{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Getting Started\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 About Version Control\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What is version control, and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. Even though the examples in this book show software source code as the files under version control, in reality any type of file on a computer can be placed under version control.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you are a graphic or web designer and want to keep every version of an image or layout (which you certainly would), it is very wise to use a Version Control System (VCS). A VCS allows you to: revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also means that if you screw things up or lose files, you can generally recover easily. In addition, you get all this for very little overhead.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Local Version Control Systems\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many people\u8217's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they\u8217're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you\u8217're in and accidentally write to the wrong file or copy over files you don\u8217't mean to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To deal with this issue, programmers long ago developed local VCSs that had a simple database that kept all the changes to files under revision control (see Figure 1-1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0101.png Figure 1-1. Local version control diagram.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the more popular VCS tools was a system called rcs, which is still distributed with many computers today. Even the popular Mac OS X operating system includes the rcs command when you install the Developer Tools. This tool basically works by keeping patch sets (that is, the differences between files) from one change to another in a special format on disk; it can then re-create what any file looked like at any point in time by adding up all the patches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Centralized Version Control Systems\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next major issue that people encounter is that they need to collaborate with developers on other systems. To deal with this problem, Centralized Version Control Systems (CVCSs) were developed. These systems, such as CVS, Subversion, and Perforce, have a single server that contains all the versioned files, and a number of clients that check out files from that central place. For many years, this has been the standard for version control (see Figure 1-2).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0102.png Figure 1-2. Centralized version control diagram.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This setup offers many advantages, especially over local VCSs. For example, everyone knows to a certain degree what everyone else on the project is doing. Administrators have fine-grained control over who can do what; and it\u8217's far easier to administer a CVCS than it is to deal with local databases on every client.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, this setup also has some serious downsides. The most obvious is the single point of failure that the centralized server represents. If that server goes down for an hour, then during that hour nobody can collaborate at all or save versioned changes to anything they\u8217're working on. If the hard disk the central database is on becomes corrupted, and proper backups haven\u8217't been kept, you lose absolutely everything\u8212-the entire history of the project except whatever single snapshots people happen to have on their local machines. Local VCS systems suffer from this same problem\u8212-whenever you have the entire history of the project in a single place, you risk losing everything.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Distributed Version Control Systems\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is where Distributed Version Control Systems (DVCSs) step in. In a DVCS (such as Git, Mercurial, Bazaar or Darcs), clients don\u8217't just check out the latest snapshot of the files: they fully mirror the repository. Thus if any server dies, and these systems were collaborating via it, any of the client repositories can be copied back up to the server to restore it. Every checkout is really a full backup of all the data (see Figure 1-3).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0103.png Figure 1-3. Distributed version control diagram.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Furthermore, many of these systems deal pretty well with having several remote repositories they can work with, so you can collaborate with different groups of people in different ways simultaneously within the same project. This allows you to set up several types of workflows that aren\u8217't possible in centralized systems, such as hierarchical models.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 A Short History of Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As with many great things in life, Git began with a bit of creative destruction and fiery controversy. The Linux kernel is an open source software project of fairly large scope. For most of the lifetime of the Linux kernel maintenance (1991\u8211-2002), changes to the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS system called BitKeeper.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool\u8217's free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to develop their own tool based on some of the lessons they learned while using BitKeeper. Some of the goals of the new system were as follows:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Speed\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Simple design\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Strong support for non-linear development (thousands of parallel branches)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Fully distributed\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Able to handle large projects like the Linux kernel efficiently (speed and data size)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Since its birth in 2005, Git has evolved and matured to be easy to use and yet retain these initial qualities. It\u8217's incredibly fast, it\u8217's very efficient with large projects, and it has an incredible branching system for non-linear development (See Chapter 3).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Basics\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So, what is Git in a nutshell? This is an important section to absorb, because if you understand what Git is and the fundamentals of how it works, then using Git effectively will probably be much easier for you. As you learn Git, try to clear your mind of the things you may know about other VCSs, such as Subversion and Perforce; doing so will help you avoid subtle confusion when using the tool. Git stores and thinks about information much differently than these other systems, even though the user interface is fairly similar; understanding those differences will help prevent you from becoming confused while using it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Snapshots, Not Differences\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The major difference between Git and any other VCS (Subversion and friends included) is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a set of files and the changes made to each file over time, as illustrated in Figure 1-4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0104.png Figure 1-4. Other systems tend to store data as changes to a base version of each file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git doesn\u8217't think of or store its data this way. Instead, Git thinks of its data more like a set of snapshots of a mini filesystem. Every time you commit, or save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot. To be efficient, if files have not changed, Git doesn\u8217't store the file again\u8212-just a link to the previous identical file it has already stored. Git thinks about its data more like Figure 1-5.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0105.png Figure 1-5. Git stores data as snapshots of the project over time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is an important distinction between Git and nearly all other VCSs. It makes Git reconsider almost every aspect of version control that most other systems copied from the previous generation. This makes Git more like a mini filesystem with some incredibly powerful tools built on top of it, rather than simply a VCS. We\u8217'll explore some of the benefits you gain by thinking of your data this way when we cover Git branching in Chapter 3.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Nearly Every Operation Is Local\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Most operations in Git only need local files and resources to operate \u8212- generally no information is needed from another computer on your network. If you\u8217're used to a CVCS where most operations have that network latency overhead, this aspect of Git will make you think that the gods of speed have blessed Git with unworldly powers. Because you have the entire history of the project right there on your local disk, most operations seem almost instantaneous.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, to browse the history of the project, Git doesn\u8217't need to go out to the server to get the history and display it for you\u8212-it simply reads it directly from your local database. This means you see the project history almost instantly. If you want to see the changes introduced between the current version of a file and the file a month ago, Git can look up the file a month ago and do a local difference calculation, instead of having to either ask a remote server to do it or pull an older version of the file from the remote server to do it locally.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This also means that there is very little you can\u8217't do if you\u8217're offline or off VPN. If you get on an airplane or a train and want to do a little work, you can commit happily until you get to a network connection to upload. If you go home and can\u8217't get your VPN client working properly, you can still work. In many other systems, doing so is either impossible or painful. In Perforce, for example, you can\u8217't do much when you aren\u8217't connected to the server; and in Subversion and CVS, you can edit files, but you can\u8217't commit changes to your database (because your database is offline). This may not seem like a huge deal, but you may be surprised what a big difference it can make.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Git Has Integrity\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Everything in Git is check-summed before it is stored and is then referred to by that checksum. This means it\u8217's impossible to change the contents of any file or directory without Git knowing about it. This functionality is built into Git at the lowest levels and is integral to its philosophy. You can\u8217't lose information in transit or get file corruption without Git being able to detect it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The mechanism that Git uses for this checksumming is called a SHA-1 hash. This is a 40-character string composed of hexadecimal characters (0\u8211-9 and a\u8211-f) and calculated based on the contents of a file or directory structure in Git. A SHA-1 hash looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 24b9da6552252987aa493b52f8696cd6d3b00373\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You will see these hash values all over the place in Git because it uses them so much. In fact, Git stores everything not by file name but in the Git database addressable by the hash value of its contents.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Git Generally Only Adds Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you do actions in Git, nearly all of them only add data to the Git database. It is very difficult to get the system to do anything that is not undoable or to make it erase data in any way. As in any VCS, you can lose or mess up changes you haven\u8217't committed yet; but after you commit a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This makes using Git a joy because we know we can experiment without the danger of severely screwing things up. For a more in-depth look at how Git stores its data and how you can recover data that seems lost, see Chapter 9.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Three States\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, pay attention. This is the main thing to remember about Git if you want the rest of your learning process to go smoothly. Git has three main states that your files can reside in: committed, modified, and staged. Committed means that the data is safely stored in your local database. Modified means that you have changed the file but have not committed it to your database yet. Staged means that you have marked a modified file in its current version to go into your next commit snapshot.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This leads us to the three main sections of a Git project: the Git directory, the working directory, and the staging area.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0106.png Figure 1-6. Working directory, staging area, and git directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The working directory is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The staging area is a simple file, generally contained in your Git directory, that stores information about what will go into your next commit. It\u8217's sometimes referred to as the index, but it\u8217's becoming standard to refer to it as the staging area.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The basic Git workflow goes something like this:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab You modify files in your working directory.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab You stage the files, adding snapshots of them to your staging area.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a particular version of a file is in the git directory, it\u8217's considered committed. If it\u8217's modified but has been added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified. In Chapter 2, you\u8217'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Installing Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's get into using some Git. First things first\u8212-you have to install it. You can get it a number of ways; the two major ones are to install it from source or to install an existing package for your platform.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing from Source\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you can, it\u8217's generally useful to install Git from source, because you\u8217'll get the most recent version. Each version of Git tends to include useful UI enhancements, so getting the latest version is often the best route if you feel comfortable compiling software from source. It is also the case that many Linux distributions contain very old packages; so unless you\u8217're on a very up-to-date distro or are using backports, installing from source may be the best bet.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To install Git, you need to have the following libraries that Git depends on: curl, zlib, openssl, expat, and libiconv. For example, if you\u8217're on a system that has yum (such as Fedora) or apt-get (such as a Debian based system), you can use one of these commands to install all of the dependencies:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ yum install curl-devel expat-devel gettext-devel \\\line
  openssl-devel zlib-devel\line
\line
$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\line
  libz-dev libssl-dev\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you have all the necessary dependencies, you can go ahead and grab the latest snapshot from the Git web site:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 http://git-scm.com/download\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, compile and install:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ tar -zxf git-1.7.2.2.tar.gz\line
$ cd git-1.7.2.2\line
$ make prefix=/usr/local all\line
$ sudo make prefix=/usr/local install\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After this is done, you can also get Git via Git itself for updates:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://git.kernel.org/pub/scm/git/git.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing on Linux\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to install Git on Linux via a binary installer, you can generally do so through the basic package-management tool that comes with your distribution. If you\u8217're on Fedora, you can use yum:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ yum install git-core\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or if you\u8217're on a Debian-based distribution like Ubuntu, try apt-get:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ apt-get install git-core\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing on Mac\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are two easy ways to install Git on a Mac. The easiest is to use the graphical Git installer, which you can download from the Google Code page (see Figure 1-7):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 http://code.google.com/p/git-osx-installer\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0107.png Figure 1-7. Git OS X installer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other major way is to install Git via MacPorts ({\f1 http://www.macports.org}). If you have MacPorts installed, install Git via\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo port install git-core +svn +doc +bash_completion +gitweb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You don\u8217't have to add all the extras, but you\u8217'll probably want to include +svn in case you ever have to use Git with Subversion repositories (see Chapter 8).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing on Windows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Installing Git on Windows is very easy. The msysGit project has one of the easier installation procedures. Simply download the installer exe file from the Google Code page, and run it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 http://code.google.com/p/msysgit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After it\u8217's installed, you have both a command-line version (including an SSH client that will come in handy later) and the standard GUI.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note on Windows usage: you should use Git with the provided msysGit shell (Unix style), it allows to use the complex lines of command given in this book. If you need, for some reason, to use the native Windows shell / command line console, you have to use double quotes instead of simple quotes (for parameters with spaces in them) and you must quote the parameters ending with the circumflex accent (^) if they are last on the line, as it is a continuation symbol in Windows.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 First-Time Git Setup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have Git on your system, you\u8217'll want to do a few things to customize your Git environment. You should have to do these things only once; they\u8217'll stick around between upgrades. You can also change them at any time by running through the commands again.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git comes with a tool called git config that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 /etc/gitconfig} file: Contains values for every user on the system and all their repositories. If you pass the option{\f1 --system} to {\f1 git config}, it reads and writes from this file specifically.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 ~/.gitconfig} file: Specific to your user. You can make Git read and write to this file specifically by passing the {\f1 --global} option.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab config file in the git directory (that is, {\f1 .git/config}) of whatever repository you\u8217're currently using: Specific to that single repository. Each level overrides values in the previous level, so values in {\f1 .git/config} trump those in {\f1 /etc/gitconfig}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 On Windows systems, Git looks for the {\f1 .gitconfig} file in the {\f1 $HOME} directory ({\f1 %USERPROFILE%} in Windows\u8217' environment), which is {\f1 C:\\Documents and Settings\\$USER} or {\f1 C:\\Users\\$USER} for most people, depending on version ({\f1 $USER} is {\f1 %USERNAME%} in Windows\u8217' environment). It also still looks for /etc/gitconfig, although it\u8217's relative to the MSys root, which is wherever you decide to install Git on your Windows system when you run the installer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Your Identity\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first thing you should do when you install Git is to set your user name and e-mail address. This is important because every Git commit uses this information, and it\u8217's immutably baked into the commits you pass around:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global user.name "John Doe"\line
$ git config --global user.email johndoe@example.com\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, you need to do this only once if you pass the {\f1 --global} option, because then Git will always use that information for anything you do on that system. If you want to override this with a different name or e-mail address for specific projects, you can run the command without the {\f1 --global} option when you\u8217're in that project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Your Editor\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that your identity is set up, you can configure the default text editor that will be used when Git needs you to type in a message. By default, Git uses your system\u8217's default editor, which is generally Vi or Vim. If you want to use a different text editor, such as Emacs, you can do the following:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.editor emacs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Your Diff Tool\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another useful option you may want to configure is the default diff tool to use to resolve merge conflicts. Say you want to use vimdiff:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global merge.tool vimdiff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git accepts kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, ecmerge, and opendiff as valid merge tools. You can also set up a custom tool; see Chapter 7 for more information about doing that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Checking Your Settings\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to check your settings, you can use the {\f1 git config --list} command to list all the settings Git can find at that point:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --list\line
user.name=Scott Chacon\line
user.email=schacon@gmail.com\line
color.status=auto\line
color.branch=auto\line
color.interactive=auto\line
color.diff=auto\line
...\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may see keys more than once, because Git reads the same key from different files ({\f1 /etc/gitconfig} and {\f1 ~/.gitconfig}, for example). In this case, Git uses the last value for each unique key it sees.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also check what Git thinks a specific key\u8217's value is by typing {\f1 git config \{key\}}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config user.name\line
Scott Chacon\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Getting Help\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you ever need help while using Git, there are three ways to get the manual page (manpage) help for any of the Git commands:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git help <verb>\line
$ git <verb> --help\line
$ man git-<verb>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, you can get the manpage help for the config command by running\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git help config\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These commands are nice because you can access them anywhere, even offline. If the manpages and this book aren\u8217't enough and you need in-person help, you can try the {\f1 #git} or {\f1 #github} channel on the Freenode IRC server (irc.freenode.net). These channels are regularly filled with hundreds of people who are all very knowledgeable about Git and are often willing to help.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should have a basic understanding of what Git is and how it\u8217's different from the CVCS you may have been using. You should also now have a working version of Git on your system that\u8217's set up with your personal identity. It\u8217's now time to learn some Git basics.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git Basics\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you can read only one chapter to get going with Git, this is it. This chapter covers every basic command you need to do the vast majority of the things you\u8217'll eventually spend your time doing with Git. By the end of the chapter, you should be able to configure and initialize a repository, begin and stop tracking files, and stage and commit changes. We\u8217'll also show you how to set up Git to ignore certain files and file patterns, how to undo mistakes quickly and easily, how to browse the history of your project and view changes between commits, and how to push and pull from remote repositories.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Getting a Git Repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can get a Git project using two main approaches. The first takes an existing project or directory and imports it into Git. The second clones an existing Git repository from another server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Initializing a Repository in an Existing Directory\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're starting to track an existing project in Git, you need to go to the project\u8217's directory and type\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git init\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This creates a new subdirectory named {\f1 .git} that contains all of your necessary repository files \u8212- a Git repository skeleton. At this point, nothing in your project is tracked yet. (See {\i Chapter 9} for more information about exactly what files are contained in the {\f1 .git} directory you just created.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few {\f1 git add} commands that specify the files you want to track, followed by a commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add *.c\line
$ git add README\line
$ git commit -m 'initial project version'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We\u8217'll go over what these commands do in just a minute. At this point, you have a Git repository with tracked files and an initial commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Cloning an Existing Repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to get a copy of an existing Git repository \u8212- for example, a project you\u8217'd like to contribute to \u8212- the command you need is {\f1 git clone}. If you\u8217're familiar with other VCS systems such as Subversion, you\u8217'll notice that the command is {\f1 clone} and not {\f1 checkout}. This is an important distinction \u8212- Git receives a copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down when you run {\f1 git clone}. In fact, if your server disk gets corrupted, you can use any of the clones on any client to set the server back to the state it was in when it was cloned (you may lose some server-side hooks and such, but all the versioned data would be there \u8212- see {\i Chapter 4} for more details).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You clone a repository with {\f1 git clone [url]}. For example, if you want to clone the Ruby Git library called Grit, you can do so like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://github.com/schacon/grit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That creates a directory named {\f1 grit}, initializes a {\f1 .git} directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version. If you go into the new {\f1 grit} directory, you\u8217'll see the project files in there, ready to be worked on or used. If you want to clone the repository into a directory named something other than grit, you can specify that as the next command-line option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://github.com/schacon/grit.git mygrit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That command does the same thing as the previous one, but the target directory is called {\f1 mygrit}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git has a number of different transfer protocols you can use. The previous example uses the {\f1 git://} protocol, but you may also see {\f1 http(s)://} or {\f1 user@server:/path.git}, which uses the SSH transfer protocol. {\i Chapter 4} will introduce all of the available options the server can set up to access your Git repository and the pros and cons of each.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Recording Changes to the Repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have a bona fide Git repository and a checkout or working copy of the files for that project. You need to make some changes and commit snapshots of those changes into your repository each time the project reaches a state you want to record.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember that each file in your working directory can be in one of two states: {\i tracked} or {\i untracked}. {\i Tracked} files are files that were in the last snapshot; they can be {\i unmodified}, {\i modified}, or {\i staged}. {\i Untracked} files are everything else \u8212- any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because you just checked them out and haven\u8217't edited anything.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you edit files, Git sees them as modified, because you\u8217've changed them since your last commit. You {\i stage} these modified files and then commit all your staged changes, and the cycle repeats. This lifecycle is illustrated in Figure 2-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0201.png Figure 2-1. The lifecycle of the status of your files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Checking the Status of Your Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The main tool you use to determine which files are in which state is the {\f1 git status} command. If you run this command directly after a clone, you should see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
nothing to commit (working directory clean)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means you have a clean working directory \u8212- in other words, no tracked files are modified. Git also doesn\u8217't see any untracked files, or they would be listed here. Finally, the command tells you which branch you\u8217're on. For now, that is always {\f1 master}, which is the default; you won\u8217't worry about it here. The next chapter will go over branches and references in detail.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say you add a new file to your project, a simple {\f1 README} file. If the file didn\u8217't exist before, and you run {\f1 git status}, you see your untracked file like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim README\line
$ git status\line
# On branch master\line
# Untracked files:\line
#   (use "git add <file>..." to include in what will be committed)\line
#\line
#   README\line
nothing added to commit but untracked files present (use "git add" to track)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that your new {\f1 README} file is untracked, because it\u8217's under the \u8220"Untracked files\u8221" heading in your status output. Untracked basically means that Git sees a file you didn\u8217't have in the previous snapshot (commit); Git won\u8217't start including it in your commit snapshots until you explicitly tell it to do so. It does this so you don\u8217't accidentally begin including generated binary files or other files that you did not mean to include. You do want to start including README, so let\u8217's start tracking the file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tracking New Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In order to begin tracking a new file, you use the command {\f1 git add}. To begin tracking the {\f1 README} file, you can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add README\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run your status command again, you can see that your {\f1 README} file is now tracked and staged:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can tell that it\u8217's staged because it\u8217's under the \u8220"Changes to be committed\u8221" heading. If you commit at this point, the version of the file at the time you ran {\f1 git add} is what will be in the historical snapshot. You may recall that when you ran {\f1 git init} earlier, you then ran {\f1 git add (files)} \u8212- that was to begin tracking files in your directory. The {\f1 git add} command takes a path name for either a file or a directory; if it\u8217's a directory, the command adds all the files in that directory recursively.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Staging Modified Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's change a file that was already tracked. If you change a previously tracked file called {\f1 benchmarks.rb} and then run your {\f1 status} command again, you get something that looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 benchmarks.rb} file appears under a section named \u8220"Changes not staged for commit\u8221" \u8212- which means that a file that is tracked has been modified in the working directory but not yet staged. To stage it, you run the {\f1 git add} command (it\u8217's a multipurpose command \u8212- you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved). Let\u8217's run {\f1 git add} now to stage the {\f1 benchmarks.rb} file, and then run {\f1 git status} again:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add benchmarks.rb\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Both files are staged and will go into your next commit. At this point, suppose you remember one little change that you want to make in {\f1 benchmarks.rb} before you commit it. You open it again and make that change, and you\u8217're ready to commit. However, let\u8217's run {\f1 git status} one more time:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim benchmarks.rb\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#   modified:   benchmarks.rb\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What the heck? Now {\f1 benchmarks.rb} is listed as both staged and unstaged. How is that possible? It turns out that Git stages a file exactly as it is when you run the {\f1 git add} command. If you commit now, the version of {\f1 benchmarks.rb} as it was when you last ran the {\f1 git add} command is how it will go into the commit, not the version of the file as it looks in your working directory when you run {\f1 git commit}. If you modify a file after you run {\f1 git add}, you have to run {\f1 git add} again to stage the latest version of the file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add benchmarks.rb\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ignoring Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Often, you\u8217'll have a class of files that you don\u8217't want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named {\f1 .gitignore}. Here is an example {\f1 .gitignore} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .gitignore\line
*.[oa]\line
*~\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first line tells Git to ignore any files ending in {\f1 .o} or {\f1 .a} \u8212- {\i object} and {\i archive} files that may be the product of building your code. The second line tells Git to ignore all files that end with a tilde ({\f1 ~}), which is used by many text editors such as Emacs to mark temporary files. You may also include a {\f1 log}, {\f1 tmp}, or {\f1 pid} directory; automatically generated documentation; and so on. Setting up a {\f1 .gitignore} file before you get going is generally a good idea so you don\u8217't accidentally commit files that you really don\u8217't want in your Git repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The rules for the patterns you can put in the {\f1 .gitignore} file are as follows:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Blank lines or lines starting with {\f1 #} are ignored.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Standard glob patterns work.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab You can end patterns with a forward slash ({\f1 /}) to specify a directory.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab You can negate a pattern by starting it with an exclamation point ({\f1 !}).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Glob patterns are like simplified regular expressions that shells use. An asterisk ({\f1 *}) matches zero or more characters; {\f1 [abc]} matches any character inside the brackets (in this case {\f1 a}, {\f1 b}, or {\f1 c}); a question mark ({\f1 ?}) matches a single character; and brackets enclosing characters separated by a hyphen({\f1 [0-9]}) matches any character in the range (in this case 0 through 9) .\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here is another example {\f1 .gitignore} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # a comment - this is ignored\line
*.a       # no .a files\line
!lib.a    # but do track lib.a, even though you're ignoring .a files above\line
/TODO     # only ignore the root TODO file, not subdir/TODO\line
build/    # ignore all files in the build/ directory\line
doc/*.txt # ignore doc/notes.txt, but not doc/server/arch.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Viewing Your Staged and Unstaged Changes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the {\f1 git status} command is too vague for you \u8212- you want to know exactly what you changed, not just which files were changed \u8212- you can use the {\f1 git diff} command. We\u8217'll cover {\f1 git diff} in more detail later; but you\u8217'll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although {\f1 git status} answers those questions very generally, {\f1 git diff} shows you the exact lines added and removed \u8212- the patch, as it were.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say you edit and stage the {\f1 README} file again and then edit the {\f1 benchmarks.rb} file without staging it. If you run your {\f1 status} command, you once again see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   new file:   README\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see what you\u8217've changed but not yet staged, type {\f1 git diff} with no other arguments:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff\line
diff --git a/benchmarks.rb b/benchmarks.rb\line
index 3cb747f..da65585 100644\line
--- a/benchmarks.rb\line
+++ b/benchmarks.rb\line
@@ -36,6 +36,10 @@ def main\line
           @commit.parents[0].parents[0].parents[0]\line
         end\line
\line
+        run_code(x, 'commits 1') do\line
+          git.commits.size\line
+        end\line
+\line
         run_code(x, 'commits 2') do\line
           log = git.commits('master', 15)\line
           log.size\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That command compares what is in your working directory with what is in your staging area. The result tells you the changes you\u8217've made that you haven\u8217't yet staged.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to see what you\u8217've staged that will go into your next commit, you can use {\f1 git diff --cached}. (In Git versions 1.6.1 and later, you can also use {\f1 git diff --staged}, which may be easier to remember.) This command compares your staged changes to your last commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff --cached\line
diff --git a/README b/README\line
new file mode 100644\line
index 0000000..03902a1\line
--- /dev/null\line
+++ b/README2\line
@@ -0,0 +1,5 @@\line
+grit\line
+ by Tom Preston-Werner, Chris Wanstrath\line
+ http://github.com/mojombo/grit\line
+\line
+Grit is a Ruby library for extracting information from a Git repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that {\f1 git diff} by itself doesn\u8217't show all changes made since your last commit \u8212- only changes that are still unstaged. This can be confusing, because if you\u8217've staged all of your changes, {\f1 git diff} will give you no output.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For another example, if you stage the {\f1 benchmarks.rb} file and then edit it, you can use {\f1 git diff} to see the changes in the file that are staged and the changes that are unstaged:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add benchmarks.rb\line
$ echo '# test line' >> benchmarks.rb\line
$ git status\line
# On branch master\line
#\line
# Changes to be committed:\line
#\line
#   modified:   benchmarks.rb\line
#\line
# Changes not staged for commit:\line
#\line
#   modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can use {\f1 git diff} to see what is still unstaged\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff\line
diff --git a/benchmarks.rb b/benchmarks.rb\line
index e445e28..86b2f7c 100644\line
--- a/benchmarks.rb\line
+++ b/benchmarks.rb\line
@@ -127,3 +127,4 @@ end\line
 main()\line
\line
 ##pp Grit::GitRuby.cache_client.stats\line
+# test line\par}
{\pard \ql \f0 \sa180 \li0 \fi0 and {\f1 git diff --cached} to see what you\u8217've staged so far:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff --cached\line
diff --git a/benchmarks.rb b/benchmarks.rb\line
index 3cb747f..e445e28 100644\line
--- a/benchmarks.rb\line
+++ b/benchmarks.rb\line
@@ -36,6 +36,10 @@ def main\line
          @commit.parents[0].parents[0].parents[0]\line
        end\line
\line
+        run_code(x, 'commits 1') do\line
+          git.commits.size\line
+        end\line
+\line
        run_code(x, 'commits 2') do\line
          log = git.commits('master', 15)\line
          log.size\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Committing Your Changes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged \u8212- any files you have created or modified that you haven\u8217't run {\f1 git add} on since you edited them \u8212- won\u8217't go into this commit. They will stay as modified files on your disk. In this case, the last time you ran {\f1 git status}, you saw that everything was staged, so you\u8217're ready to commit your changes. The simplest way to commit is to type {\f1 git commit}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Doing so launches your editor of choice. (This is set by your shell\u8217's {\f1 $EDITOR} environment variable \u8212- usually vim or emacs, although you can configure it with whatever you want using the {\f1 git config --global core.editor} command as you saw in {\i Chapter 1}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The editor displays the following text (this example is a Vim screen):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Please enter the commit message for your changes. Lines starting\line
# with '#' will be ignored, and an empty message aborts the commit.\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       new file:   README\line
#       modified:   benchmarks.rb\line
~\line
~\line
~\line
".git/COMMIT_EDITMSG" 10L, 283C\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that the default commit message contains the latest output of the {\f1 git status} command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u8217're committing. (For an even more explicit reminder of what you\u8217've modified, you can pass the {\f1 -v} option to {\f1 git commit}. Doing so also puts the diff of your change in the editor so you can see exactly what you did.) When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Alternatively, you can type your commit message inline with the {\f1 commit} command by specifying it after a {\f1 -m} flag, like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -m "Story 182: Fix benchmarks for speed"\line
[master]: created 463dc4f: "Fix benchmarks for speed"\line
 2 files changed, 3 insertions(+), 0 deletions(-)\line
 create mode 100644 README\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217've created your first commit! You can see that the commit has given you some output about itself: which branch you committed to ({\f1 master}), what SHA-1 checksum the commit has ({\f1 463dc4f}), how many files were changed, and statistics about lines added and removed in the commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember that the commit records the snapshot you set up in your staging area. Anything you didn\u8217't stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you\u8217're recording a snapshot of your project that you can revert to or compare to later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Skipping the Staging Area\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow. If you want to skip the staging area, Git provides a simple shortcut. Providing the {\f1 -a} option to the {\f1 git commit} command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the {\f1 git add} part:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
#\line
# Changes not staged for commit:\line
#\line
#   modified:   benchmarks.rb\line
#\line
$ git commit -a -m 'added new benchmarks'\line
[master 83e38c7] added new benchmarks\line
 1 files changed, 5 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice how you don\u8217't have to run {\f1 git add} on the {\f1 benchmarks.rb} file in this case before you commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Removing Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit. The {\f1 git rm} command does that and also removes the file from your working directory so you don\u8217't see it as an untracked file next time around.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you simply remove the file from your working directory, it shows up under the \u8220"Changes not staged for commit\u8221" (that is, {\i unstaged}) area of your {\f1 git status} output:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rm grit.gemspec\line
$ git status\line
# On branch master\line
#\line
# Changes not staged for commit:\line
#   (use "git add/rm <file>..." to update what will be committed)\line
#\line
#       deleted:    grit.gemspec\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, if you run {\f1 git rm}, it stages the file\u8217's removal:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm grit.gemspec\line
rm 'grit.gemspec'\line
$ git status\line
# On branch master\line
#\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       deleted:    grit.gemspec\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next time you commit, the file will be gone and no longer tracked. If you modified the file and added it to the index already, you must force the removal with the {\f1 -f} option. This is a safety feature to prevent accidental removal of data that hasn\u8217't yet been recorded in a snapshot and that can\u8217't be recovered from Git.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your {\f1 .gitignore} file and accidentally added it, like a large log file or a bunch of {\f1 .a} compiled files. To do this, use the {\f1 --cached} option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm --cached readme.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can pass files, directories, and file-glob patterns to the {\f1 git rm} command. That means you can do things such as\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm log/\\*.log\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note the backslash ({\f1 \\}) in front of the {\f1 *}. This is necessary because Git does its own filename expansion in addition to your shell\u8217's filename expansion. On Windows with the system console, the backslash must be omitted. This command removes all files that have the {\f1 .log} extension in the {\f1 log/} directory. Or, you can do something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm \\*~\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command removes all files that end with {\f1 ~}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Moving Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unlike many other VCS systems, Git doesn\u8217't explicitly track file movement. If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file. However, Git is pretty smart about figuring that out after the fact \u8212- we\u8217'll deal with detecting file movement a bit later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Thus it\u8217's a bit confusing that Git has a {\f1 mv} command. If you want to rename a file in Git, you can run something like\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git mv file_from file_to\par}
{\pard \ql \f0 \sa180 \li0 \fi0 and it works fine. In fact, if you run something like this and look at the status, you\u8217'll see that Git considers it a renamed file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git mv README.txt README\line
$ git status\line
# On branch master\line
# Your branch is ahead of 'origin/master' by 1 commit.\line
#\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       renamed:    README.txt -> README\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, this is equivalent to running something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ mv README.txt README\line
$ git rm README.txt\line
$ git add README\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git figures out that it\u8217's a rename implicitly, so it doesn\u8217't matter if you rename a file that way or with the {\f1 mv} command. The only real difference is that {\f1 mv} is one command instead of three \u8212- it\u8217's a convenience function. More important, you can use any tool you like to rename a file, and address the add/rm later, before you commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Viewing the Commit History\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After you have created several commits, or if you have cloned a repository with an existing commit history, you\u8217'll probably want to look back to see what has happened. The most basic and powerful tool to do this is the {\f1 git log} command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These examples use a very simple project called {\f1 simplegit} that I often use for demonstrations. To get the project, run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git clone git://github.com/schacon/simplegit-progit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you run {\f1 git log} in this project, you should get output that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log\line
commit ca82a6dff817ec66f44342007202690a93763949\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Mar 17 21:52:11 2008 -0700\line
\line
    changed the version number\line
\line
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sat Mar 15 16:40:33 2008 -0700\line
\line
    removed unnecessary test code\line
\line
commit a11bef06a3f659402fe7563abf99ad00de2209e6\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sat Mar 15 10:31:28 2008 -0700\line
\line
    first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By default, with no arguments, {\f1 git log} lists the commits made in that repository in reverse chronological order. That is, the most recent commits show up first. As you can see, this command lists each commit with its SHA-1 checksum, the author\u8217's name and e-mail, the date written, and the commit message.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A huge number and variety of options to the {\f1 git log} command are available to show you exactly what you\u8217're looking for. Here, we\u8217'll show you some of the most-used options.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the more helpful options is {\f1 -p}, which shows the diff introduced in each commit. You can also use {\f1 -2}, which limits the output to only the last two entries:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -p -2\line
commit ca82a6dff817ec66f44342007202690a93763949\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Mar 17 21:52:11 2008 -0700\line
\line
    changed the version number\line
\line
diff --git a/Rakefile b/Rakefile\line
index a874b73..8f94139 100644\line
--- a/Rakefile\line
+++ b/Rakefile\line
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'\line
 spec = Gem::Specification.new do |s|\line
-    s.version   =   "0.1.0"\line
+    s.version   =   "0.1.1"\line
     s.author    =   "Scott Chacon"\line
\line
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sat Mar 15 16:40:33 2008 -0700\line
\line
    removed unnecessary test code\line
\line
diff --git a/lib/simplegit.rb b/lib/simplegit.rb\line
index a0a60ae..47c6340 100644\line
--- a/lib/simplegit.rb\line
+++ b/lib/simplegit.rb\line
@@ -18,8 +18,3 @@ class SimpleGit\line
     end\line
\line
 end\line
-\line
-if $0 == __FILE__\line
-  git = SimpleGit.new\line
-  puts git.show\line
-end\line
\\ No newline at end of file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This option displays the same information but with a diff directly following each entry. This is very helpful for code review or to quickly browse what happened during a series of commits that a collaborator has added. You can also use a series of summarizing options with {\f1 git log}. For example, if you want to see some abbreviated stats for each commit, you can use the {\f1 --stat} option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --stat\line
commit ca82a6dff817ec66f44342007202690a93763949\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Mar 17 21:52:11 2008 -0700\line
\line
    changed the version number\line
\line
 Rakefile |    2 +-\line
 1 files changed, 1 insertions(+), 1 deletions(-)\line
\line
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sat Mar 15 16:40:33 2008 -0700\line
\line
    removed unnecessary test code\line
\line
 lib/simplegit.rb |    5 -----\line
 1 files changed, 0 insertions(+), 5 deletions(-)\line
\line
commit a11bef06a3f659402fe7563abf99ad00de2209e6\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sat Mar 15 10:31:28 2008 -0700\line
\line
    first commit\line
\line
 README           |    6 ++++++\line
 Rakefile         |   23 +++++++++++++++++++++++\line
 lib/simplegit.rb |   25 +++++++++++++++++++++++++\line
 3 files changed, 54 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you can see, the {\f1 --stat} option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. Another really useful option is {\f1 --pretty}. This option changes the log output to formats other than the default. A few prebuilt options are available for you to use. The {\f1 oneline} option prints each commit on a single line, which is useful if you\u8217're looking at a lot of commits. In addition, the {\f1 short}, {\f1 full}, and {\f1 fuller} options show the output in roughly the same format but with less or more information, respectively:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline\line
ca82a6dff817ec66f44342007202690a93763949 changed the version number\line
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code\line
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The most interesting option is {\f1 format}, which allows you to specify your own log output format. This is especially useful when you\u8217're generating output for machine parsing \u8212- because you specify the format explicitly, you know it won\u8217't change with updates to Git:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=format:"%h - %an, %ar : %s"\line
ca82a6d - Scott Chacon, 11 months ago : changed the version number\line
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code\line
a11bef0 - Scott Chacon, 11 months ago : first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Table 2-1 lists some of the more useful options that format takes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Option  Description of Output\line
%H  Commit hash\line
%h  Abbreviated commit hash\line
%T  Tree hash\line
%t  Abbreviated tree hash\line
%P  Parent hashes\line
%p  Abbreviated parent hashes\line
%an Author name\line
%ae Author e-mail\line
%ad Author date (format respects the --date= option)\line
%ar Author date, relative\line
%cn Committer name\line
%ce Committer email\line
%cd Committer date\line
%cr Committer date, relative\line
%s  Subject\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may be wondering what the difference is between {\i author} and {\i committer}. The {\i author} is the person who originally wrote the patch, whereas the {\i committer} is the person who last applied the patch. So, if you send in a patch to a project and one of the core members applies the patch, both of you get credit \u8212- you as the author and the core member as the committer. We\u8217'll cover this distinction a bit more in {\i Chapter 5}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 oneline} and {\f1 format} options are particularly useful with another {\f1 log} option called {\f1 --graph}. This option adds a nice little ASCII graph showing your branch and merge history, which we can see our copy of the Grit project repository:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=format:"%h %s" --graph\line
* 2d3acf9 ignore errors from SIGCHLD on trap\line
*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\line
|\\\line
| * 420eac9 Added a method for getting the current branch.\line
* | 30e367c timeout code and tests\line
* | 5a09431 add timeout protection to grit\line
* | e1193f8 support for heads with slashes in them\line
|/\line
* d6016bc require time for xmlschema\line
*  11d191e Merge branch 'defunkt' into local\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Those are only some simple output-formatting options to {\f1 git log} \u8212- there are many more. Table 2-2 lists the options we\u8217've covered so far and some other common formatting options that may be useful, along with how they change the output of the {\f1 log} command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Option  Description\line
-p  Show the patch introduced with each commit.\line
--stat  Show statistics for files modified in each commit.\line
--shortstat Display only the changed/insertions/deletions line from the --stat command.\line
--name-only Show the list of files modified after the commit information.\line
--name-status   Show the list of files affected with added/modified/deleted information as well.\line
--abbrev-commit Show only the first few characters of the SHA-1 checksum instead of all 40.\line
--relative-date Display the date in a relative format (for example, \u8220"2 weeks ago\u8221") instead of using the full date format.\line
--graph Display an ASCII graph of the branch and merge history beside the log output.\line
--pretty    Show commits in an alternate format. Options include oneline, short, full, fuller, and format (where you specify your own format).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Limiting Log Output\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to output-formatting options, {\f1 git log} takes a number of useful limiting options \u8212- that is, options that let you show only a subset of commits. You\u8217've seen one such option already \u8212- the {\f1 -2} option, which shows only the last two commits. In fact, you can do {\f1 -<n>}, where {\f1 n} is any integer to show the last {\f1 n} commits. In reality, you\u8217're unlikely to use that often, because Git by default pipes all output through a pager so you see only one page of log output at a time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, the time-limiting options such as {\f1 --since} and {\f1 --until} are very useful. For example, this command gets the list of commits made in the last two weeks:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --since=2.weeks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command works with lots of formats \u8212- you can specify a specific date (\u8220"2008-01-15\u8221") or a relative date such as \u8220"2 years 1 day 3 minutes ago\u8221".\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also filter the list to commits that match some search criteria. The {\f1 --author} option allows you to filter on a specific author, and the {\f1 --grep} option lets you search for keywords in the commit messages. (Note that if you want to specify both author and grep options, you have to add {\f1 --all-match} or the command will match commits with either.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last really useful option to pass to {\f1 git log} as a filter is a path. If you specify a directory or file name, you can limit the log output to commits that introduced a change to those files. This is always the last option and is generally preceded by double dashes ({\f1 --}) to separate the paths from the options.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In Table 2-3 we\u8217'll list these and a few other common options for your reference.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Option  Description\line
-(n)    Show only the last n commits\line
--since, --after    Limit the commits to those made after the specified date.\line
--until, --before   Limit the commits to those made before the specified date.\line
--author    Only show commits in which the author entry matches the specified string.\line
--committer Only show commits in which the committer entry matches the specified string.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, if you want to see which commits modifying test files in the Git source code history were committed by Junio Hamano in the month of October 2008 and were not merges, you can run something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \\\line
   --before="2008-11-01" --no-merges -- t/\line
5610e3b - Fix testcase failure when extended attribute\line
acd3b9e - Enhance hold_lock_file_for_\{update,append\}()\line
f563754 - demonstrate breakage of detached checkout wi\line
d1a43f2 - reset --hard/read-tree --reset -u: remove un\line
51a94af - Fix "checkout --track -b newbranch" on detac\line
b0ad11e - pull: allow "git pull origin $something:$cur\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Of the nearly 20,000 commits in the Git source code history, this command shows the 6 that match those criteria.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Using a GUI to Visualize History\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you like to use a more graphical tool to visualize your commit history, you may want to take a look at a Tcl/Tk program called {\f1 gitk} that is distributed with Git. Gitk is basically a visual {\f1 git log} tool, and it accepts nearly all the filtering options that {\f1 git log} does. If you type {\f1 gitk} on the command line in your project, you should see something like Figure 2-2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0202.png Figure 2-2. The gitk history visualizer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see the commit history in the top half of the window along with a nice ancestry graph. The diff viewer in the bottom half of the window shows you the changes introduced at any commit you click.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Undoing Things\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At any stage, you may want to undo something. Here, we\u8217'll review a few basic tools for undoing changes that you\u8217've made. Be careful, because you can\u8217't always revert some of these undos. This is one of the few areas in Git where you may lose some work if you do it wrong.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Changing Your Last Commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to try that commit again, you can run commit with the {\f1 --amend} option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit --amend\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command takes your staging area and uses it for the commit. If you\u8217've made no changes since your last commit (for instance, you run this command immediately after your previous commit), then your snapshot will look exactly the same and all you\u8217'll change is your commit message.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The same commit-message editor fires up, but it already contains the message of your previous commit. You can edit the message the same as always, but it overwrites your previous commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As an example, if you commit and then realize you forgot to stage the changes in a file you wanted to add to this commit, you can do something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -m 'initial commit'\line
$ git add forgotten_file\line
$ git commit --amend\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After these three commands, you end up with a single commit \u8212- the second commit replaces the results of the first.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unstaging a Staged File\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next two sections demonstrate how to wrangle your staging area and working directory changes. The nice part is that the command you use to determine the state of those two areas also reminds you how to undo changes to them. For example, let\u8217's say you\u8217've changed two files and want to commit them as two separate changes, but you accidentally type {\f1 git add *} and stage them both. How can you unstage one of the two? The {\f1 git status} command reminds you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add .\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       modified:   README.txt\line
#       modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Right below the \u8220"Changes to be committed\u8221" text, it says \u8220"use {\f1 git reset HEAD <file>...} to unstage\u8221". So, let\u8217's use that advice to unstage the {\f1 benchmarks.rb} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git reset HEAD benchmarks.rb\line
benchmarks.rb: locally modified\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       modified:   README.txt\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#   (use "git checkout -- <file>..." to discard changes in working directory)\line
#\line
#       modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The command is a bit strange, but it works. The {\f1 benchmarks.rb} file is modified but once again unstaged.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Unmodifying a Modified File\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What if you realize that you don\u8217't want to keep your changes to the {\f1 benchmarks.rb} file? How can you easily unmodify it \u8212- revert it back to what it looked like when you last committed (or initially cloned, or however you got it into your working directory)? Luckily, {\f1 git status} tells you how to do that, too. In the last example output, the unstaged area looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#   (use "git checkout -- <file>..." to discard changes in working directory)\line
#\line
#       modified:   benchmarks.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It tells you pretty explicitly how to discard the changes you\u8217've made (at least, the newer versions of Git, 1.6.1 and later, do this \u8212- if you have an older version, we highly recommend upgrading it to get some of these nicer usability features). Let\u8217's do what it says:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -- benchmarks.rb\line
$ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#       modified:   README.txt\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that the changes have been reverted. You should also realize that this is a dangerous command: any changes you made to that file are gone \u8212- you just copied another file over it. Don\u8217't ever use this command unless you absolutely know that you don\u8217't want the file. If you just need to get it out of the way, we\u8217'll go over stashing and branching in the next chapter; these are generally better ways to go.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember, anything that is committed in Git can almost always be recovered. Even commits that were on branches that were deleted or commits that were overwritten with an {\f1 --amend} commit can be recovered (see {\i Chapter 9} for data recovery). However, anything you lose that was never committed is likely never to be seen again.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Working with Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To be able to collaborate on any Git project, you need to know how to manage your remote repositories. Remote repositories are versions of your project that are hosted on the Internet or network somewhere. You can have several of them, each of which generally is either read-only or read/write for you. Collaborating with others involves managing these remote repositories and pushing and pulling data to and from them when you need to share work. Managing remote repositories includes knowing how to add remote repositories, remove remotes that are no longer valid, manage various remote branches and define them as being tracked or not, and more. In this section, we\u8217'll cover these remote-management skills.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Showing Your Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see which remote servers you have configured, you can run the {\f1 git remote} command. It lists the shortnames of each remote handle you\u8217've specified. If you\u8217've cloned your repository, you should at least see {\i origin} \u8212- that is the default name Git gives to the server you cloned from:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://github.com/schacon/ticgit.git\line
Initialized empty Git repository in /private/tmp/ticgit/.git/\line
remote: Counting objects: 595, done.\line
remote: Compressing objects: 100% (269/269), done.\line
remote: Total 595 (delta 255), reused 589 (delta 253)\line
Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.\line
Resolving deltas: 100% (255/255), done.\line
$ cd ticgit\line
$ git remote\line
origin\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also specify {\f1 -v}, which shows you the URL that Git has stored for the shortname to be expanded to:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote -v\line
origin  git://github.com/schacon/ticgit.git (fetch)\line
origin  git://github.com/schacon/ticgit.git (push)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have more than one remote, the command lists them all. For example, my Grit repository looks something like this.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd grit\line
$ git remote -v\line
bakkdoor  git://github.com/bakkdoor/grit.git\line
cho45     git://github.com/cho45/grit.git\line
defunkt   git://github.com/defunkt/grit.git\line
koke      git://github.com/koke/grit.git\line
origin    git@github.com:mojombo/grit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means we can pull contributions from any of these users pretty easily. But notice that only the origin remote is an SSH URL, so it\u8217's the only one I can push to (we\u8217'll cover why this is in {\i Chapter 4}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Adding Remote Repositories\par}
{\pard \ql \f0 \sa180 \li0 \fi0 I\u8217've mentioned and given some demonstrations of adding remote repositories in previous sections, but here is how to do it explicitly. To add a new remote Git repository as a shortname you can reference easily, run {\f1 git remote add [shortname] [url]}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote\line
origin\line
$ git remote add pb git://github.com/paulboone/ticgit.git\line
$ git remote -v\line
origin  git://github.com/schacon/ticgit.git\line
pb  git://github.com/paulboone/ticgit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can use the string {\f1 pb} on the command line in lieu of the whole URL. For example, if you want to fetch all the information that Paul has but that you don\u8217't yet have in your repository, you can run git fetch pb:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch pb\line
remote: Counting objects: 58, done.\line
remote: Compressing objects: 100% (41/41), done.\line
remote: Total 44 (delta 24), reused 1 (delta 0)\line
Unpacking objects: 100% (44/44), done.\line
From git://github.com/paulboone/ticgit\line
 * [new branch]      master     -> pb/master\line
 * [new branch]      ticgit     -> pb/ticgit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Paul\u8217's master branch is accessible locally as {\f1 pb/master} \u8212- you can merge it into one of your branches, or you can check out a local branch at that point if you want to inspect it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Fetching and Pulling from Your Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you just saw, to get data from your remote projects, you can run:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch [remote-name]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The command goes out to that remote project and pulls down all the data from that remote project that you don\u8217't have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time. (We\u8217'll go over what branches are and how to use them in much more detail in {\i Chapter 3}.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you clone a repository, the command automatically adds that remote repository under the name {\i origin}. So, {\f1 git fetch origin} fetches any new work that has been pushed to that server since you cloned (or last fetched from) it. It\u8217's important to note that the {\f1 fetch} command pulls the data to your local repository \u8212- it doesn\u8217't automatically merge it with any of your work or modify what you\u8217're currently working on. You have to merge it manually into your work when you\u8217're ready.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a branch set up to track a remote branch (see the next section and {\i Chapter 3} for more information), you can use the {\f1 git pull} command to automatically fetch and then merge a remote branch into your current branch. This may be an easier or more comfortable workflow for you; and by default, the {\f1 git clone} command automatically sets up your local master branch to track the remote master branch on the server you cloned from (assuming the remote has a master branch). Running {\f1 git pull} generally fetches data from the server you originally cloned from and automatically tries to merge it into the code you\u8217're currently working on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pushing to Your Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple: {\f1 git push [remote-name] [branch-name]}. If you want to push your master branch to your {\f1 origin} server (again, cloning generally sets up both of those names for you automatically), then you can run this to push your work back up to the server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You\u8217'll have to pull down their work first and incorporate it into yours before you\u8217'll be allowed to push. See {\i Chapter 3} for more detailed information on how to push to remote servers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Inspecting a Remote\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to see more information about a particular remote, you can use the {\f1 git remote show [remote-name]} command. If you run this command with a particular shortname, such as {\f1 origin}, you get something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote show origin\line
* remote origin\line
  URL: git://github.com/schacon/ticgit.git\line
  Remote branch merged with 'git pull' while on branch master\line
    master\line
  Tracked remote branches\line
    master\line
    ticgit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It lists the URL for the remote repository as well as the tracking branch information. The command helpfully tells you that if you\u8217're on the master branch and you run {\f1 git pull}, it will automatically merge in the master branch on the remote after it fetches all the remote references. It also lists all the remote references it has pulled down.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is a simple example you\u8217're likely to encounter. When you\u8217're using Git more heavily, however, you may see much more information from {\f1 git remote show}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote show origin\line
* remote origin\line
  URL: git@github.com:defunkt/github.git\line
  Remote branch merged with 'git pull' while on branch issues\line
    issues\line
  Remote branch merged with 'git pull' while on branch master\line
    master\line
  New remote branches (next fetch will store in remotes/origin)\line
    caching\line
  Stale tracking branches (use 'git remote prune')\line
    libwalker\line
    walker2\line
  Tracked remote branches\line
    acl\line
    apiv2\line
    dashboard2\line
    issues\line
    master\line
    postgres\line
  Local branch pushed with 'git push'\line
    master:master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command shows which branch is automatically pushed when you run {\f1 git push} on certain branches. It also shows you which remote branches on the server you don\u8217't yet have, which remote branches you have that have been removed from the server, and multiple branches that are automatically merged when you run {\f1 git pull}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Removing and Renaming Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to rename a reference, in newer versions of Git you can run {\f1 git remote rename} to change a remote\u8217's shortname. For instance, if you want to rename {\f1 pb} to {\f1 paul}, you can do so with {\f1 git remote rename}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote rename pb paul\line
$ git remote\line
origin\line
paul\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's worth mentioning that this changes your remote branch names, too. What used to be referenced at {\f1 pb/master} is now at {\f1 paul/master}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to remove a reference for some reason \u8212- you\u8217've moved the server or are no longer using a particular mirror, or perhaps a contributor isn\u8217't contributing anymore \u8212- you can use {\f1 git remote rm}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote rm paul\line
$ git remote\line
origin\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Tagging\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Like most VCSs, Git has the ability to tag specific points in history as being important. Generally, people use this functionality to mark release points ({\f1 v1.0}, and so on). In this section, you\u8217'll learn how to list the available tags, how to create new tags, and what the different types of tags are.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Listing Your Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Listing the available tags in Git is straightforward. Just type {\f1 git tag}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag\line
v0.1\line
v1.3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command lists the tags in alphabetical order; the order in which they appear has no real importance.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 240 tags. If you\u8217're only interested in looking at the 1.4.2 series, you can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -l 'v1.4.2.*'\line
v1.4.2.1\line
v1.4.2.2\line
v1.4.2.3\line
v1.4.2.4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Creating Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git uses two main types of tags: lightweight and annotated. A lightweight tag is very much like a branch that doesn\u8217't change \u8212- it\u8217's just a pointer to a specific commit. Annotated tags, however, are stored as full objects in the Git database. They\u8217're checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It\u8217's generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don\u8217't want to keep the other information, lightweight tags are available too.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Annotated Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Creating an annotated tag in Git is simple. The easiest way is to specify {\f1 -a} when you run the {\f1 tag} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -a v1.4 -m 'my version 1.4'\line
$ git tag\line
v0.1\line
v1.3\line
v1.4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 -m} specifies a tagging message, which is stored with the tag. If you don\u8217't specify a message for an annotated tag, Git launches your editor so you can type it in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see the tag data along with the commit that was tagged by using the {\f1 git show} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show v1.4\line
tag v1.4\line
Tagger: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Feb 9 14:45:11 2009 -0800\line
\line
my version 1.4\line
commit 15027957951b64cf874c3557a0f3547bd83b3ff6\line
Merge: 4a447f7... a6b4c97...\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sun Feb 8 19:02:46 2009 -0800\line
\line
    Merge branch 'experiment'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Signed Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also sign your tags with GPG, assuming you have a private key. All you have to do is use {\f1 -s} instead of {\f1 -a}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -s v1.5 -m 'my signed 1.5 tag'\line
You need a passphrase to unlock the secret key for\line
user: "Scott Chacon <schacon@gee-mail.com>"\line
1024-bit DSA key, ID F721C45A, created 2009-02-09\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run {\f1 git show} on that tag, you can see your GPG signature attached to it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show v1.5\line
tag v1.5\line
Tagger: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Feb 9 15:22:20 2009 -0800\line
\line
my signed 1.5 tag\line
-----BEGIN PGP SIGNATURE-----\line
Version: GnuPG v1.4.8 (Darwin)\line
\line
iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN\line
Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/\line
=WryJ\line
-----END PGP SIGNATURE-----\line
commit 15027957951b64cf874c3557a0f3547bd83b3ff6\line
Merge: 4a447f7... a6b4c97...\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sun Feb 8 19:02:46 2009 -0800\line
\line
    Merge branch 'experiment'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A bit later, you\u8217'll learn how to verify signed tags.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lightweight Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file \u8212- no other information is kept. To create a lightweight tag, don\u8217't supply the {\f1 -a}, {\f1 -s}, or {\f1 -m} option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag v1.4-lw\line
$ git tag\line
v0.1\line
v1.3\line
v1.4\line
v1.4-lw\line
v1.5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This time, if you run {\f1 git show} on the tag, you don\u8217't see the extra tag information. The command just shows the commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show v1.4-lw\line
commit 15027957951b64cf874c3557a0f3547bd83b3ff6\line
Merge: 4a447f7... a6b4c97...\line
Author: Scott Chacon <schacon@gee-mail.com>\line
Date:   Sun Feb 8 19:02:46 2009 -0800\line
\line
    Merge branch 'experiment'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Verifying Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To verify a signed tag, you use {\f1 git tag -v [tag-name]}. This command uses GPG to verify the signature. You need the signer\u8217's public key in your keyring for this to work properly:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -v v1.4.2.1\line
object 883653babd8ee7ea23e6a5c392bb739348b1eb61\line
type commit\line
tag v1.4.2.1\line
tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700\line
\line
GIT 1.4.2.1\line
\line
Minor fixes since 1.4.2, including git-mv and git-http with alternates.\line
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\line
gpg: Good signature from "Junio C Hamano <junkio@cox.net>"\line
gpg:                 aka "[jpeg image of size 1513]"\line
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you don\u8217't have the signer\u8217's public key, you get something like this instead:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\line
gpg: Can't check signature: public key not found\line
error: could not verify the tag 'v1.4.2.1'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tagging Later\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also tag commits after you\u8217've moved past them. Suppose your commit history looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline\line
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\line
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\line
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\line
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\line
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\line
4682c3261057305bdd616e23b64b0857d832627b added a todo file\line
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\line
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\line
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\line
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, suppose you forgot to tag the project at {\f1 v1.2}, which was at the \u8220"updated rakefile\u8221" commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -a v1.2 -m 'version 1.2' 9fceb02\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that you\u8217've tagged the commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag\line
v0.1\line
v1.2\line
v1.3\line
v1.4\line
v1.4-lw\line
v1.5\line
\line
$ git show v1.2\line
tag v1.2\line
Tagger: Scott Chacon <schacon@gee-mail.com>\line
Date:   Mon Feb 9 15:32:16 2009 -0800\line
\line
version 1.2\line
commit 9fceb02d0ae598e95dc970b74767f19372d61af8\line
Author: Magnus Chacon <mchacon@gee-mail.com>\line
Date:   Sun Apr 27 20:43:35 2008 -0700\line
\line
    updated rakefile\line
...\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sharing Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By default, the {\f1 git push} command doesn\u8217't transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches \u8212- you can run {\f1 git push origin [tagname]}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin v1.5\line
Counting objects: 50, done.\line
Compressing objects: 100% (38/38), done.\line
Writing objects: 100% (44/44), 4.56 KiB, done.\line
Total 44 (delta 18), reused 8 (delta 1)\line
To git@github.com:schacon/simplegit.git\line
* [new tag]         v1.5 -> v1.5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a lot of tags that you want to push up at once, you can also use the {\f1 --tags} option to the {\f1 git push} command. This will transfer all of your tags to the remote server that are not already there.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin --tags\line
Counting objects: 50, done.\line
Compressing objects: 100% (38/38), done.\line
Writing objects: 100% (44/44), 4.56 KiB, done.\line
Total 44 (delta 18), reused 8 (delta 1)\line
To git@github.com:schacon/simplegit.git\line
 * [new tag]         v0.1 -> v0.1\line
 * [new tag]         v1.2 -> v1.2\line
 * [new tag]         v1.4 -> v1.4\line
 * [new tag]         v1.4-lw -> v1.4-lw\line
 * [new tag]         v1.5 -> v1.5\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, when someone else clones or pulls from your repository, they will get all your tags as well.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Tips and Tricks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Before we finish this chapter on basic Git, a few little tips and tricks may make your Git experience a bit simpler, easier, or more familiar. Many people use Git without using any of these tips, and we won\u8217't refer to them or assume you\u8217've used them later in the book; but you should probably know how to do them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Auto-Completion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you use the Bash shell, Git comes with a nice auto-completion script you can enable. Download the Git source code, and look in the {\f1 contrib/completion} directory; there should be a file called {\f1 git-completion.bash}. Copy this file to your home directory, and add this to your {\f1 .bashrc} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 source ~/.git-completion.bash\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to set up Git to automatically have Bash shell completion for all users, copy this script to the {\f1 /opt/local/etc/bash_completion.d} directory on Mac systems or to the {\f1 /etc/bash_completion.d/} directory on Linux systems. This is a directory of scripts that Bash will automatically load to provide shell completions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're using Windows with Git Bash, which is the default when installing Git on Windows with msysGit, auto-completion should be preconfigured.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Press the Tab key when you\u8217're writing a Git command, and it should return a set of suggestions for you to pick from:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git co<tab><tab>\line
commit config\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, typing {\f1 git co} and then pressing the Tab key twice suggests commit and config. Adding {\f1 m<tab>} completes {\f1 git commit} automatically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This also works with options, which is probably more useful. For instance, if you\u8217're running a {\f1 git log} command and can\u8217't remember one of the options, you can start typing it and press Tab to see what matches:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --s<tab>\line
--shortstat  --since=  --src-prefix=  --stat   --summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's a pretty nice trick and may save you some time and documentation reading.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Git Aliases\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git doesn\u8217't infer your command if you type it in partially. If you don\u8217't want to type the entire text of each of the Git commands, you can easily set up an alias for each command using {\f1 git config}. Here are a couple of examples you may want to set up:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global alias.co checkout\line
$ git config --global alias.br branch\line
$ git config --global alias.ci commit\line
$ git config --global alias.st status\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means that, for example, instead of typing {\f1 git commit}, you just need to type {\f1 git ci}. As you go on using Git, you\u8217'll probably use other commands frequently as well; in this case, don\u8217't hesitate to create new aliases.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This technique can also be very useful in creating commands that you think should exist. For example, to correct the usability problem you encountered with unstaging a file, you can add your own unstage alias to Git:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global alias.unstage 'reset HEAD --'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This makes the following two commands equivalent:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git unstage fileA\line
$ git reset HEAD fileA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This seems a bit clearer. It\u8217's also common to add a {\f1 last} command, like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global alias.last 'log -1 HEAD'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, you can see the last commit easily:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git last\line
commit 66938dae3329c7aebe598c2246a8e6af90d04646\line
Author: Josh Goebel <dreamer3@example.com>\line
Date:   Tue Aug 26 19:48:51 2008 +0800\line
\line
    test for current head\line
\line
    Signed-off-by: Scott Chacon <schacon@example.com>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you can tell, Git simply replaces the new command with whatever you alias it to. However, maybe you want to run an external command, rather than a Git subcommand. In that case, you start the command with a {\f1 !} character. This is useful if you write your own tools that work with a Git repository. We can demonstrate by aliasing {\f1 git visual} to run {\f1 gitk}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global alias.visual '!gitk'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you can do all the basic local Git operations \u8212- creating or cloning a repository, making changes, staging and committing those changes, and viewing the history of all the changes the repository has been through. Next, we\u8217'll cover Git\u8217's killer feature: its branching model.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git Branching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Nearly every VCS has some form of branching support. Branching means you diverge from the main line of development and continue to do work without messing with that main line. In many VCS tools, this is a somewhat expensive process, often requiring you to create a new copy of your source code directory, which can take a long time for large projects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some people refer to the branching model in Git as its \u8220"killer feature\u8221" , and it certainly sets Git apart in the VCS community. Why is it so special? The way Git branches is incredibly lightweight, making branching operations nearly instantaneous and switching back and forth between branches generally just as fast. Unlike many other VCSs, Git encourages a workflow that branches and merges often, even multiple times in a day. Understanding and mastering this feature gives you a powerful and unique tool and can literally change the way that you develop.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 What a Branch Is\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To really understand the way Git does branching, we need to take a step back and examine how Git stores its data. As you may remember from Chapter 1, Git doesn\u8217't store data as a series of changesets or deltas, but instead as a series of snapshots.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you commit in Git, Git stores a commit object that contains a pointer to the snapshot of the content you staged, the author and message metadata, and zero or more pointers to the commit or commits that were the direct parents of this commit: zero parents for the first commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To visualize this, let\u8217's assume that you have a directory containing three files, and you stage them all and commit. Staging the files checksums each one (the SHA-1 hash we mentioned in Chapter 1), stores that version of the file in the Git repository (Git refers to them as blobs), and adds that checksum to the staging area:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add README test.rb LICENSE\line
$ git commit -m 'initial commit of my project'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you create the commit by running {\f1 git commit}, Git checksums each subdirectory (in this case, just the root project directory) and stores those tree objects in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your Git repository now contains five objects: one blob for the contents of each of your three files, one tree that lists the contents of the directory and specifies which file names are stored as which blobs, and one commit with the pointer to that root tree and all the commit metadata. Conceptually, the data in your Git repository looks something like Figure 3-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0301.png Figure 3-1. Single commit repository data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you make some changes and commit again, the next commit stores a pointer to the commit that came immediately before it. After two more commits, your history might look something like Figure 3-2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0302.png Figure 3-2. Git object data for multiple commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you initially make commits, you\u8217're given a {\f1 master} branch that points to the last commit you made. Every time you commit, it moves forward automatically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0303.png Figure 3-3. Branch pointing into the commit data\u8217's history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What happens if you create a new branch? Well, doing so creates a new pointer for you to move around. Let\u8217's say you create a new branch called testing. You do this with the {\f1 git branch} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This creates a new pointer at the same commit you\u8217're currently on (see Figure 3-4).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0304.png Figure 3-4. Multiple branches pointing into the commit\u8217's data history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 How does Git know what branch you\u8217're currently on? It keeps a special pointer called HEAD. Note that this is a lot different than the concept of HEAD in other VCSs you may be used to, such as Subversion or CVS. In Git, this is a pointer to the local branch you\u8217're currently on. In this case, you\u8217're still on master. The git branch command only created a new branch \u8212- it didn\u8217't switch to that branch (see Figure 3-5).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0305.png Figure 3-5. HEAD file pointing to the branch you\u8217're on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To switch to an existing branch, you run the {\f1 git checkout} command. Let\u8217's switch to the new testing branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This moves HEAD to point to the testing branch (see Figure 3-6).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0306.png Figure 3-6. HEAD points to another branch when you switch branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What is the significance of that? Well, let\u8217's do another commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim test.rb\line
$ git commit -a -m 'made a change'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Figure 3-7 illustrates the result.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0307.png Figure 3-7. The branch that HEAD points to moves forward with each commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is interesting, because now your testing branch has moved forward, but your {\f1 master} branch still points to the commit you were on when you ran {\f1 git checkout} to switch branches. Let\u8217's switch back to the {\f1 master} branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Figure 3-8 shows the result.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0308.png Figure 3-8. HEAD moves to another branch on a checkout.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That command did two things. It moved the HEAD pointer back to point to the {\f1 master} branch, and it reverted the files in your working directory back to the snapshot that {\f1 master} points to. This also means the changes you make from this point forward will diverge from an older version of the project. It essentially rewinds the work you\u8217've done in your testing branch temporarily so you can go in a different direction.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's make a few changes and commit again:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim test.rb\line
$ git commit -a -m 'made other changes'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now your project history has diverged (see Figure 3-9). You created and switched to a branch, did some work on it, and then switched back to your main branch and did other work. Both of those changes are isolated in separate branches: you can switch back and forth between the branches and merge them together when you\u8217're ready. And you did all that with simple {\f1 branch} and {\f1 checkout} commands.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0309.png Figure 3-9. The branch histories have diverged.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy. Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is in sharp contrast to the way most VCS tools branch, which involves copying all of the project\u8217's files into a second directory. This can take several seconds or even minutes, depending on the size of the project, whereas in Git the process is always instantaneous. Also, because we\u8217're recording the parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do. These features help encourage developers to create and use branches often.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's see why you should do so.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Basic Branching and Merging\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's go through a simple example of branching and merging with a workflow that you might use in the real world. You\u8217'll follow these steps:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Do work on a web site.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Create a branch for a new story you\u8217're working on.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Do some work in that branch.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this stage, you\u8217'll receive a call that another issue is critical and you need a hotfix. You\u8217'll do the following:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Revert back to your production branch.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Create a branch to add the hotfix.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab After it\u8217's tested, merge the hotfix branch, and push to production.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Switch back to your original story and continue working.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Basic Branching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, let\u8217's say you\u8217're working on your project and have a couple of commits already (see Figure 3-10).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0310.png Figure 3-10. A short and simple commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217've decided that you\u8217're going to work on issue #53 in whatever issue-tracking system your company uses. To be clear, Git isn\u8217't tied into any particular issue-tracking system; but because issue #53 is a focused topic that you want to work on, you\u8217'll create a new branch in which to work. To create a branch and switch to it at the same time, you can run the {\f1 git checkout} command with the {\f1 -b} switch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b iss53\line
Switched to a new branch "iss53"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is shorthand for:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch iss53\line
$ git checkout iss53\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Figure 3-11 illustrates the result.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0311.png Figure 3-11. Creating a new branch pointer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You work on your web site and do some commits. Doing so moves the {\f1 iss53} branch forward, because you have it checked out (that is, your HEAD is pointing to it; see Figure 3-12):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim index.html\line
$ git commit -a -m 'added a new footer [issue 53]'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0312.png Figure 3-12. The iss53 branch has moved forward with your work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you get the call that there is an issue with the web site, and you need to fix it immediately. With Git, you don\u8217't have to deploy your fix along with the {\f1 iss53} changes you\u8217've made, and you don\u8217't have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in production. All you have to do is switch back to your master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you\u8217're checking out, Git won\u8217't let you switch branches. It\u8217's best to have a clean working state when you switch branches. There are ways to get around this (namely, stashing and commit amending) that we\u8217'll cover later. For now, you\u8217've committed all your changes, so you can switch back to your master branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
Switched to branch "master"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, your project working directory is exactly the way it was before you started working on issue #53, and you can concentrate on your hotfix. This is an important point to remember: Git resets your working directory to look like the snapshot of the commit that the branch you check out points to. It adds, removes, and modifies files automatically to make sure your working copy is what the branch looked like on your last commit to it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you have a hotfix to make. Let\u8217's create a hotfix branch on which to work until it\u8217's completed (see Figure 3-13):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b hotfix\line
Switched to a new branch "hotfix"\line
$ vim index.html\line
$ git commit -a -m 'fixed the broken email address'\line
[hotfix]: created 3a0874c: "fixed the broken email address"\line
 1 files changed, 0 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0313.png Figure 3-13. hotfix branch based back at your master branch point.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can run your tests, make sure the hotfix is what you want, and merge it back into your master branch to deploy to production. You do this with the {\f1 git merge} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
$ git merge hotfix\line
Updating f42c576..3a0874c\line
Fast forward\line
 README |    1 -\line
 1 files changed, 0 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll notice the phrase \u8220"Fast forward\u8221" in that merge. Because the commit pointed to by the branch you merged in was directly upstream of the commit you\u8217're on, Git moves the pointer forward. To phrase that another way, when you try to merge one commit with a commit that can be reached by following the first commit\u8217's history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together \u8212- this is called a \u8220"fast forward\u8221".\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your change is now in the snapshot of the commit pointed to by the {\f1 master} branch, and you can deploy your change (see Figure 3-14).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0314.png Figure 3-14. Your master branch points to the same place as your hotfix branch after the merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After your super-important fix is deployed, you\u8217're ready to switch back to the work you were doing before you were interrupted. However, first you\u8217'll delete the {\f1 hotfix} branch, because you no longer need it \u8212- the {\f1 master} branch points at the same place. You can delete it with the {\f1 -d} option to {\f1 git branch}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -d hotfix\line
Deleted branch hotfix (3a0874c).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can switch back to your work-in-progress branch on issue #53 and continue working on it (see Figure 3-15):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout iss53\line
Switched to branch "iss53"\line
$ vim index.html\line
$ git commit -a -m 'finished the new footer [issue 53]'\line
[iss53]: created ad82d7a: "finished the new footer [issue 53]"\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0315.png Figure 3-15. Your iss53 branch can move forward independently.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's worth noting here that the work you did in your {\f1 hotfix} branch is not contained in the files in your {\f1 iss53} branch. If you need to pull it in, you can merge your {\f1 master} branch into your {\f1 iss53} branch by running {\f1 git merge master}, or you can wait to integrate those changes until you decide to pull the {\f1 iss53} branch back into {\f1 master} later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Basic Merging\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you\u8217've decided that your issue #53 work is complete and ready to be merged into your {\f1 master} branch. In order to do that, you\u8217'll merge in your {\f1 iss53} branch, much like you merged in your {\f1 hotfix} branch earlier. All you have to do is check out the branch you wish to merge into and then run the {\f1 git merge} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
$ git merge iss53\line
Merge made by recursive.\line
 README |    1 +\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This looks a bit different than the {\f1 hotfix} merge you did earlier. In this case, your development history has diverged from some older point. Because the commit on the branch you\u8217're on isn\u8217't a direct ancestor of the branch you\u8217're merging in, Git has to do some work. In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two. Figure 3-16 highlights the three snapshots that Git uses to do its merge in this case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0316.png Figure 3-16. Git automatically identifies the best common-ancestor merge base for branch merging.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it (see Figure 3-17). This is referred to as a merge commit and is special in that it has more than one parent.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's worth pointing out that Git determines the best common ancestor to use for its merge base; this is different than CVS or Subversion (before version 1.5), where the developer doing the merge has to figure out the best merge base for themselves. This makes merging a heck of a lot easier in Git than in these other systems.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0317.png Figure 3-17. Git automatically creates a new commit object that contains the merged work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that your work is merged in, you have no further need for the {\f1 iss53} branch. You can delete it and then manually close the ticket in your ticket-tracking system:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -d iss53\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Basic Merge Conflicts\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Occasionally, this process doesn\u8217't go smoothly. If you changed the same part of the same file differently in the two branches you\u8217're merging together, Git won\u8217't be able to merge them cleanly. If your fix for issue #53 modified the same part of a file as the {\f1 hotfix}, you\u8217'll get a merge conflict that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge iss53\line
Auto-merging index.html\line
CONFLICT (content): Merge conflict in index.html\line
Automatic merge failed; fix conflicts and then commit the result.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git hasn\u8217't automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to see which files are unmerged at any point after a merge conflict, you can run {\f1 git status}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [master*]$ git status\line
index.html: needs merge\line
# On branch master\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#   (use "git checkout -- <file>..." to discard changes in working directory)\line
#\line
#   unmerged:   index.html\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Anything that has merge conflicts and hasn\u8217't been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts. Your file contains a section that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <<<<<<< HEAD:index.html\line
<div id="footer">contact : email.support@github.com</div>\line
=======\line
<div id="footer">\line
  please contact us at support@github.com\line
</div>\line
>>>>>>> iss53:index.html\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means the version in HEAD (your master branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the {\f1 =======}), while the version in your {\f1 iss53} branch looks like everything in the bottom part. In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself. For instance, you might resolve this conflict by replacing the entire block with this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <div id="footer">\line
please contact us at email.support@github.com\line
</div>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This resolution has a little of each section, and I\u8217've fully removed the {\f1 <<<<<<<}, {\f1 =======}, and {\f1 >>>>>>>} lines. After you\u8217've resolved each of these sections in each conflicted file, run {\f1 git add} on each file to mark it as resolved. Staging the file marks it as resolved in Git. If you want to use a graphical tool to resolve these issues, you can run {\f1 git mergetool}, which fires up an appropriate visual merge tool and walks you through the conflicts:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git mergetool\line
merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff\line
Merging the files: index.html\line
\line
Normal merge conflict for 'index.html':\line
  \{local\}: modified\line
  \{remote\}: modified\line
Hit return to start merge resolution tool (opendiff):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to use a merge tool other than the default (Git chose {\f1 opendiff} for me in this case because I ran the command on a Mac), you can see all the supported tools listed at the top after \u8220"merge tool candidates\u8221". Type the name of the tool you\u8217'd rather use. In Chapter 7, we\u8217'll discuss how you can change this default value for your environment.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After you exit the merge tool, Git asks you if the merge was successful. If you tell the script that it was, it stages the file to mark it as resolved for you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can run {\f1 git status} again to verify that all conflicts have been resolved:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#   modified:   index.html\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're happy with that, and you verify that everything that had conflicts has been staged, you can type {\f1 git commit} to finalize the merge commit. The commit message by default looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Merge branch 'iss53'\line
\line
Conflicts:\line
  index.html\line
#\line
# It looks like you may be committing a MERGE.\line
# If this is not correct, please remove the file\line
# .git/MERGE_HEAD\line
# and try again.\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can modify that message with details about how you resolved the merge if you think it would be helpful to others looking at this merge in the future \u8212- why you did what you did, if it\u8217's not obvious.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Branch Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you\u8217've created, merged, and deleted some branches, let\u8217's look at some branch-management tools that will come in handy when you begin using branches all the time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 git branch} command does more than just create and delete branches. If you run it with no arguments, you get a simple listing of your current branches:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch\line
  iss53\line
* master\line
  testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice the {\f1 *} character that prefixes the {\f1 master} branch: it indicates the branch that you currently have checked out. This means that if you commit at this point, the {\f1 master} branch will be moved forward with your new work. To see the last commit on each branch, you can run {\f1 git branch -v}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -v\line
  iss53   93b412c fix javascript issue\line
* master  7a98805 Merge branch 'iss53'\line
  testing 782fd34 add scott to the author list in the readmes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another useful option to figure out what state your branches are in is to filter this list to branches that you have or have not yet merged into the branch you\u8217're currently on. The useful {\f1 --merged} and {\f1 --no-merged} options have been available in Git since version 1.5.6 for this purpose. To see which branches are already merged into the branch you\u8217're on, you can run {\f1 git branch --merged}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch --merged\line
  iss53\line
* master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because you already merged in {\f1 iss53} earlier, you see it in your list. Branches on this list without the {\f1 *} in front of them are generally fine to delete with {\f1 git branch -d}; you\u8217've already incorporated their work into another branch, so you\u8217're not going to lose anything.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see all the branches that contain work you haven\u8217't yet merged in, you can run {\f1 git branch --no-merged}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch --no-merged\line
  testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This shows your other branch. Because it contains work that isn\u8217't merged in yet, trying to delete it with {\f1 git branch -d} will fail:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -d testing\line
error: The branch 'testing' is not an ancestor of your current HEAD.\line
If you are sure you want to delete it, run 'git branch -D testing'.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you really do want to delete the branch and lose that work, you can force it with {\f1 -D}, as the helpful message points out.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Branching Workflows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have the basics of branching and merging down, what can or should you do with them? In this section, we\u8217'll cover some common workflows that this lightweight branching makes possible, so you can decide if you would like to incorporate it into your own development cycle.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Long-Running Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because Git uses a simple three-way merge, merging from one branch into another multiple times over a long period is generally easy to do. This means you can have several branches that are always open and that you use for different stages of your development cycle; you can merge regularly from some of them into others.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many Git developers have a workflow that embraces this approach, such as having only code that is entirely stable in their {\f1 master} branch \u8212- possibly only code that has been or will be released. They have another parallel branch named develop or next that they work from or use to test stability \u8212- it isn\u8217't necessarily always stable, but whenever it gets to a stable state, it can be merged into {\f1 master}. It\u8217's used to pull in topic branches (short-lived branches, like your earlier {\f1 iss53} branch) when they\u8217're ready, to make sure they pass all the tests and don\u8217't introduce bugs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In reality, we\u8217're talking about pointers moving up the line of commits you\u8217're making. The stable branches are farther down the line in your commit history, and the bleeding-edge branches are farther up the history (see Figure 3-18).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0318.png Figure 3-18. More stable branches are generally farther down the commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when they\u8217're fully tested (see Figure 3-19).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0319.png Figure 3-19. It may be helpful to think of your branches as silos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can keep doing this for several levels of stability. Some larger projects also have a {\f1 proposed} or {\f1 pu} (proposed updates) branch that has integrated branches that may not be ready to go into the {\f1 next} or {\f1 master} branch. The idea is that your branches are at various levels of stability; when they reach a more stable level, they\u8217're merged into the branch above them. Again, having multiple long-running branches isn\u8217't necessary, but it\u8217's often helpful, especially when you\u8217're dealing with very large or complex projects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Topic Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Topic branches, however, are useful in projects of any size. A topic branch is a short-lived branch that you create and use for a single particular feature or related work. This is something you\u8217've likely never done with a VCS before because it\u8217's generally too expensive to create and merge branches. But in Git it\u8217's common to create, work on, merge, and delete branches several times a day.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You saw this in the last section with the {\f1 iss53} and {\f1 hotfix} branches you created. You did a few commits on them and deleted them directly after merging them into your main branch. This technique allows you to context-switch quickly and completely \u8212- because your work is separated into silos where all the changes in that branch have to do with that topic, it\u8217's easier to see what has happened during code review and such. You can keep the changes there for minutes, days, or months, and merge them in when they\u8217're ready, regardless of the order in which they were created or worked on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Consider an example of doing some work (on {\f1 master}), branching off for an issue ({\f1 iss91}), working on it for a bit, branching off the second branch to try another way of handling the same thing ({\f1 iss91v2}), going back to your master branch and working there for a while, and then branching off there to do some work that you\u8217're not sure is a good idea ({\f1 dumbidea} branch). Your commit history will look something like Figure 3-20.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0320.png Figure 3-20. Your commit history with multiple topic branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, let\u8217's say you decide you like the second solution to your issue best ({\f1 iss91v2}); and you showed the {\f1 dumbidea} branch to your coworkers, and it turns out to be genius. You can throw away the original {\f1 iss91} branch (losing commits C5 and C6) and merge in the other two. Your history then looks like Figure 3-21.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0321.png Figure 3-21. Your history after merging in dumbidea and iss91v2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to remember when you\u8217're doing all this that these branches are completely local. When you\u8217're branching and merging, everything is being done only in your Git repository \u8212- no server communication is happening.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Remote Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remote branches are references to the state of branches on your remote repositories. They\u8217're local branches that you can\u8217't move; they\u8217're moved automatically whenever you do any network communication. Remote branches act as bookmarks to remind you where the branches on your remote repositories were the last time you connected to them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 They take the form {\f1 (remote)/(branch)}. For instance, if you wanted to see what the {\f1 master} branch on your {\f1 origin} remote looked like as of the last time you communicated with it, you would check the {\f1 origin/master} branch. If you were working on an issue with a partner and they pushed up an {\f1 iss53} branch, you might have your own local {\f1 iss53} branch; but the branch on the server would point to the commit at {\f1 origin/iss53}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This may be a bit confusing, so let\u8217's look at an example. Let\u8217's say you have a Git server on your network at {\f1 git.ourcompany.com}. If you clone from this, Git automatically names it {\f1 origin} for you, pulls down all its data, creates a pointer to where its {\f1 master} branch is, and names it {\f1 origin/master} locally; and you can\u8217't move it. Git also gives you your own {\f1 master} branch starting at the same place as origin\u8217's {\f1 master} branch, so you have something to work from (see Figure 3-22).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0322.png Figure 3-22. A Git clone gives you your own master branch and origin/master pointing to origin\u8217's master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you do some work on your local master branch, and, in the meantime, someone else pushes to {\f1 git.ourcompany.com} and updates its master branch, then your histories move forward differently. Also, as long as you stay out of contact with your origin server, your {\f1 origin/master} pointer doesn\u8217't move (see Figure 3-23).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0323.png Figure 3-23. Working locally and having someone push to your remote server makes each history move forward differently.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To synchronize your work, you run a {\f1 git fetch origin} command. This command looks up which server origin is (in this case, it\u8217's {\f1 git.ourcompany.com}), fetches any data from it that you don\u8217't yet have, and updates your local database, moving your {\f1 origin/master} pointer to its new, more up-to-date position (see Figure 3-24).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0324.png Figure 3-24. The git fetch command updates your remote references.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To demonstrate having multiple remote servers and what remote branches for those remote projects look like, let\u8217's assume you have another internal Git server that is used only for development by one of your sprint teams. This server is at {\f1 git.team1.ourcompany.com}. You can add it as a new remote reference to the project you\u8217're currently working on by running the {\f1 git remote add} command as we covered in Chapter 2. Name this remote {\f1 teamone}, which will be your shortname for that whole URL (see Figure 3-25).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0325.png Figure 3-25. Adding another server as a remote.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can run {\f1 git fetch teamone} to fetch everything the remote {\f1 teamone} server has that you don\u8217't have yet. Because that server has a subset of the data your {\f1 origin} server has right now, Git fetches no data but sets a remote branch called {\f1 teamone/master} to point to the commit that {\f1 teamone} has as its {\f1 master} branch (see Figure 3-26).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0326.png Figure 3-26. You get a reference to teamone\u8217's master branch position locally.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pushing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you want to share a branch with the world, you need to push it up to a remote that you have write access to. Your local branches aren\u8217't automatically synchronized to the remotes you write to \u8212- you have to explicitly push the branches you want to share. That way, you can use private branches for work you don\u8217't want to share, and push up only the topic branches you want to collaborate on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a branch named {\f1 serverfix} that you want to work on with others, you can push it up the same way you pushed your first branch. Run {\f1 git push (remote) (branch)}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin serverfix\line
Counting objects: 20, done.\line
Compressing objects: 100% (14/14), done.\line
Writing objects: 100% (15/15), 1.74 KiB, done.\line
Total 15 (delta 5), reused 0 (delta 0)\line
To git@github.com:schacon/simplegit.git\line
 * [new branch]      serverfix -> serverfix\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a bit of a shortcut. Git automatically expands the {\f1 serverfix} branchname out to {\f1 refs/heads/serverfix:refs/heads/serverfix}, which means, \u8220"Take my serverfix local branch and push it to update the remote\u8217's serverfix branch.\u8221" We\u8217'll go over the {\f1 refs/heads/} part in detail in Chapter 9, but you can generally leave it off. You can also do {\f1 git push origin serverfix:serverfix}, which does the same thing \u8212- it says, \u8220"Take my serverfix and make it the remote\u8217's serverfix.\u8221" You can use this format to push a local branch into a remote branch that is named differently. If you didn\u8217't want it to be called {\f1 serverfix} on the remote, you could instead run {\f1 git push origin serverfix:awesomebranch} to push your local {\f1 serverfix} branch to the {\f1 awesomebranch} branch on the remote project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next time one of your collaborators fetches from the server, they will get a reference to where the server\u8217's version of {\f1 serverfix} is under the remote branch {\f1 origin/serverfix}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin\line
remote: Counting objects: 20, done.\line
remote: Compressing objects: 100% (14/14), done.\line
remote: Total 15 (delta 5), reused 0 (delta 0)\line
Unpacking objects: 100% (15/15), done.\line
From git@github.com:schacon/simplegit\line
 * [new branch]      serverfix    -> origin/serverfix\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that when you do a fetch that brings down new remote branches, you don\u8217't automatically have local, editable copies of them. In other words, in this case, you don\u8217't have a new {\f1 serverfix} branch \u8212- you only have an {\f1 origin/serverfix} pointer that you can\u8217't modify.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To merge this work into your current working branch, you can run {\f1 git merge origin/serverfix}. If you want your own {\f1 serverfix} branch that you can work on, you can base it off your remote branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b serverfix origin/serverfix\line
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.\line
Switched to a new branch "serverfix"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This gives you a local branch that you can work on that starts where {\f1 origin/serverfix} is.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tracking Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Checking out a local branch from a remote branch automatically creates what is called a {\i tracking branch}. Tracking branches are local branches that have a direct relationship to a remote branch. If you\u8217're on a tracking branch and type {\f1 git push}, Git automatically knows which server and branch to push to. Also, running {\f1 git pull} while on one of these branches fetches all the remote references and then automatically merges in the corresponding remote branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you clone a repository, it generally automatically creates a {\f1 master} branch that tracks {\f1 origin/master}. That\u8217's why {\f1 git push} and {\f1 git pull} work out of the box with no other arguments. However, you can set up other tracking branches if you wish \u8212- ones that don\u8217't track branches on {\f1 origin} and don\u8217't track the {\f1 master} branch. The simple case is the example you just saw, running {\f1 git checkout -b [branch] [remotename]/[branch]}. If you have Git version 1.6.2 or later, you can also use the {\f1 --track} shorthand:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout --track origin/serverfix\line
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.\line
Switched to a new branch "serverfix"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b sf origin/serverfix\line
Branch sf set up to track remote branch refs/remotes/origin/serverfix.\line
Switched to a new branch "sf"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, your local branch sf will automatically push to and pull from origin/serverfix.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Deleting Remote Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you\u8217're done with a remote branch \u8212- say, you and your collaborators are finished with a feature and have merged it into your remote\u8217's {\f1 master} branch (or whatever branch your stable codeline is in). You can delete a remote branch using the rather obtuse syntax {\f1 git push [remotename] :[branch]}. If you want to delete your {\f1 serverfix} branch from the server, you run the following:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin :serverfix\line
To git@github.com:schacon/simplegit.git\line
 - [deleted]         serverfix\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Boom. No more branch on your server. You may want to dog-ear this page, because you\u8217'll need that command, and you\u8217'll likely forget the syntax. A way to remember this command is by recalling the {\f1 git push [remotename] [localbranch]:[remotebranch]} syntax that we went over a bit earlier. If you leave off the {\f1 [localbranch]} portion, then you\u8217're basically saying, \u8220"Take nothing on my side and make it be {\f1 [remotebranch]}.\u8221"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Rebasing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In Git, there are two main ways to integrate changes from one branch into another: the {\f1 merge} and the {\f1 rebase}. In this section you\u8217'll learn what rebasing is, how to do it, why it\u8217's a pretty amazing tool, and in what cases you won\u8217't want to use it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Basic Rebase\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you go back to an earlier example from the Merge section (see Figure 3-27), you can see that you diverged your work and made commits on two different branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0327.png Figure 3-27. Your initial diverged commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The easiest way to integrate the branches, as we\u8217've already covered, is the {\f1 merge} command. It performs a three-way merge between the two latest branch snapshots (C3 and C4) and the most recent common ancestor of the two (C2), creating a new snapshot (and commit), as shown in Figure 3-28.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0328.png Figure 3-28. Merging a branch to integrate the diverged work history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, there is another way: you can take the patch of the change that was introduced in C3 and reapply it on top of C4. In Git, this is called {\i rebasing}. With the {\f1 rebase} command, you can take all the changes that were committed on one branch and replay them on another one.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this example, you\u8217'd run the following:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout experiment\line
$ git rebase master\line
First, rewinding head to replay your work on top of it...\line
Applying: added staged command\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It works by going to the common ancestor of the two branches (the one you\u8217're on and the one you\u8217're rebasing onto), getting the diff introduced by each commit of the branch you\u8217're on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn. Figure 3-29 illustrates this process.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0329.png Figure 3-29. Rebasing the change introduced in C3 onto C4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you can go back to the master branch and do a fast-forward merge (see Figure 3-30).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0330.png Figure 3-30. Fast-forwarding the master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, the snapshot pointed to by C3\u8217' is exactly the same as the one that was pointed to by C5 in the merge example. There is no difference in the end product of the integration, but rebasing makes for a cleaner history. If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Often, you\u8217'll do this to make sure your commits apply cleanly on a remote branch \u8212- perhaps in a project to which you\u8217're trying to contribute but that you don\u8217't maintain. In this case, you\u8217'd do your work in a branch and then rebase your work onto {\f1 origin/master} when you were ready to submit your patches to the main project. That way, the maintainer doesn\u8217't have to do any integration work \u8212- just a fast-forward or a clean apply.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note that the snapshot pointed to by the final commit you end up with, whether it\u8217's the last of the rebased commits for a rebase or the final merge commit after a merge, is the same snapshot \u8212- it\u8217's only the history that is different. Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 More Interesting Rebases\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also have your rebase replay on something other than the rebase branch. Take a history like Figure 3-31, for example. You branched a topic branch ({\f1 server}) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes ({\f1 client}) and committed a few times. Finally, you went back to your server branch and did a few more commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0331.png Figure 3-31. A history with a topic branch off another topic branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it\u8217's tested further. You can take the changes on client that aren\u8217't on server (C8 and C9) and replay them on your master branch by using the {\f1 --onto} option of {\f1 git rebase}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rebase --onto master server client\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This basically says, \u8220"Check out the client branch, figure out the patches from the common ancestor of the {\f1 client} and {\f1 server} branches, and then replay them onto {\f1 master}.\u8221" It\u8217's a bit complex; but the result, shown in Figure 3-32, is pretty cool.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0332.png Figure 3-32. Rebasing a topic branch off another topic branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can fast-forward your master branch (see Figure 3-33):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
$ git merge client\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0333.png Figure 3-33. Fast-forwarding your master branch to include the client branch changes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say you decide to pull in your server branch as well. You can rebase the server branch onto the master branch without having to check it out first by running {\f1 git rebase [basebranch] [topicbranch]} \u8212- which checks out the topic branch (in this case, {\f1 server}) for you and replays it onto the base branch ({\f1 master}):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rebase master server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This replays your {\f1 server} work on top of your {\f1 master} work, as shown in Figure 3-34.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0334.png Figure 3-34. Rebasing your server branch on top of your master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can fast-forward the base branch ({\f1 master}):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
$ git merge server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can remove the {\f1 client} and {\f1 server} branches because all the work is integrated and you don\u8217't need them anymore, leaving your history for this entire process looking like Figure 3-35:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -d client\line
$ git branch -d server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0335.png Figure 3-35. Final commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Perils of Rebasing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ahh, but the bliss of rebasing isn\u8217't without its drawbacks, which can be summed up in a single line:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Do not rebase commits that you have pushed to a public repository.}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you follow that guideline, you\u8217'll be fine. If you don\u8217't, people will hate you, and you\u8217'll be scorned by friends and family.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you rebase stuff, you\u8217're abandoning existing commits and creating new ones that are similar but different. If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with {\f1 git rebase} and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's look at an example of how rebasing work that you\u8217've made public can cause problems. Suppose you clone from a central server and then do some work off that. Your commit history looks like Figure 3-36.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0336.png Figure 3-36. Clone a repository, and base some work on it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, someone else does more work that includes a merge, and pushes that work to the central server. You fetch them and merge the new remote branch into your work, making your history look something like Figure 3-37.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0337.png Figure 3-37. Fetch more commits, and merge them into your work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, the person who pushed the merged work decides to go back and rebase their work instead; they do a {\f1 git push --force} to overwrite the history on the server. You then fetch from that server, bringing down the new commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0338.png Figure 3-38. Someone pushes rebased commits, abandoning commits you\u8217've based your work on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you have to merge this work in again, even though you\u8217've already done so. Rebasing changes the SHA-1 hashes of these commits so to Git they look like new commits, when in fact you already have the C4 work in your history (see Figure 3-39).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0339.png Figure 3-39. You merge in the same work again into a new merge commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to merge that work in at some point so you can keep up with the other developer in the future. After you do that, your commit history will contain both the C4 and C4\u8217' commits, which have different SHA-1 hashes but introduce the same work and have the same commit message. If you run a {\f1 git log} when your history looks like this, you\u8217'll see two commits that have the same author date and message, which will be confusing. Furthermore, if you push this history back up to the server, you\u8217'll reintroduce all those rebased commits to the central server, which can further confuse people.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you\u8217'll be fine. If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We\u8217've covered basic branching and merging in Git. You should feel comfortable creating and switching to new branches, switching between branches and merging local branches together. You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git on the Server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you should be able to do most of the day-to-day tasks for which you\u8217'll be using Git. However, in order to do any collaboration in Git, you\u8217'll need to have a remote Git repository. Although you can technically push changes to and pull changes from individuals\u8217' repositories, doing so is discouraged because you can fairly easily confuse what they\u8217're working on if you\u8217're not careful. Furthermore, you want your collaborators to be able to access the repository even if your computer is offline \u8212- having a more reliable common repository is often useful. Therefore, the preferred method for collaborating with someone is to set up an intermediate repository that you both have access to, and push to and pull from that. We\u8217'll refer to this repository as a \u8220"Git server\u8221"; but you\u8217'll notice that it generally takes a tiny amount of resources to host a Git repository, so you\u8217'll rarely need to use an entire server for it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Running a Git server is simple. First, you choose which protocols you want your server to communicate with. The first section of this chapter will cover the available protocols and the pros and cons of each. The next sections will explain some typical setups using those protocols and how to get your server running with them. Last, we\u8217'll go over a few hosted options, if you don\u8217't mind hosting your code on someone else\u8217's server and don\u8217't want to go through the hassle of setting up and maintaining your own server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have no interest in running your own server, you can skip to the last section of the chapter to see some options for setting up a hosted account and then move on to the next chapter, where we discuss the various ins and outs of working in a distributed source control environment.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A remote repository is generally a {\i bare repository} \u8212- a Git repository that has no working directory. Because the repository is only used as a collaboration point, there is no reason to have a snapshot checked out on disk; it\u8217's just the Git data. In the simplest terms, a bare repository is the contents of your project\u8217's {\f1 .git} directory and nothing else.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 The Protocols\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git can use four major network protocols to transfer data: Local, Secure Shell (SSH), Git, and HTTP. Here we\u8217'll discuss what they are and in what basic circumstances you would want (or not want) to use them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that with the exception of the HTTP protocols, all of these require Git to be installed and working on the server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Local Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The most basic is the {\i Local protocol}, in which the remote repository is in another directory on disk. This is often used if everyone on your team has access to a shared filesystem such as an NFS mount, or in the less likely case that everyone logs in to the same computer. The latter wouldn\u8217't be ideal, because all your code repository instances would reside on the same computer, making a catastrophic loss much more likely.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository. To clone a repository like this or to add one as a remote to an existing project, use the path to the repository as the URL. For example, to clone a local repository, you can run something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone /opt/git/project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or you can do this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone file:///opt/git/project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git operates slightly differently if you explicitly specify {\f1 file://} at the beginning of the URL. If you just specify the path, Git tries to use hardlinks or directly copy the files it needs. If you specify {\f1 file://}, Git fires up the processes that it normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data. The main reason to specify the {\f1 file://} prefix is if you want a clean copy of the repository with extraneous references or objects left out \u8212- generally after an import from another version-control system or something similar (see Chapter 9 for maintenance tasks). We\u8217'll use the normal path here because doing so is almost always faster.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To add a local repository to an existing Git project, you can run something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add local_proj /opt/git/project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can push to and pull from that remote as though you were doing so over a network.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Pros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The pros of file-based repositories are that they\u8217're simple and they use existing file permissions and network access. If you already have a shared filesystem to which your whole team has access, setting up a repository is very easy. You stick the bare repository copy somewhere everyone has shared access to and set the read/write permissions as you would for any other shared directory. We\u8217'll discuss how to export a bare repository copy for this purpose in the next section, \u8220"Getting Git on a Server.\u8221"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is also a nice option for quickly grabbing work from someone else\u8217's working repository. If you and a co-worker are working on the same project and they want you to check something out, running a command like {\f1 git pull /home/john/project} is often easier than them pushing to a remote server and you pulling down.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Cons\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The cons of this method are that shared access is generally more difficult to set up and reach from multiple locations than basic network access. If you want to push from your laptop when you\u8217're at home, you have to mount the remote disk, which can be difficult and slow compared to network-based access.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's also important to mention that this isn\u8217't necessarily the fastest option if you\u8217're using a shared mount of some kind. A local repository is fast only if you have fast access to the data. A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The SSH Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Probably the most common transport protocol for Git is SSH. This is because SSH access to servers is already set up in most places \u8212- and if it isn\u8217't, it\u8217's easy to do. SSH is also the only network-based protocol that you can easily read from and write to. The other two network protocols (HTTP and Git) are generally read-only, so even if you have them available for the unwashed masses, you still need SSH for your own write commands. SSH is also an authenticated network protocol; and because it\u8217's ubiquitous, it\u8217's generally easy to set up and use.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To clone a Git repository over SSH, you can specify ssh:// URL like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone ssh://user@server:project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or you can not specify a protocol \u8212- Git assumes SSH if you aren\u8217't explicit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone user@server:project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also not specify a user, and Git assumes the user you\u8217're currently logged in as.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Pros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The pros of using SSH are many. First, you basically have to use it if you want authenticated write access to your repository over a network. Second, SSH is relatively easy to set up \u8212- SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them. Next, access over SSH is secure \u8212- all data transfer is encrypted and authenticated. Last, like the Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Cons\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The negative aspect of SSH is that you can\u8217't serve anonymous access of your repository over it. People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn\u8217't make SSH access conducive to open source projects. If you\u8217're using it only within your corporate network, SSH may be the only protocol you need to deal with. If you want to allow anonymous read-only access to your projects, you\u8217'll have to set up SSH for you to push over but something else for others to pull over.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Git Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next is the Git protocol. This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication. In order for a repository to be served over the Git protocol, you must create the {\f1 git-export-daemon-ok} file \u8212- the daemon won\u8217't serve a repository without that file in it \u8212- but other than that there is no security. Either the Git repository is available for everyone to clone or it isn\u8217't. This means that there is generally no pushing over this protocol. You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project\u8217's URL could push to your project. Suffice it to say that this is rare.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Pros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Git protocol is the fastest transfer protocol available. If you\u8217're serving a lot of traffic for a public project or serving a very large project that doesn\u8217't require user authentication for read access, it\u8217's likely that you\u8217'll want to set up a Git daemon to serve your project. It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Cons\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The downside of the Git protocol is the lack of authentication. It\u8217's generally undesirable for the Git protocol to be the only access to your project. Generally, you\u8217'll pair it with SSH access for the few developers who have push (write) access and have everyone else use {\f1 git://} for read-only access. It\u8217's also probably the most difficult protocol to set up. It must run its own daemon, which is custom \u8212- we\u8217'll look at setting one up in the \u8220"Gitosis\u8221" section of this chapter \u8212- it requires {\f1 xinetd} configuration or the like, which isn\u8217't always a walk in the park. It also requires firewall access to port 9418, which isn\u8217't a standard port that corporate firewalls always allow. Behind big corporate firewalls, this obscure port is commonly blocked.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The HTTP/S Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Last we have the HTTP protocol. The beauty of the HTTP or HTTPS protocol is the simplicity of setting it up. Basically, all you have to do is put the bare Git repository under your HTTP document root and set up a specific {\f1 post-update} hook, and you\u8217're done (See Chapter 7 for details on Git hooks). At that point, anyone who can access the web server under which you put the repository can also clone your repository. To allow read access to your repository over HTTP, do something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd /var/www/htdocs/\line
$ git clone --bare /path/to/git_project gitproject.git\line
$ cd gitproject.git\line
$ mv hooks/post-update.sample hooks/post-update\line
$ chmod a+x hooks/post-update\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's all. The {\f1 post-update} hook that comes with Git by default runs the appropriate command ({\f1 git update-server-info}) to make HTTP fetching and cloning work properly. This command is run when you push to this repository over SSH; then, other people can clone via something like\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone http://example.com/gitproject.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this particular case, we\u8217're using the {\f1 /var/www/htdocs} path that is common for Apache setups, but you can use any static web server \u8212- just put the bare repository in its path. The Git data is served as basic static files (see Chapter 9 for details about exactly how it\u8217's served).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's possible to make Git push over HTTP as well, although that technique isn\u8217't as widely used and requires you to set up complex WebDAV requirements. Because it\u8217's rarely used, we won\u8217't cover it in this book. If you\u8217're interested in using the HTTP-push protocols, you can read about preparing a repository for this purpose at {\f1 http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt}. One nice thing about making Git push over HTTP is that you can use any WebDAV server, without specific Git features; so, you can use this functionality if your web-hosting provider supports WebDAV for writing updates to your web site.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Pros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The upside of using the HTTP protocol is that it\u8217's easy to set up. Running the handful of required commands gives you a simple way to give the world read access to your Git repository. It takes only a few minutes to do. The HTTP protocol also isn\u8217't very resource intensive on your server. Because it generally uses a static HTTP server to serve all the data, a normal Apache server can serve thousands of files per second on average \u8212- it\u8217's difficult to overload even a small server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates. Generally, if you\u8217're going to these lengths, it\u8217's easier to use SSH public keys; but it may be a better solution in your specific case to use signed SSL certificates or other HTTP-based authentication methods for read-only access over HTTPS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another nice thing is that HTTP is such a commonly used protocol that corporate firewalls are often set up to allow traffic through this port.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 The Cons\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The downside of serving your repository over HTTP is that it\u8217's relatively inefficient for the client. It generally takes a lot longer to clone or fetch from the repository, and you often have a lot more network overhead and transfer volume over HTTP than with any of the other network protocols. Because it\u8217's not as intelligent about transferring only the data you need \u8212- there is no dynamic work on the part of the server in these transactions \u8212- the HTTP protocol is often referred to as a {\i dumb} protocol. For more information about the differences in efficiency between the HTTP protocol and the other protocols, see Chapter 9.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Getting Git on a Server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In order to initially set up any Git server, you have to export an existing repository into a new bare repository \u8212- a repository that doesn\u8217't contain a working directory. This is generally straightforward to do. In order to clone your repository to create a new bare repository, you run the clone command with the {\f1 --bare} option. By convention, bare repository directories end in {\f1 .git}, like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone --bare my_project my_project.git\line
Initialized empty Git repository in /opt/projects/my_project.git/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The output for this command is a little confusing. Since {\f1 clone} is basically a {\f1 git init} then a {\f1 git fetch}, we see some output from the {\f1 git init} part, which creates an empty directory. The actual object transfer gives no output, but it does happen. You should now have a copy of the Git directory data in your {\f1 my_project.git} directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is roughly equivalent to something like\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cp -Rf my_project/.git my_project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are a couple of minor differences in the configuration file; but for your purpose, this is close to the same thing. It takes the Git repository by itself, without a working directory, and creates a directory specifically for it alone.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Putting the Bare Repository on a Server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have a bare copy of your repository, all you need to do is put it on a server and set up your protocols. Let\u8217's say you\u8217've set up a server called {\f1 git.example.com} that you have SSH access to, and you want to store all your Git repositories under the {\f1 /opt/git} directory. You can set up your new repository by copying your bare repository over:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ scp -r my_project.git user@git.example.com:/opt/git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, other users who have SSH access to the same server which has read-access to the {\f1 /opt/git} directory can clone your repository by running\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone user@git.example.com:/opt/git/my_project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a user SSHs into a server and has write access to the {\f1 /opt/git/my_project.git} directory, they will also automatically have push access. Git will automatically add group write permissions to a repository properly if you run the {\f1 git init} command with the {\f1 --shared} option.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh user@git.example.com\line
$ cd /opt/git/my_project.git\line
$ git init --bare --shared\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You see how easy it is to take a Git repository, create a bare version, and place it on a server to which you and your collaborators have SSH access. Now you\u8217're ready to collaborate on the same project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that this is literally all you need to do to run a useful Git server to which several people have access \u8212- just add SSH-able accounts on a server, and stick a bare repository somewhere that all those users have read and write access to. You\u8217're ready to go \u8212- nothing else needed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the next few sections, you\u8217'll see how to expand to more sophisticated setups. This discussion will include not having to create user accounts for each user, adding public read access to repositories, setting up web UIs, using the Gitosis tool, and more. However, keep in mind that to collaborate with a couple of people on a private project, all you {\i need} is an SSH server and a bare repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Small Setups\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're a small outfit or are just trying out Git in your organization and have only a few developers, things can be simple for you. One of the most complicated aspects of setting up a Git server is user management. If you want some repositories to be read-only to certain users and read/write to others, access and permissions can be a bit difficult to arrange.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 SSH Access\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you already have a server to which all your developers have SSH access, it\u8217's generally easiest to set up your first repository there, because you have to do almost no work (as we covered in the last section). If you want more complex access control type permissions on your repositories, you can handle them with the normal filesystem permissions of the operating system your server runs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to place your repositories on a server that doesn\u8217't have accounts for everyone on your team whom you want to have write access, then you must set up SSH access for them. We assume that if you have a server with which to do this, you already have an SSH server installed, and that\u8217's how you\u8217're accessing the server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are a few ways you can give access to everyone on your team. The first is to set up accounts for everybody, which is straightforward but can be cumbersome. You may not want to run {\f1 adduser} and set temporary passwords for every user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A second method is to create a single \u8216'git\u8217' user on the machine, ask every user who is to have write access to send you an SSH public key, and add that key to the {\f1 ~/.ssh/authorized_keys} file of your new \u8216'git\u8217' user. At that point, everyone will be able to access that machine via the \u8216'git\u8217' user. This doesn\u8217't affect the commit data in any way \u8212- the SSH user you connect as doesn\u8217't affect the commits you\u8217've recorded.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another way to do it is to have your SSH server authenticate from an LDAP server or some other centralized authentication source that you may already have set up. As long as each user can get shell access on the machine, any SSH authentication mechanism you can think of should work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Generating Your SSH Public Key\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That being said, many Git servers authenticate using SSH public keys. In order to provide a public key, each user in your system must generate one if they don\u8217't already have one. This process is similar across all operating systems. First, you should check to make sure you don\u8217't already have a key. By default, a user\u8217's SSH keys are stored in that user\u8217's {\f1 ~/.ssh} directory. You can easily check to see if you have a key already by going to that directory and listing the contents:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd ~/.ssh\line
$ ls\line
authorized_keys2  id_dsa       known_hosts\line
config            id_dsa.pub\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217're looking for a pair of files named something and something.pub, where the something is usually {\f1 id_dsa} or {\f1 id_rsa}. The {\f1 .pub} file is your public key, and the other file is your private key. If you don\u8217't have these files (or you don\u8217't even have a {\f1 .ssh} directory), you can create them by running a program called {\f1 ssh-keygen}, which is provided with the SSH package on Linux/Mac systems and comes with the MSysGit package on Windows:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh-keygen\line
Generating public/private rsa key pair.\line
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):\line
Enter passphrase (empty for no passphrase):\line
Enter same passphrase again:\line
Your identification has been saved in /Users/schacon/.ssh/id_rsa.\line
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.\line
The key fingerprint is:\line
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First it confirms where you want to save the key ({\f1 .ssh/id_rsa}), and then it asks twice for a passphrase, which you can leave empty if you don\u8217't want to type a password when you use the key.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, each user that does this has to send their public key to you or whoever is administrating the Git server (assuming you\u8217're using an SSH server setup that requires public keys). All they have to do is copy the contents of the {\f1 .pub} file and e-mail it. The public keys look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat ~/.ssh/id_rsa.pub\line
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU\line
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3\line
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA\line
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En\line
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx\line
NrRFi9wrf+M7Q== schacon@agadorlaptop.local\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For a more in-depth tutorial on creating an SSH key on multiple operating systems, see the GitHub guide on SSH keys at {\f1 http://github.com/guides/providing-your-ssh-key}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Setting Up the Server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's walk through setting up SSH access on the server side. In this example, you\u8217'll use the {\f1 authorized_keys} method for authenticating your users. We also assume you\u8217're running a standard Linux distribution like Ubuntu. First, you create a \u8216'git\u8217' user and a {\f1 .ssh} directory for that user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo adduser git\line
$ su git\line
$ cd\line
$ mkdir .ssh\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you need to add some developer SSH public keys to the {\f1 authorized_keys} file for that user. Let\u8217's assume you\u8217've received a few keys by e-mail and saved them to temporary files. Again, the public keys look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /tmp/id_rsa.john.pub\line
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L\line
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k\line
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez\line
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv\line
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq\line
dAv8JggJICUvax2T9va5 gsg-keypair\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You just append them to your {\f1 authorized_keys} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys\line
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys\line
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can set up an empty repository for them by running {\f1 git init} with the {\f1 --bare} option, which initializes the repository without a working directory:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd /opt/git\line
$ mkdir project.git\line
$ cd project.git\line
$ git --bare init\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, John, Josie, or Jessica can push the first version of their project into that repository by adding it as a remote and pushing up a branch. Note that someone must shell onto the machine and create a bare repository every time you want to add a project. Let\u8217's use {\f1 gitserver} as the hostname of the server on which you\u8217've set up your \u8216'git\u8217' user and repository. If you\u8217're running it internally, and you set up DNS for {\f1 gitserver} to point to that server, then you can use the commands pretty much as is:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # on Johns computer\line
$ cd myproject\line
$ git init\line
$ git add .\line
$ git commit -m 'initial commit'\line
$ git remote add origin git@gitserver:/opt/git/project.git\line
$ git push origin master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, the others can clone it down and push changes back up just as easily:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git@gitserver:/opt/git/project.git\line
$ cd project\line
$ vim README\line
$ git commit -am 'fix for the README file'\line
$ git push origin master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With this method, you can quickly get a read/write Git server up and running for a handful of developers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As an extra precaution, you can easily restrict the \u8216'git\u8217' user to only doing Git activities with a limited shell tool called {\f1 git-shell} that comes with Git. If you set this as your \u8216'git\u8217' user\u8217's login shell, then the \u8216'git\u8217' user can\u8217't have normal shell access to your server. To use this, specify {\f1 git-shell} instead of bash or csh for your user\u8217's login shell. To do so, you\u8217'll likely have to edit your {\f1 /etc/passwd} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo vim /etc/passwd\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At the bottom, you should find a line that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git:x:1000:1000::/home/git:/bin/sh\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Change {\f1 /bin/sh} to {\f1 /usr/bin/git-shell} (or run {\f1 which git-shell} to see where it\u8217's installed). The line should look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git:x:1000:1000::/home/git:/usr/bin/git-shell\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, the \u8216'git\u8217' user can only use the SSH connection to push and pull Git repositories and can\u8217't shell onto the machine. If you try, you\u8217'll see a login rejection like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh git@gitserver\line
fatal: What do you think I am? A shell?\line
Connection to gitserver closed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Public Access\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What if you want anonymous read access to your project? Perhaps instead of hosting an internal private project, you want to host an open source project. Or maybe you have a bunch of automated build servers or continuous integration servers that change a lot, and you don\u8217't want to have to generate SSH keys all the time \u8212- you just want to add simple anonymous read access.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Probably the simplest way for smaller setups is to run a static web server with its document root where your Git repositories are, and then enable that {\f1 post-update} hook we mentioned in the first section of this chapter. Let\u8217's work from the previous example. Say you have your repositories in the {\f1 /opt/git} directory, and an Apache server is running on your machine. Again, you can use any web server for this; but as an example, we\u8217'll demonstrate some basic Apache configurations that should give you an idea of what you might need.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First you need to enable the hook:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd project.git\line
$ mv hooks/post-update.sample hooks/post-update\line
$ chmod a+x hooks/post-update\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're using a version of Git earlier than 1.6, the {\f1 mv} command isn\u8217't necessary \u8212- Git started naming the hooks examples with the .sample postfix only recently.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What does this {\f1 post-update} hook do? It looks basically like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/hooks/post-update\line
#!/bin/sh\line
exec git-update-server-info\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means that when you push to the server via SSH, Git will run this command to update the files needed for HTTP fetching.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you need to add a VirtualHost entry to your Apache configuration with the document root as the root directory of your Git projects. Here, we\u8217're assuming that you have wildcard DNS set up to send {\f1 *.gitserver} to whatever box you\u8217're using to run all this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <VirtualHost *:80>\line
    ServerName git.gitserver\line
    DocumentRoot /opt/git\line
    <Directory /opt/git/>\line
        Order allow, deny\line
        allow from all\line
    </Directory>\line
</VirtualHost>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll also need to set the Unix user group of the {\f1 /opt/git} directories to {\f1 www-data} so your web server can read-access the repositories, because the Apache instance running the CGI script will (by default) be running as that user:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ chgrp -R www-data /opt/git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you restart Apache, you should be able to clone your repositories under that directory by specifying the URL for your project:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone http://git.gitserver/project.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, you can set up HTTP-based read access to any of your projects for a fair number of users in a few minutes. Another simple option for public unauthenticated access is to start a Git daemon, although that requires you to daemonize the process - we\u8217'll cover this option in the next section, if you prefer that route.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 GitWeb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have basic read/write and read-only access to your project, you may want to set up a simple web-based visualizer. Git comes with a CGI script called GitWeb that is commonly used for this. You can see GitWeb in use at sites like {\f1 http://git.kernel.org} (see Figure 4-1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0401.png Figure 4-1. The GitWeb web-based user interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to check out what GitWeb would look like for your project, Git comes with a command to fire up a temporary instance if you have a lightweight server on your system like {\f1 lighttpd} or {\f1 webrick}. On Linux machines, {\f1 lighttpd} is often installed, so you may be able to get it to run by typing {\f1 git instaweb} in your project directory. If you\u8217're running a Mac, Leopard comes preinstalled with Ruby, so {\f1 webrick} may be your best bet. To start {\f1 instaweb} with a non-lighttpd handler, you can run it with the {\f1 --httpd} option.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git instaweb --httpd=webrick\line
[2009-02-21 10:02:21] INFO  WEBrick 1.3.1\line
[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That starts up an HTTPD server on port 1234 and then automatically starts a web browser that opens on that page. It\u8217's pretty easy on your part. When you\u8217're done and want to shut down the server, you can run the same command with the {\f1 --stop} option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git instaweb --httpd=webrick --stop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to run the web interface on a server all the time for your team or for an open source project you\u8217're hosting, you\u8217'll need to set up the CGI script to be served by your normal web server. Some Linux distributions have a {\f1 gitweb} package that you may be able to install via {\f1 apt} or {\f1 yum}, so you may want to try that first. We\u8217'll walk though installing GitWeb manually very quickly. First, you need to get the Git source code, which GitWeb comes with, and generate the custom CGI script:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://git.kernel.org/pub/scm/git/git.git\line
$ cd git/\line
$ make GITWEB_PROJECTROOT="/opt/git" \\\line
        prefix=/usr gitweb\line
$ sudo cp -Rf gitweb /var/www/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that you have to tell the command where to find your Git repositories with the {\f1 GITWEB_PROJECTROOT} variable. Now, you need to make Apache use CGI for that script, for which you can add a VirtualHost:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 <VirtualHost *:80>\line
    ServerName gitserver\line
    DocumentRoot /var/www/gitweb\line
    <Directory /var/www/gitweb>\line
        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch\line
        AllowOverride All\line
        order allow,deny\line
        Allow from all\line
        AddHandler cgi-script cgi\line
        DirectoryIndex gitweb.cgi\line
    </Directory>\line
</VirtualHost>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, GitWeb can be served with any CGI capable web server; if you prefer to use something else, it shouldn\u8217't be difficult to set up. At this point, you should be able to visit {\f1 http://gitserver/} to view your repositories online, and you can use {\f1 http://git.gitserver} to clone and fetch your repositories over HTTP.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Gitosis\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Keeping all users\u8217' public keys in the {\f1 authorized_keys} file for access works well only for a while. When you have hundreds of users, it\u8217's much more of a pain to manage that process. You have to shell onto the server each time, and there is no access control \u8212- everyone in the file has read and write access to every project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you may want to turn to a widely used software project called Gitosis. Gitosis is basically a set of scripts that help you manage the {\f1 authorized_keys} file as well as implement some simple access controls. The really interesting part is that the UI for this tool for adding people and determining access isn\u8217't a web interface but a special Git repository. You set up the information in that project; and when you push it, Gitosis reconfigures the server based on that, which is cool.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Installing Gitosis isn\u8217't the simplest task ever, but it\u8217's not too difficult. It\u8217's easiest to use a Linux server for it \u8212- these examples use a stock Ubuntu 8.10 server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitosis requires some Python tools, so first you have to install the Python setuptools package, which Ubuntu provides as python-setuptools:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ apt-get install python-setuptools\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you clone and install Gitosis from the project\u8217's main site:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://eagain.net/gitosis.git\line
$ cd gitosis\line
$ sudo python setup.py install\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That installs a couple of executables that Gitosis will use. Next, Gitosis wants to put its repositories under {\f1 /home/git}, which is fine. But you have already set up your repositories in {\f1 /opt/git}, so instead of reconfiguring everything, you create a symlink:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ln -s /opt/git /home/git/repositories\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitosis is going to manage your keys for you, so you need to remove the current file, re-add the keys later, and let Gitosis control the {\f1 authorized_keys} file automatically. For now, move the {\f1 authorized_keys} file out of the way:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next you need to turn your shell back on for the \u8216'git\u8217' user, if you changed it to the {\f1 git-shell} command. People still won\u8217't be able to log in, but Gitosis will control that for you. So, let\u8217's change this line in your {\f1 /etc/passwd} file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git:x:1000:1000::/home/git:/usr/bin/git-shell\par}
{\pard \ql \f0 \sa180 \li0 \fi0 back to this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git:x:1000:1000::/home/git:/bin/sh\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now it\u8217's time to initialize Gitosis. You do this by running the {\f1 gitosis-init} command with your personal public key. If your public key isn\u8217't on the server, you\u8217'll have to copy it there:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo -H -u git gitosis-init < /tmp/id_dsa.pub\line
Initialized empty Git repository in /opt/git/gitosis-admin.git/\line
Reinitialized existing Git repository in /opt/git/gitosis-admin.git/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This lets the user with that key modify the main Git repository that controls the Gitosis setup. Next, you have to manually set the execute bit on the {\f1 post-update} script for your new control repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217're ready to roll. If you\u8217're set up correctly, you can try to SSH into your server as the user for which you added the public key to initialize Gitosis. You should see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh git@gitserver\line
PTY allocation request failed on channel 0\line
fatal: unrecognized command 'gitosis-serve schacon@quaternion'\line
  Connection to gitserver closed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That means Gitosis recognized you but shut you out because you\u8217're not trying to do any Git commands. So, let\u8217's do an actual Git command \u8212- you\u8217'll clone the Gitosis control repository:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # on your local computer\line
$ git clone git@gitserver:gitosis-admin.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have a directory named {\f1 gitosis-admin}, which has two major parts:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd gitosis-admin\line
$ find .\line
./gitosis.conf\line
./keydir\line
./keydir/scott.pub\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 gitosis.conf} file is the control file you use to specify users, repositories, and permissions. The {\f1 keydir} directory is where you store the public keys of all the users who have any sort of access to your repositories \u8212- one file per user. The name of the file in {\f1 keydir} (in the previous example, {\f1 scott.pub}) will be different for you \u8212- Gitosis takes that name from the description at the end of the public key that was imported with the {\f1 gitosis-init} script.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you look at the {\f1 gitosis.conf} file, it should only specify information about the {\f1 gitosis-admin} project that you just cloned:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat gitosis.conf\line
[gitosis]\line
\line
[group gitosis-admin]\line
writable = gitosis-admin\line
members = scott\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It shows you that the \u8216'scott\u8217' user \u8212- the user with whose public key you initialized Gitosis \u8212- is the only one who has access to the {\f1 gitosis-admin} project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, let\u8217's add a new project for you. You\u8217'll add a new section called {\f1 mobile} where you\u8217'll list the developers on your mobile team and projects that those developers need access to. Because \u8216'scott\u8217' is the only user in the system right now, you\u8217'll add him as the only member, and you\u8217'll create a new project called {\f1 iphone_project} to start on:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [group mobile]\line
writable = iphone_project\line
members = scott\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Whenever you make changes to the {\f1 gitosis-admin} project, you have to commit the changes and push them back up to the server in order for them to take effect:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -am 'add iphone_project and mobile group'\line
[master]: created 8962da8: "changed name"\line
 1 files changed, 4 insertions(+), 0 deletions(-)\line
$ git push\line
Counting objects: 5, done.\line
Compressing objects: 100% (2/2), done.\line
Writing objects: 100% (3/3), 272 bytes, done.\line
Total 3 (delta 1), reused 0 (delta 0)\line
To git@gitserver:/opt/git/gitosis-admin.git\line
   fb27aec..8962da8  master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can make your first push to the new {\f1 iphone_project} project by adding your server as a remote to your local version of the project and pushing. You no longer have to manually create a bare repository for new projects on the server \u8212- Gitosis creates them automatically when it sees the first push:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add origin git@gitserver:iphone_project.git\line
$ git push origin master\line
Initialized empty Git repository in /opt/git/iphone_project.git/\line
Counting objects: 3, done.\line
Writing objects: 100% (3/3), 230 bytes, done.\line
Total 3 (delta 0), reused 0 (delta 0)\line
To git@gitserver:iphone_project.git\line
 * [new branch]      master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that you don\u8217't need to specify the path (in fact, doing so won\u8217't work), just a colon and then the name of the project \u8212- Gitosis finds it for you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You want to work on this project with your friends, so you\u8217'll have to re-add their public keys. But instead of appending them manually to the {\f1 ~/.ssh/authorized_keys} file on your server, you\u8217'll add them, one key per file, into the {\f1 keydir} directory. How you name the keys determines how you refer to the users in the {\f1 gitosis.conf} file. Let\u8217's re-add the public keys for John, Josie, and Jessica:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cp /tmp/id_rsa.john.pub keydir/john.pub\line
$ cp /tmp/id_rsa.josie.pub keydir/josie.pub\line
$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can add them all to your \u8216'mobile\u8217' team so they have read and write access to {\f1 iphone_project}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [group mobile]\line
writable = iphone_project\line
members = scott john josie jessica\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After you commit and push that change, all four users will be able to read from and write to that project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitosis has simple access controls as well. If you want John to have only read access to this project, you can do this instead:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [group mobile]\line
writable = iphone_project\line
members = scott josie jessica\line
\line
[group mobile_ro]\line
readonly = iphone_project\line
members = john\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now John can clone the project and get updates, but Gitosis won\u8217't allow him to push back up to the project. You can create as many of these groups as you want, each containing different users and projects. You can also specify another group as one of the members (using {\f1 @} as prefix), to inherit all of its members automatically:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [group mobile_committers]\line
members = scott josie jessica\line
\line
[group mobile]\line
writable  = iphone_project\line
members   = @mobile_committers\line
\line
[group mobile_2]\line
writable  = another_iphone_project\line
members   = @mobile_committers john\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have any issues, it may be useful to add {\f1 loglevel=DEBUG} under the {\f1 [gitosis]} section. If you\u8217've lost push access by pushing a messed-up configuration, you can manually fix the file on the server under {\f1 /home/git/.gitosis.conf} \u8212- the file from which Gitosis reads its info. A push to the project takes the {\f1 gitosis.conf} file you just pushed up and sticks it there. If you edit that file manually, it remains like that until the next successful push to the {\f1 gitosis-admin} project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Gitolite\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This section serves as a quick introduction to gitolite, and provides basic installation and setup instructions. It cannot, however, replace the enormous amount of {\field{\*\fldinst{HYPERLINK "http://sitaramc.github.com/gitolite/master-toc.html"}}{\fldrslt{\ul
documentation
}}}
 that gitolite comes with. There may also be occasional changes to this section itself, so you may also want to look at the latest version {\field{\*\fldinst{HYPERLINK "http://sitaramc.github.com/gitolite/progit.html"}}{\fldrslt{\ul
here
}}}
.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite is an authorisation layer on top of git, relying on sshd or httpd for authentication. (Recap: authentication is identifying who the user is, authorisation is deciding if he is allowed to do what he is attempting to).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite allows you to specify permissions not just by repository, but also by branch or tag names within each repository. That is, you can specify that certain people (or groups of people) can only push certain \u8220"refs\u8221" (branches or tags) but not others.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Installing Gitolite is very easy, even if you don\u8217't read the extensive documentation that comes with it. You need an account on a Unix server of some kind. You do not need root access, assuming git, perl, and an openssh compatible ssh server are already installed. In the examples below, we will use the {\f1 git} account on a host called {\f1 gitserver}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite is somewhat unusual as far as \u8220"server\u8221" software goes \u8211- access is via ssh, and so every userid on the server is a potential \u8220"gitolite host\u8221". We will describe the simplest install method in this article; for the other methods please see the documentation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To begin, create a user called {\f1 git} on your server and login to this user. Copy your ssh pubkey (a file called {\f1 ~/.ssh/id_rsa.pub} if you did a plain {\f1 ssh-keygen} with all the defaults) from your workstation, renaming it to {\f1 YourName.pub}. Then run these commands:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git clone git://github.com/sitaramc/gitolite\line
gitolite/install -ln\line
    # assumes $HOME/bin exists and is in your $PATH\line
gitolite setup -pk $HOME/YourName.pub\line
    # for example, I would run 'gitolite setup -pk $HOME/sitaram.pub'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, back on your workstation, run {\f1 git clone git@server:gitolite-admin}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 And you\u8217're done! Gitolite has now been installed on the server, and you now have a brand new repository called {\f1 gitolite-admin} in your workstation. You administer your gitolite setup by making changes to this repository and pushing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Customising the Install\par}
{\pard \ql \f0 \sa180 \li0 \fi0 While the default, quick, install works for most people, there are some ways to customise the install if you need to. Some changes can be made simply by editing the rc file, but if that is not sufficient, there\u8217's documentation on customising Gitolite.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Config File and Access Control Rules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Once the install is done, you switch to the {\f1 gitolite-admin} clone you just made on your workstation, and poke around to see what you got:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd ~/gitolite-admin/\line
$ ls\line
conf/  keydir/\line
$ find conf keydir -type f\line
conf/gitolite.conf\line
keydir/sitaram.pub\line
$ cat conf/gitolite.conf\line
\line
repo gitolite-admin\line
    RW+                 = sitaram\line
\line
repo testing\line
    RW+                 = @all\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that \u8220"sitaram\u8221" (the name of the pubkey in the gl-setup command you used earlier) has read-write permissions on the {\f1 gitolite-admin} repository as well as a public key file of the same name.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Adding users is easy. To add a user called \u8220"alice\u8221", obtain her public key, name it \u8220"alice.pub\u8221", and put it in the \u8220"keydir\u8221" directory of the clone of the gitolite-admin repo you just made on your workstation. Add, commit, and push the change, and the user has been added.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The config file syntax for gitolite is well documented, so we\u8217'll only mention some highlights here.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can group users or repos for convenience. The group names are just like macros; when defining them, it doesn\u8217't even matter whether they are projects or users; that distinction is only made when you {\i use} the \u8220"macro\u8221".\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 @oss_repos      = linux perl rakudo git gitolite\line
@secret_repos   = fenestra pear\line
\line
@admins         = scott     # Adams, not Chacon, sorry :)\line
@interns        = ashok     # get the spelling right, Scott!\line
@engineers      = sitaram dilbert wally alice\line
@staff          = @admins @engineers @interns\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can control permissions at the \u8220"ref\u8221" level. In the following example, interns can only push the \u8220"int\u8221" branch. Engineers can push any branch whose name starts with \u8220"eng-\u8221", and tags that start with \u8220"rc\u8221" followed by a digit. And the admins can do anything (including rewind) to any ref.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 repo @oss_repos\line
    RW  int$                = @interns\line
    RW  eng-                = @engineers\line
    RW  refs/tags/rc[0-9]   = @engineers\line
    RW+                     = @admins\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The expression after the {\f1 RW} or {\f1 RW+} is a regular expression (regex) that the refname (ref) being pushed is matched against. So we call it a \u8220"refex\u8221"! Of course, a refex can be far more powerful than shown here, so don\u8217't overdo it if you\u8217're not comfortable with Perl regexes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also, as you probably guessed, Gitolite prefixes {\f1 refs/heads/} as a syntactic convenience if the refex does not begin with {\f1 refs/}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An important feature of the config file\u8217's syntax is that all the rules for a repository need not be in one place. You can keep all the common stuff together, like the rules for all {\f1 oss_repos} shown above, then add specific rules for specific cases later on, like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 repo gitolite\line
    RW+                     = sitaram\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That rule will just get added to the ruleset for the {\f1 gitolite} repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point you might be wondering how the access control rules are actually applied, so let\u8217's go over that briefly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are two levels of access control in Gitolite. The first is at the repository level; if you have read (or write) access to {\i any} ref in the repository, then you have read (or write) access to the repository. This is the only access control that Gitosis had.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The second level, applicable only to \u8220"write\u8221" access, is by branch or tag within a repository. The username, the access being attempted ({\f1 W} or {\f1 +}), and the refname being updated are known. The access rules are checked in order of appearance in the config file, looking for a match for this combination (but remember that the refname is regex-matched, not merely string-matched). If a match is found, the push succeeds. A fallthrough results in access being denied.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Advanced Access Control with \u8220"deny\u8221" rules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So far, we\u8217've only seen permissions to be one of {\f1 R}, {\f1 RW}, or {\f1 RW+}. However, Gitolite allows another permission: {\f1 -}, standing for \u8220"deny\u8221". This gives you a lot more power, at the expense of some complexity, because now fallthrough is not the {\i only} way for access to be denied, so the {\i order of the rules now matters}!\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let us say, in the situation above, we want engineers to be able to rewind any branch {\i except} master and integ. Here\u8217's how to do that:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1     RW  master integ    = @engineers\line
    -   master integ    = @engineers\line
    RW+                 = @engineers\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, you simply follow the rules top down until you hit a match for your access mode, or a deny. Non-rewind push to master or integ is allowed by the first rule. A rewind push to those refs does not match the first rule, drops down to the second, and is therefore denied. Any push (rewind or non-rewind) to refs other than master or integ won\u8217't match the first two rules anyway, and the third rule allows it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Restricting pushes by files changed\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to restricting what branches a user can push changes to, you can also restrict what files they are allowed to touch. For example, perhaps the Makefile (or some other program) is really not supposed to be changed by just anyone, because a lot of things depend on it or would break if the changes are not done {\i just right}. You can tell gitolite:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 repo foo\line
    RW                      =   @junior_devs @senior_devs\line
\line
    -   VREF/NAME/Makefile  =   @junior_devs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 User who are migrating from the older gitolite should note that there is a significant change in behaviour with regard to this feature; please see the migration guide for details.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Personal Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite also has a feature called \u8220"personal branches\u8221" (or rather, \u8220"personal branch namespace\u8221") that can be very useful in a corporate environment.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A lot of code exchange in the git world happens by \u8220"please pull\u8221" requests. In a corporate environment, however, unauthenticated access is a no-no, and a developer workstation cannot do authentication, so you have to push to the central server and ask someone to pull from there.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This would normally cause the same branch name clutter as in a centralised VCS, plus setting up permissions for this becomes a chore for the admin.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite lets you define a \u8220"personal\u8221" or \u8220"scratch\u8221" namespace prefix for each developer (for example, {\f1 refs/personal/<devname>/*}); please see the documentation for details.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 \u8220"Wildcard\u8221" repositories\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitolite allows you to specify repositories with wildcards (actually perl regexes), like, for example {\f1 assignments/s[0-9][0-9]/a[0-9][0-9]}, to pick a random example. It also allows you to assign a new permission mode (\u8220"C\u8221") which enables users to create repositories based on such wild cards, automatically assigns ownership to the specific user who created it, allows him/her to hand out R and RW permissions to other users to collaborate, etc. Again, please see the documentation for details.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Other Features\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We\u8217'll round off this discussion with a sampling of other features, all of which, and many more, are described in great detail in the documentation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Logging}: Gitolite logs all successful accesses. If you were somewhat relaxed about giving people rewind permissions ({\f1 RW+}) and some kid blew away \u8220"master\u8221", the log file is a life saver, in terms of easily and quickly finding the SHA that got hosed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Access rights reporting}: Another convenient feature is what happens when you try and just ssh to the server. Gitolite shows you what repos you have access to, and what that access may be. Here\u8217's an example:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1     hello sitaram, this is git@git running gitolite3 v3.01-18-g9609868 on git 1.7.4.4\line
\line
         R     anu-wsd\line
         R     entrans\line
         R  W  git-notes\line
         R  W  gitolite\line
         R  W  gitolite-admin\line
         R     indic_web_input\line
         R     shreelipi_converter\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Delegation}: For really large installations, you can delegate responsibility for groups of repositories to various people and have them manage those pieces independently. This reduces the load on the main admin, and makes him less of a bottleneck.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Mirroring}: Gitolite can help you maintain multiple mirrors, and switch between them easily if the primary server goes down.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Daemon\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For public, unauthenticated read access to your projects, you\u8217'll want to move past the HTTP protocol and start using the Git protocol. The main reason is speed. The Git protocol is far more efficient and thus faster than the HTTP protocol, so using it will save your users time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, this is for unauthenticated read-only access. If you\u8217're running this on a server outside your firewall, it should only be used for projects that are publicly visible to the world. If the server you\u8217're running it on is inside your firewall, you might use it for projects that a large number of people or computers (continuous integration or build servers) have read-only access to, when you don\u8217't want to have to add an SSH key for each.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In any case, the Git protocol is relatively easy to set up. Basically, you need to run this command in a daemonized manner:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git daemon --reuseaddr --base-path=/opt/git/ /opt/git/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 --reuseaddr} allows the server to restart without waiting for old connections to time out, the {\f1 --base-path} option allows people to clone projects without specifying the entire path, and the path at the end tells the Git daemon where to look for repositories to export. If you\u8217're running a firewall, you\u8217'll also need to punch a hole in it at port 9418 on the box you\u8217're setting this up on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can daemonize this process a number of ways, depending on the operating system you\u8217're running. On an Ubuntu machine, you use an Upstart script. So, in the following file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 /etc/event.d/local-git-daemon\par}
{\pard \ql \f0 \sa180 \li0 \fi0 you put this script:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 start on startup\line
stop on shutdown\line
exec /usr/bin/git daemon \\\line
    --user=git --group=git \\\line
    --reuseaddr \\\line
    --base-path=/opt/git/ \\\line
    /opt/git/\line
respawn\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For security reasons, it is strongly encouraged to have this daemon run as a user with read-only permissions to the repositories \u8212- you can easily do this by creating a new user \u8216'git-ro\u8217' and running the daemon as them. For the sake of simplicity we\u8217'll simply run it as the same \u8216'git\u8217' user that Gitosis is running as.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you restart your machine, your Git daemon will start automatically and respawn if it goes down. To get it running without having to reboot, you can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 initctl start local-git-daemon\par}
{\pard \ql \f0 \sa180 \li0 \fi0 On other systems, you may want to use {\f1 xinetd}, a script in your {\f1 sysvinit} system, or something else \u8212- as long as you get that command daemonized and watched somehow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you have to tell your Gitosis server which repositories to allow unauthenticated Git server-based access to. If you add a section for each repository, you can specify the ones from which you want your Git daemon to allow reading. If you want to allow Git protocol access for the {\f1 iphone_project}, you add this to the end of the {\f1 gitosis.conf} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [repo iphone_project]\line
daemon = yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When that is committed and pushed up, your running daemon should start serving requests for the project to anyone who has access to port 9418 on your server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you decide not to use Gitosis, but you want to set up a Git daemon, you\u8217'll have to run this on each project you want the Git daemon to serve:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cd /path/to/project.git\line
$ touch git-daemon-export-ok\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The presence of that file tells Git that it\u8217's OK to serve this project without authentication.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Gitosis can also control which projects GitWeb shows. First, you need to add something like the following to the {\f1 /etc/gitweb.conf} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $projects_list = "/home/git/gitosis/projects.list";\line
$projectroot = "/home/git/repositories";\line
$export_ok = "git-daemon-export-ok";\line
@git_base_url_list = ('git://gitserver');\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can control which projects GitWeb lets users browse by adding or removing a {\f1 gitweb} setting in the Gitosis configuration file. For instance, if you want the {\f1 iphone_project} to show up on GitWeb, you make the {\f1 repo} setting look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [repo iphone_project]\line
daemon = yes\line
gitweb = yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, if you commit and push the project, GitWeb will automatically start showing the {\f1 iphone_project}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Hosted Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you don\u8217't want to go through all of the work involved in setting up your own Git server, you have several options for hosting your Git projects on an external dedicated hosting site. Doing so offers a number of advantages: a hosting site is generally quick to set up and easy to start projects on, and no server maintenance or monitoring is involved. Even if you set up and run your own server internally, you may still want to use a public hosting site for your open source code \u8212- it\u8217's generally easier for the open source community to find and help you with.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These days, you have a huge number of hosting options to choose from, each with different advantages and disadvantages. To see an up-to-date list, check out the following page:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 http://en.wikipedia.org/wiki/Git_(software)#Source_code_hosting\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because we can\u8217't cover all of them, and because I happen to work at one of them, we\u8217'll use this section to walk through setting up an account and creating a new project at GitHub. This will give you an idea of what is involved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 GitHub is by far the largest open source Git hosting site and it\u8217's also one of the very few that offers both public and private hosting options so you can keep your open source and private commercial code in the same place. In fact, we used GitHub to privately collaborate on this book.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 GitHub\par}
{\pard \ql \f0 \sa180 \li0 \fi0 GitHub is slightly different than most code-hosting sites in the way that it namespaces projects. Instead of being primarily based on the project, GitHub is user centric. That means when I host my {\f1 grit} project on GitHub, you won\u8217't find it at {\f1 github.com/grit} but instead at {\f1 github.com/schacon/grit}. There is no canonical version of any project, which allows a project to move from one user to another seamlessly if the first author abandons the project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 GitHub is also a commercial company that charges for accounts that maintain private repositories, but anyone can quickly get a free account to host as many open source projects as they want. We\u8217'll quickly go over how that is done.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Setting Up a User Account\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first thing you need to do is set up a free user account. If you visit the Pricing and Signup page at {\f1 http://github.com/plans} and click the \u8220"Sign Up\u8221" button on the Free account (see Figure 4-2), you\u8217're taken to the signup page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0402.png Figure 4-2. The GitHub plan page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here you must choose a username that isn\u8217't yet taken in the system and enter an e-mail address that will be associated with the account and a password (see Figure 4-3).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0403.png Figure 4-3. The GitHub user signup form.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have it available, this is a good time to add your public SSH key as well. We covered how to generate a new key earlier, in the \u8220"Simple Setups\u8221" section. Take the contents of the public key of that pair, and paste it into the SSH Public Key text box. Clicking the \u8220"explain ssh keys\u8221" link takes you to detailed instructions on how to do so on all major operating systems. Clicking the \u8220"I agree, sign me up\u8221" button takes you to your new user dashboard (see Figure 4-4).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0404.png Figure 4-4. The GitHub user dashboard.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next you can create a new repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Creating a New Repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Start by clicking the \u8220"create a new one\u8221" link next to Your Repositories on the user dashboard. You\u8217're taken to the Create a New Repository form (see Figure 4-5).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0405.png Figure 4-5. Creating a new repository on GitHub.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All you really have to do is provide a project name, but you can also add a description. When that is done, click the \u8220"Create Repository\u8221" button. Now you have a new repository on GitHub (see Figure 4-6).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0406.png Figure 4-6. GitHub project header information.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Since you have no code there yet, GitHub will show you instructions for how create a brand-new project, push an existing Git project up, or import a project from a public Subversion repository (see Figure 4-7).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0407.png Figure 4-7. Instructions for a new repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These instructions are similar to what we\u8217've already gone over. To initialize a project if it isn\u8217't already a Git project, you use\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git init\line
$ git add .\line
$ git commit -m 'initial commit'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you have a Git repository locally, add GitHub as a remote and push up your master branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add origin git@github.com:testinguser/iphone_project.git\line
$ git push origin master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now your project is hosted on GitHub, and you can give the URL to anyone you want to share your project with. In this case, it\u8217's {\f1 http://github.com/testinguser/iphone_project}. You can also see from the header on each of your project\u8217's pages that you have two Git URLs (see Figure 4-8).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0408.png Figure 4-8. Project header with a public URL and a private URL.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Public Clone URL is a public, read-only Git URL over which anyone can clone the project. Feel free to give out that URL and post it on your web site or what have you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Your Clone URL is a read/write SSH-based URL that you can read or write over only if you connect with the SSH private key associated with the public key you uploaded for your user. When other users visit this project page, they won\u8217't see that URL\u8212-only the public one.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Importing from Subversion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have an existing public Subversion project that you want to import into Git, GitHub can often do that for you. At the bottom of the instructions page is a link to a Subversion import. If you click it, you see a form with information about the import process and a text box where you can paste in the URL of your public Subversion project (see Figure 4-9).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0409.png Figure 4-9. Subversion importing interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If your project is very large, nonstandard, or private, this process probably won\u8217't work for you. In Chapter 7, you\u8217'll learn how to do more complicated manual project imports.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Adding Collaborators\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's add the rest of the team. If John, Josie, and Jessica all sign up for accounts on GitHub, and you want to give them push access to your repository, you can add them to your project as collaborators. Doing so will allow pushes from their public keys to work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Click the \u8220"edit\u8221" button in the project header or the Admin tab at the top of the project to reach the Admin page of your GitHub project (see Figure 4-10).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0410.png Figure 4-10. GitHub administration page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To give another user write access to your project, click the \u8220"Add another collaborator\u8221" link. A new text box appears, into which you can type a username. As you type, a helper pops up, showing you possible username matches. When you find the correct user, click the Add button to add that user as a collaborator on your project (see Figure 4-11).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0411.png Figure 4-11. Adding a collaborator to your project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you\u8217're finished adding collaborators, you should see a list of them in the Repository Collaborators box (see Figure 4-12).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0412.png Figure 4-12. A list of collaborators on your project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you need to revoke access to individuals, you can click the \u8220"revoke\u8221" link, and their push access will be removed. For future projects, you can also copy collaborator groups by copying the permissions of an existing project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Your Project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After you push your project up or have it imported from Subversion, you have a main project page that looks something like Figure 4-13.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0413.png Figure 4-13. A GitHub main project page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When people visit your project, they see this page. It contains tabs to different aspects of your projects. The Commits tab shows a list of commits in reverse chronological order, similar to the output of the {\f1 git log} command. The Network tab shows all the people who have forked your project and contributed back. The Downloads tab allows you to upload project binaries and link to tarballs and zipped versions of any tagged points in your project. The Wiki tab provides a wiki where you can write documentation or other information about your project. The Graphs tab has some contribution visualizations and statistics about your project. The main Source tab that you land on shows your project\u8217's main directory listing and automatically renders the README file below it if you have one. This tab also shows a box with the latest commit information.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Forking Projects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to contribute to an existing project to which you don\u8217't have push access, GitHub encourages forking the project. When you land on a project page that looks interesting and you want to hack on it a bit, you can click the \u8220"fork\u8221" button in the project header to have GitHub copy that project to your user so you can push to it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, projects don\u8217't have to worry about adding users as collaborators to give them push access. People can fork a project and push to it, and the main project maintainer can pull in those changes by adding them as remotes and merging in their work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To fork a project, visit the project page (in this case, mojombo/chronic) and click the \u8220"fork\u8221" button in the header (see Figure 4-14).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0414.png Figure 4-14. Get a writable copy of any repository by clicking the \u8220"fork\u8221" button.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After a few seconds, you\u8217're taken to your new project page, which indicates that this project is a fork of another one (see Figure 4-15).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0415.png Figure 4-15. Your fork of a project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 GitHub Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's all we\u8217'll cover about GitHub, but it\u8217's important to note how quickly you can do all this. You can create an account, add a new project, and push to it in a matter of minutes. If your project is open source, you also get a huge community of developers who now have visibility into your project and may well fork it and help contribute to it. At the very least, this may be a way to get up and running with Git and try it out quickly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have several options to get a remote Git repository up and running so that you can collaborate with others or share your work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Running your own server gives you a lot of control and allows you to run the server within your own firewall, but such a server generally requires a fair amount of your time to set up and maintain. If you place your data on a hosted server, it\u8217's easy to set up and maintain; however, you have to be able to keep your code on someone else\u8217's servers, and some organizations don\u8217't allow that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It should be fairly straightforward to determine which solution or combination of solutions is appropriate for you and your organization.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Distributed Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have a remote Git repository set up as a point for all the developers to share their code, and you\u8217're familiar with basic Git commands in a local workflow, you\u8217'll look at how to utilize some of the distributed workflows that Git affords you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this chapter, you\u8217'll see how to work with Git in a distributed environment as a contributor and an integrator. That is, you\u8217'll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Distributed Workflows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects. In centralized systems, every developer is a node working more or less equally on a central hub. In Git, however, every developer is potentially both a node and a hub \u8212- that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to. This opens a vast range of workflow possibilities for your project and/or your team, so I\u8217'll cover a few common paradigms that take advantage of this flexibility. I\u8217'll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Centralized Workflow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In centralized systems, there is generally a single collaboration model\u8212-the centralized workflow. One central hub, or repository, can accept code, and everyone synchronizes their work to it. A number of developers are nodes \u8212- consumers of that hub \u8212- and synchronize to that one place (see Figure 5-1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0501.png Figure 5-1. Centralized workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems. The second developer must merge in the first one\u8217's work before pushing changes up, so as not to overwrite the first developer\u8217's changes. This concept is true in Git as it is in Subversion (or any CVCS), and this model works perfectly in Git.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a small team or are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git. Simply set up a single repository, and give everyone on your team push access; Git won\u8217't let users overwrite each other. If one developer clones, makes changes, and then tries to push their changes while another developer has pushed in the meantime, the server will reject that developer\u8217's changes. They will be told that they\u8217're trying to push non-fast-forward changes and that they won\u8217't be able to do so until they fetch and merge. This workflow is attractive to a lot of people because it\u8217's a paradigm that many are familiar and comfortable with.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Integration-Manager Workflow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because Git allows you to have multiple remote repositories, it\u8217's possible to have a workflow where each developer has write access to their own public repository and read access to everyone else\u8217's. This scenario often includes a canonical repository that represents the \u8220"official\u8221" project. To contribute to that project, you create your own public clone of the project and push your changes to it. Then, you can send a request to the maintainer of the main project to pull in your changes. They can add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository. The process works as follow (see Figure 5-2):\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab The project maintainer pushes to their public repository.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab A contributor clones that repository and makes changes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab The contributor pushes to their own public copy.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab The contributor sends the maintainer an e-mail asking them to pull changes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab The maintainer adds the contributor\u8217's repo as a remote and merges locally.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 6.\tx360\tab The maintainer pushes merged changes to the main repository.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0502.png Figure 5-2. Integration-manager workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a very common workflow with sites like GitHub, where it\u8217's easy to fork a project and push your changes into your fork for everyone to see. One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time. Contributors don\u8217't have to wait for the project to incorporate their changes \u8212- each party can work at their own pace.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Dictator and Lieutenants Workflow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a variant of a multiple-repository workflow. It\u8217's generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel. Various integration managers are in charge of certain parts of the repository; they\u8217're called lieutenants. All the lieutenants have one integration manager known as the benevolent dictator. The benevolent dictator\u8217's repository serves as the reference repository from which all the collaborators need to pull. The process works like this (see Figure 5-3):\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Lieutenants merge the developers\u8217' topic branches into their master branch.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab The dictator merges the lieutenants\u8217' master branches into the dictator\u8217's master branch.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab The dictator pushes their master to the reference repository so the other developers can rebase on it.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0503.png Figure 5-3. Benevolent dictator workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This kind of workflow isn\u8217't common but can be useful in very big projects or in highly hierarchical environments, as it allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow. Now that you can (I hope) determine which workflow combination may work for you, I\u8217'll cover some more specific examples of how to accomplish the main roles that make up the different flows.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Contributing to a Project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You know what the different workflows are, and you should have a pretty good grasp of fundamental Git usage. In this section, you\u8217'll learn about a few common patterns for contributing to a project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The main difficulty with describing this process is that there are a huge number of variations on how it\u8217's done. Because Git is very flexible, people can and do work together many ways, and it\u8217's problematic to describe how you should contribute to a project \u8212- every project is a bit different. Some of the variables involved are active contributor size, chosen workflow, your commit access, and possibly the external contribution method.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first variable is active contributor size. How many users are actively contributing code to this project, and how often? In many instances, you\u8217'll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects. For really large companies or projects, the number of developers could be in the thousands, with dozens or even hundreds of patches coming in each day. This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged. Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied. How can you keep your code consistently up to date and your patches valid?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next variable is the workflow in use for the project. Is it centralized, with each developer having equal write access to the main codeline? Does the project have a maintainer or integration manager who checks all the patches? Are all the patches peer-reviewed and approved? Are you involved in that process? Is a lieutenant system in place, and do you have to submit your work to them first?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next issue is your commit access. The workflow required in order to contribute to a project is much different if you have write access to the project than if you don\u8217't. If you don\u8217't have write access, how does the project prefer to accept contributed work? Does it even have a policy? How much work are you contributing at a time? How often do you contribute?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you. I\u8217'll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Commit Guidelines\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Before you start looking at the specific use cases, here\u8217's a quick note about commit messages. Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier. The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches \u8212- you can read it in the Git source code in the {\f1 Documentation/SubmittingPatches} file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, you don\u8217't want to submit any whitespace errors. Git provides an easy way to check for this \u8212- before you commit, run {\f1 git diff --check}, which identifies possible whitespace errors and lists them for you. Here is an example, where I\u8217've replaced a red terminal color with {\f1 X}s:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff --check\line
lib/simplegit.rb:5: trailing whitespace.\line
+    @git_dir = File.expand_path(git_dir)XX\line
lib/simplegit.rb:7: trailing whitespace.\line
+ XXXXXXXXXXX\line
lib/simplegit.rb:26: trailing whitespace.\line
+    def command(git_cmd)XXXX\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run that command before committing, you can tell if you\u8217're about to commit whitespace issues that may annoy other developers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, try to make each commit a logically separate changeset. If you can, try to make your changes digestible \u8212- don\u8217't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday. Even if you don\u8217't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit. If some of the changes modify the same file, try to use {\f1 git add --patch} to partially stage files (covered in detail in Chapter 6). The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes. This approach also makes it easier to pull out or revert one of the changesets if you need to later. Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files \u8212- use these tools to help craft a clean and understandable history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last thing to keep in mind is the commit message. Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier. As a general rule, your messages should start with a single line that\u8217's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation. The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior \u8212- this is a good guideline to follow. It\u8217's also a good idea to use the imperative present tense in these messages. In other words, use commands. Instead of \u8220"I added tests for\u8221" or \u8220"Adding tests for,\u8221" use \u8220"Add tests for.\u8221" Here is a template originally written by Tim Pope at tpope.net:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Short (50 chars or less) summary of changes\line
\line
More detailed explanatory text, if necessary.  Wrap it to about 72\line
characters or so.  In some contexts, the first line is treated as the\line
subject of an email and the rest of the text as the body.  The blank\line
line separating the summary from the body is critical (unless you omit\line
the body entirely); tools like rebase can get confused if you run the\line
two together.\line
\line
Further paragraphs come after blank lines.\line
\line
 - Bullet points are okay, too\line
\line
 - Typically a hyphen or asterisk is used for the bullet, preceded by a\line
   single space, with blank lines in between, but conventions vary here\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If all your commit messages look like this, things will be a lot easier for you and the developers you work with. The Git project has well-formatted commit messages \u8212- I encourage you to run {\f1 git log --no-merges} there to see what a nicely formatted project-commit history looks like.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the following examples, and throughout most of this book, for the sake of brevity I don\u8217't format messages nicely like this; instead, I use the {\f1 -m} option to {\f1 git commit}. Do as I say, not as I do.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Private Small Team\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The simplest setup you\u8217're likely to encounter is a private project with one or two other developers. By private, I mean closed source \u8212- not read-accessible to the outside world. You and the other developers all have push access to the repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system. You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time. Let\u8217's see what it might look like when two developers start to work together with a shared repository. The first developer, John, clones the repository, makes a change, and commits locally. (I\u8217'm replacing the protocol messages with {\f1 ...} in these examples to shorten them somewhat.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # John's Machine\line
$ git clone john@githost:simplegit.git\line
Initialized empty Git repository in /home/john/simplegit/.git/\line
...\line
$ cd simplegit/\line
$ vim lib/simplegit.rb\line
$ git commit -am 'removed invalid default value'\line
[master 738ee87] removed invalid default value\line
 1 files changed, 1 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The second developer, Jessica, does the same thing \u8212- clones the repository and commits a change:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Jessica's Machine\line
$ git clone jessica@githost:simplegit.git\line
Initialized empty Git repository in /home/jessica/simplegit/.git/\line
...\line
$ cd simplegit/\line
$ vim TODO\line
$ git commit -am 'add reset task'\line
[master fbff5bc] add reset task\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Jessica pushes her work up to the server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Jessica's Machine\line
$ git push origin master\line
...\line
To jessica@githost:simplegit.git\line
   1edee6b..fbff5bc  master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 John tries to push his change up, too:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # John's Machine\line
$ git push origin master\line
To john@githost:simplegit.git\line
 ! [rejected]        master -> master (non-fast forward)\line
error: failed to push some refs to 'john@githost:simplegit.git'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 John isn\u8217't allowed to push because Jessica has pushed in the meantime. This is especially important to understand if you\u8217're used to Subversion, because you\u8217'll notice that the two developers didn\u8217't edit the same file. Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally. John has to fetch Jessica\u8217's changes and merge them in before he will be allowed to push:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin\line
...\line
From john@githost:simplegit\line
 + 049d078...fbff5bc master     -> origin/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, John\u8217's local repository looks something like Figure 5-4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0504.png Figure 5-4. John\u8217's initial repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge origin/master\line
Merge made by recursive.\line
 TODO |    1 +\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The merge goes smoothly \u8212- John\u8217's commit history now looks like Figure 5-5.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0505.png Figure 5-5. John\u8217's repository after merging origin/master.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin master\line
...\line
To john@githost:simplegit.git\line
   fbff5bc..72bbc59  master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, John\u8217's commit history looks like Figure 5-6.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0506.png Figure 5-6. John\u8217's history after pushing to the origin server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the meantime, Jessica has been working on a topic branch. She\u8217's created a topic branch called {\f1 issue54} and done three commits on that branch. She hasn\u8217't fetched John\u8217's changes yet, so her commit history looks like Figure 5-7.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0507.png Figure 5-7. Jessica\u8217's initial commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica wants to sync up with John, so she fetches:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Jessica's Machine\line
$ git fetch origin\line
...\line
From jessica@githost:simplegit\line
   fbff5bc..72bbc59  master     -> origin/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That pulls down the work John has pushed up in the meantime. Jessica\u8217's history now looks like Figure 5-8.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0508.png Figure 5-8. Jessica\u8217's history after fetching John\u8217's changes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica thinks her topic branch is ready, but she wants to know what she has to merge her work into so that she can push. She runs {\f1 git log} to find out:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --no-merges origin/master ^issue54\line
commit 738ee872852dfaa9d6634e0dea7a324040193016\line
Author: John Smith <jsmith@example.com>\line
Date:   Fri May 29 16:01:27 2009 -0700\line
\line
    removed invalid default value\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Jessica can merge her topic work into her master branch, merge John\u8217's work ({\f1 origin/master}) into her {\f1 master} branch, and then push back to the server again. First, she switches back to her master branch to integrate all this work:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
Switched to branch "master"\line
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 She can merge either {\f1 origin/master} or {\f1 issue54} first \u8212- they\u8217're both upstream, so the order doesn\u8217't matter. The end snapshot should be identical no matter which order she chooses; only the history will be slightly different. She chooses to merge in {\f1 issue54} first:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge issue54\line
Updating fbff5bc..4af4298\line
Fast forward\line
 README           |    1 +\line
 lib/simplegit.rb |    6 +++++-\line
 2 files changed, 6 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 No problems occur; as you can see, it was a simple fast-forward. Now Jessica merges in John\u8217's work ({\f1 origin/master}):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge origin/master\line
Auto-merging lib/simplegit.rb\line
Merge made by recursive.\line
 lib/simplegit.rb |    2 +-\line
 1 files changed, 1 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Everything merges cleanly, and Jessica\u8217's history looks like Figure 5-9.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0509.png Figure 5-9. Jessica\u8217's history after merging John\u8217's changes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now {\f1 origin/master} is reachable from Jessica\u8217's {\f1 master} branch, so she should be able to successfully push (assuming John hasn\u8217't pushed again in the meantime):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin master\line
...\line
To jessica@githost:simplegit.git\line
   72bbc59..8059c15  master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each developer has committed a few times and merged each other\u8217's work successfully; see Figure 5-10.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0510.png Figure 5-10. Jessica\u8217's history after pushing all changes back to the server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is one of the simplest workflows. You work for a while, generally in a topic branch, and merge into your master branch when it\u8217's ready to be integrated. When you want to share that work, you merge it into your own master branch, then fetch and merge {\f1 origin/master} if it has changed, and finally push to the {\f1 master} branch on the server. The general sequence is something like that shown in Figure 5-11.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0511.png Figure 5-11. General sequence of events for a simple multiple-developer Git workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Private Managed Team\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this next scenario, you\u8217'll look at contributor roles in a larger private group. You\u8217'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second. In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the {\f1 master} branch of the main repo can be updated only by those engineers. In this scenario, all work is done in team-based branches and pulled together by the integrators later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's follow Jessica\u8217's workflow as she works on her two features, collaborating in parallel with two different developers in this environment. Assuming she already has her repository cloned, she decides to work on {\f1 featureA} first. She creates a new branch for the feature and does some work on it there:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Jessica's Machine\line
$ git checkout -b featureA\line
Switched to a new branch "featureA"\line
$ vim lib/simplegit.rb\line
$ git commit -am 'add limit to log function'\line
[featureA 3300904] add limit to log function\line
 1 files changed, 1 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, she needs to share her work with John, so she pushes her {\f1 featureA} branch commits up to the server. Jessica doesn\u8217't have push access to the {\f1 master} branch \u8212- only the integrators do \u8212- so she has to push to another branch in order to collaborate with John:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin featureA\line
...\line
To jessica@githost:simplegit.git\line
 * [new branch]      featureA -> featureA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica e-mails John to tell him that she\u8217's pushed some work into a branch named {\f1 featureA} and he can look at it now. While she waits for feedback from John, Jessica decides to start working on {\f1 featureB} with Josie. To begin, she starts a new feature branch, basing it off the server\u8217's {\f1 master} branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # Jessica's Machine\line
$ git fetch origin\line
$ git checkout -b featureB origin/master\line
Switched to a new branch "featureB"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Jessica makes a couple of commits on the {\f1 featureB} branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ vim lib/simplegit.rb\line
$ git commit -am 'made the ls-tree function recursive'\line
[featureB e5b0fdc] made the ls-tree function recursive\line
 1 files changed, 1 insertions(+), 1 deletions(-)\line
$ vim lib/simplegit.rb\line
$ git commit -am 'add ls-files'\line
[featureB 8512791] add ls-files\line
 1 files changed, 5 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica\u8217's repository looks like Figure 5-12.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0512.png Figure 5-12. Jessica\u8217's initial commit history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 She\u8217's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as {\f1 featureBee}. Jessica first needs to merge those changes in with her own before she can push to the server. She can then fetch Josie\u8217's changes down with {\f1 git fetch}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin\line
...\line
From jessica@githost:simplegit\line
 * [new branch]      featureBee -> origin/featureBee\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica can now merge this into the work she did with {\f1 git merge}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge origin/featureBee\line
Auto-merging lib/simplegit.rb\line
Merge made by recursive.\line
 lib/simplegit.rb |    4 ++++\line
 1 files changed, 4 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There is a bit of a problem \u8212- she needs to push the merged work in her {\f1 featureB} branch to the {\f1 featureBee} branch on the server. She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the {\f1 git push} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin featureB:featureBee\line
...\line
To jessica@githost:simplegit.git\line
   fba9af8..cd685d1  featureB -> featureBee\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is called a {\i refspec}. See Chapter 9 for a more detailed discussion of Git refspecs and different things you can do with them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, John e-mails Jessica to say he\u8217's pushed some changes to the {\f1 featureA} branch and ask her to verify them. She runs a {\f1 git fetch} to pull down those changes:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin\line
...\line
From jessica@githost:simplegit\line
   3300904..aad881d  featureA   -> origin/featureA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, she can see what has been changed with {\f1 git log}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log origin/featureA ^featureA\line
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6\line
Author: John Smith <jsmith@example.com>\line
Date:   Fri May 29 19:57:33 2009 -0700\line
\line
    changed log output to 30 from 25\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, she merges John\u8217's work into her own {\f1 featureA} branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout featureA\line
Switched to branch "featureA"\line
$ git merge origin/featureA\line
Updating 3300904..aad881d\line
Fast forward\line
 lib/simplegit.rb |   10 +++++++++-\line
1 files changed, 9 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica wants to tweak something, so she commits again and then pushes this back up to the server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -am 'small tweak'\line
[featureA 774b3ed] small tweak\line
 1 files changed, 1 insertions(+), 1 deletions(-)\line
$ git push origin featureA\line
...\line
To jessica@githost:simplegit.git\line
   3300904..774b3ed  featureA -> featureA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica\u8217's commit history now looks something like Figure 5-13.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0513.png Figure 5-13. Jessica\u8217's history after committing on a feature branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Jessica, Josie, and John inform the integrators that the {\f1 featureA} and {\f1 featureBee} branches on the server are ready for integration into the mainline. After they integrate these branches into the mainline, a fetch will bring down the new merge commits, making the commit history look like Figure 5-14.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0514.png Figure 5-14. Jessica\u8217's history after merging both her topic branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process. The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git. The sequence for the workflow you saw here is something like Figure 5-15.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0515.png Figure 5-15. Basic sequence of this managed-team workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Public Small Project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Contributing to public projects is a bit different. Because you don\u8217't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way. This first example describes contributing via forking on Git hosts that support easy forking. The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution. The next section deals with projects that prefer to accept contributed patches via e-mail.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, you\u8217'll probably want to clone the main repository, create a topic branch for the patch or patch series you\u8217're planning to contribute, and do your work there. The sequence looks basically like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone (url)\line
$ cd project\line
$ git checkout -b featureA\line
$ (work)\line
$ git commit\line
$ (work)\line
$ git commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may want to use {\f1 rebase -i} to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review \u8212- see Chapter 6 for more information about interactive rebasing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When your branch work is finished and you\u8217're ready to contribute it back to the maintainers, go to the original project page and click the \u8220"Fork\u8221" button, creating your own writable fork of the project. You then need to add in this new repository URL as a second remote, in this case named {\f1 myfork}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add myfork (url)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You need to push your work up to it. It\u8217's easiest to push the remote branch you\u8217're working on up to your repository, rather than merging into your master branch and pushing that up. The reason is that if the work isn\u8217't accepted or is cherry picked, you don\u8217't have to rewind your master branch. If the maintainers merge, rebase, or cherry-pick your work, you\u8217'll eventually get it back via pulling from their repository anyhow:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push myfork featureA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When your work has been pushed up to your fork, you need to notify the maintainer. This is often called a pull request, and you can either generate it via the website \u8212- GitHub has a \u8220"pull request\u8221" button that automatically messages the maintainer \u8212- or run the {\f1 git request-pull} command and e-mail the output to the project maintainer manually.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 request-pull} command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you\u8217're asking to be pulled in. For instance, if Jessica wants to send John a pull request, and she\u8217's done two commits on the topic branch she just pushed up, she can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git request-pull origin/master myfork\line
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:\line
  John Smith (1):\line
        added a new function\line
\line
are available in the git repository at:\line
\line
  git://githost/simplegit.git featureA\line
\line
Jessica Smith (2):\line
      add limit to log function\line
      change log output to 30 from 25\line
\line
 lib/simplegit.rb |   10 +++++++++-\line
 1 files changed, 9 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The output can be sent to the maintainer\u8212-it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 On a project for which you\u8217're not the maintainer, it\u8217's generally easier to have a branch like {\f1 master} always track {\f1 origin/master} and to do your work in topic branches that you can easily discard if they\u8217're rejected. Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly. For example, if you want to submit a second topic of work to the project, don\u8217't continue working on the topic branch you just pushed up \u8212- start over from the main repository\u8217's {\f1 master} branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b featureB origin/master\line
$ (work)\line
$ git commit\line
$ git push myfork featureB\line
$ (email maintainer)\line
$ git fetch origin\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, each of your topics is contained within a silo \u8212- similar to a patch queue \u8212- that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0516.png Figure 5-16. Initial commit history with featureB work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges. In this case, you can try to rebase that branch on top of {\f1 origin/master}, resolve the conflicts for the maintainer, and then resubmit your changes:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout featureA\line
$ git rebase origin/master\line
$ git push -f myfork featureA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This rewrites your history to now look like Figure 5-17.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0517.png Figure 5-17. Commit history after featureA work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because you rebased the branch, you have to specify the {\f1 -f} to your push command in order to be able to replace the {\f1 featureA} branch on the server with a commit that isn\u8217't a descendant of it. An alternative would be to push this new work to a different branch on the server (perhaps called {\f1 featureAv2}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail. You\u8217'll also take this opportunity to move the work to be based off the project\u8217's current {\f1 master} branch. You start a new branch based off the current {\f1 origin/master} branch, squash the {\f1 featureB} changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b featureBv2 origin/master\line
$ git merge --no-commit --squash featureB\line
$ (change implementation)\line
$ git commit\line
$ git push myfork featureBv2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 --squash} option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you\u8217're on. The {\f1 --no-commit} option tells Git not to automatically record a commit. This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can send the maintainer a message that you\u8217've made the requested changes and they can find those changes in your {\f1 featureBv2} branch (see Figure 5-18).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0518.png Figure 5-18. Commit history after featureBv2 work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Public Large Project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many larger projects have established procedures for accepting patches \u8212- you\u8217'll need to check the specific rules for each project, because they will differ. However, many larger public projects accept patches via a developer mailing list, so I\u8217'll go over an example of that now.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The workflow is similar to the previous use case \u8212- you create topic branches for each patch series you work on. The difference is how you submit them to the project. Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b topicA\line
$ (work)\line
$ git commit\line
$ (work)\line
$ git commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have two commits that you want to send to the mailing list. You use {\f1 git format-patch} to generate the mbox-formatted files that you can e-mail to the list \u8212- it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body. The nice thing about this is that applying a patch from an e-mail generated with {\f1 format-patch} preserves all the commit information properly, as you\u8217'll see more of in the next section when you apply these patches:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git format-patch -M origin/master\line
0001-add-limit-to-log-function.patch\line
0002-changed-log-output-to-30-from-25.patch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 format-patch} command prints out the names of the patch files it creates. The {\f1 -M} switch tells Git to look for renames. The files end up looking like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat 0001-add-limit-to-log-function.patch\line
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\line
From: Jessica Smith <jessica@example.com>\line
Date: Sun, 6 Apr 2008 10:17:23 -0700\line
Subject: [PATCH 1/2] add limit to log function\line
\line
Limit log functionality to the first 20\line
\line
---\line
 lib/simplegit.rb |    2 +-\line
 1 files changed, 1 insertions(+), 1 deletions(-)\line
\line
diff --git a/lib/simplegit.rb b/lib/simplegit.rb\line
index 76f47bc..f9815f1 100644\line
--- a/lib/simplegit.rb\line
+++ b/lib/simplegit.rb\line
@@ -14,7 +14,7 @@ class SimpleGit\line
   end\line
\line
   def log(treeish = 'master')\line
-    command("git log #\{treeish\}")\line
+    command("git log -n 20 #\{treeish\}")\line
   end\line
\line
   def ls_tree(treeish = 'master')\line
--\line
1.6.2.rc1.20.g8c5b.dirty\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also edit these patch files to add more information for the e-mail list that you don\u8217't want to show up in the commit message. If you add text between the {\f1 --} line and the beginning of the patch (the {\f1 lib/simplegit.rb} line), then developers can read it; but applying the patch excludes it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program. Pasting the text often causes formatting issues, especially with \u8220"smarter\u8221" clients that don\u8217't preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you. I\u8217'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent I use; you can read detailed instructions for a number of mail programs at the end of the aforementioned {\f1 Documentation/SubmittingPatches} file in the Git source code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, you need to set up the imap section in your {\f1 ~/.gitconfig} file. You can set each value separately with a series of {\f1 git config} commands, or you can add them manually; but in the end, your config file should look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [imap]\line
  folder = "[Gmail]/Drafts"\line
  host = imaps://imap.gmail.com\line
  user = user@gmail.com\line
  pass = p4ssw0rd\line
  port = 993\line
  sslverify = false\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If your IMAP server doesn\u8217't use SSL, the last two lines probably aren\u8217't necessary, and the host value will be {\f1 imap://} instead of {\f1 imaps://}. When that is set up, you can use {\f1 git send-email} to place the patch series in the Drafts folder of the specified IMAP server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git send-email *.patch\line
0001-added-limit-to-log-function.patch\line
0002-changed-log-output-to-30-from-25.patch\line
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]\line
Emails will be sent from: Jessica Smith <jessica@example.com>\line
Who should the emails be sent to? jessica@example.com\line
Message-ID to be used as In-Reply-To for the first email? y\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, Git spits out a bunch of log information looking something like this for each patch you\u8217're sending:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 (mbox) Adding cc: Jessica Smith <jessica@example.com> from\line
  \\line 'From: Jessica Smith <jessica@example.com>'\line
OK. Log says:\line
Sendmail: /usr/sbin/sendmail -i jessica@example.com\line
From: Jessica Smith <jessica@example.com>\line
To: jessica@example.com\line
Subject: [PATCH 1/2] added limit to log function\line
Date: Sat, 30 May 2009 13:29:15 -0700\line
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>\line
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty\line
In-Reply-To: <y>\line
References: <y>\line
\line
Result: OK\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you\u8217're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This section has covered a number of common workflows for dealing with several very different types of Git projects you\u8217're likely to encounter and introduced a couple of new tools to help you manage this process. Next, you\u8217'll see how to work the other side of the coin: maintaining a Git project. You\u8217'll learn how to be a benevolent dictator or integration manager.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Maintaining a Project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to knowing how to effectively contribute to a project, you\u8217'll likely need to know how to maintain one. This can consist of accepting and applying patches generated via {\f1 format-patch} and e-mailed to you, or integrating changes in remote branches for repositories you\u8217've added as remotes to your project. Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is clearest for other contributors and sustainable by you over the long run.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Working in Topic Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you\u8217're thinking of integrating new work, it\u8217's generally a good idea to try it out in a topic branch \u8212- a temporary branch specifically made to try out that new work. This way, it\u8217's easy to tweak a patch individually and leave it if it\u8217's not working until you have time to come back to it. If you create a simple branch name based on the theme of the work you\u8217're going to try, such as {\f1 ruby_client} or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later. The maintainer of the Git project tends to namespace these branches as well \u8212- such as {\f1 sc/ruby_client}, where {\f1 sc} is short for the person who contributed the work. As you\u8217'll remember, you can create the branch based off your master branch like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch sc/ruby_client master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or, if you want to also switch to it immediately, you can use the {\f1 checkout -b} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b sc/ruby_client master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217're ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Applying Patches from E-mail\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you receive a patch over e-mail that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it. There are two ways to apply an e-mailed patch: with {\f1 git apply} or with {\f1 git am}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Applying a Patch with apply\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you received the patch from someone who generated it with the {\f1 git diff} or a Unix {\f1 diff} command, you can apply it with the {\f1 git apply} command. Assuming you saved the patch at {\f1 /tmp/patch-ruby-client.patch}, you can apply the patch like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git apply /tmp/patch-ruby-client.patch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This modifies the files in your working directory. It\u8217's almost identical to running a {\f1 patch -p1} command to apply the patch, although it\u8217's more paranoid and accepts fewer fuzzy matches than patch. It also handles file adds, deletes, and renames if they\u8217're described in the {\f1 git diff} format, which {\f1 patch} won\u8217't do. Finally, {\f1 git apply} is an \u8220"apply all or abort all\u8221" model where either everything is applied or nothing is, whereas {\f1 patch} can partially apply patchfiles, leaving your working directory in a weird state. {\f1 git apply} is overall much more paranoid than {\f1 patch}. It won\u8217't create a commit for you \u8212- after running it, you must stage and commit the changes introduced manually.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also use git apply to see if a patch applies cleanly before you try actually applying it \u8212- you can run {\f1 git apply --check} with the patch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git apply --check 0001-seeing-if-this-helps-the-gem.patch\line
error: patch failed: ticgit.gemspec:1\line
error: ticgit.gemspec: patch does not apply\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If there is no output, then the patch should apply cleanly. This command also exits with a non-zero status if the check fails, so you can use it in scripts if you want.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Applying a Patch with am\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the contributor is a Git user and was good enough to use the {\f1 format-patch} command to generate their patch, then your job is easier because the patch contains author information and a commit message for you. If you can, encourage your contributors to use {\f1 format-patch} instead of {\f1 diff} to generate patches for you. You should only have to use {\f1 git apply} for legacy patches and things like that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To apply a patch generated by {\f1 format-patch}, you use {\f1 git am}. Technically, {\f1 git am} is built to read an mbox file, which is a simple, plain-text format for storing one or more e-mail messages in one text file. It looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\line
From: Jessica Smith <jessica@example.com>\line
Date: Sun, 6 Apr 2008 10:17:23 -0700\line
Subject: [PATCH 1/2] add limit to log function\line
\line
Limit log functionality to the first 20\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is the beginning of the output of the format-patch command that you saw in the previous section. This is also a valid mbox e-mail format. If someone has e-mailed you the patch properly using git send-email, and you download that into an mbox format, then you can point git am to that mbox file, and it will start applying all the patches it sees. If you run a mail client that can save several e-mails out in mbox format, you can save entire patch series into a file and then use git am to apply them one at a time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, if someone uploaded a patch file generated via {\f1 format-patch} to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to {\f1 git am} to apply it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git am 0001-limit-log-function.patch\line
Applying: add limit to log function\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that it applied cleanly and automatically created the new commit for you. The author information is taken from the e-mail\u8217's {\f1 From} and {\f1 Date} headers, and the message of the commit is taken from the {\f1 Subject} and body (before the patch) of the e-mail. For example, if this patch was applied from the mbox example I just showed, the commit generated would look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=fuller -1\line
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\line
Author:     Jessica Smith <jessica@example.com>\line
AuthorDate: Sun Apr 6 10:17:23 2008 -0700\line
Commit:     Scott Chacon <schacon@gmail.com>\line
CommitDate: Thu Apr 9 09:19:06 2009 -0700\line
\line
   add limit to log function\line
\line
   Limit log functionality to the first 20\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 Commit} information indicates the person who applied the patch and the time it was applied. The {\f1 Author} information is the individual who originally created the patch and when it was originally created.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But it\u8217's possible that the patch won\u8217't apply cleanly. Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven\u8217't applied yet. In that case, the {\f1 git am} process will fail and ask you what you want to do:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git am 0001-seeing-if-this-helps-the-gem.patch\line
Applying: seeing if this helps the gem\line
error: patch failed: ticgit.gemspec:1\line
error: ticgit.gemspec: patch does not apply\line
Patch failed at 0001.\line
When you have resolved this problem run "git am --resolved".\line
If you would prefer to skip this patch, instead run "git am --skip".\line
To restore the original branch and stop patching run "git am --abort".\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command puts conflict markers in any files it has issues with, much like a conflicted merge or rebase operation. You solve this issue much the same way \u8212- edit the file to resolve the conflict, stage the new file, and then run {\f1 git am --resolved} to continue to the next patch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ (fix the file)\line
$ git add ticgit.gemspec\line
$ git am --resolved\line
Applying: seeing if this helps the gem\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want Git to try a bit more intelligently to resolve the conflict, you can pass a {\f1 -3} option to it, which makes Git attempt a three-way merge. This option isn\u8217't on by default because it doesn\u8217't work if the commit the patch says it was based on isn\u8217't in your repository. If you do have that commit \u8212- if the patch was based on a public commit \u8212- then the {\f1 -3} option is generally much smarter about applying a conflicting patch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git am -3 0001-seeing-if-this-helps-the-gem.patch\line
Applying: seeing if this helps the gem\line
error: patch failed: ticgit.gemspec:1\line
error: ticgit.gemspec: patch does not apply\line
Using index info to reconstruct a base tree...\line
Falling back to patching base and 3-way merge...\line
No changes -- Patch already applied.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, I was trying to apply a patch I had already applied. Without the {\f1 -3} option, it looks like a conflict.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're applying a number of patches from an mbox, you can also run the {\f1 am} command in interactive mode, which stops at each patch it finds and asks if you want to apply it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git am -3 -i mbox\line
Commit Body is:\line
--------------------------\line
seeing if this helps the gem\line
--------------------------\line
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is nice if you have a number of patches saved, because you can view the patch first if you don\u8217't remember what it is, or not apply the patch if you\u8217've already done so.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When all the patches for your topic are applied and committed into your branch, you can choose whether and how to integrate them into a longer-running branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Checking Out Remote Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and the name of the remote branch the changes are in, you can add them as a remote and do merges locally.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For instance, if Jessica sends you an e-mail saying that she has a great new feature in the {\f1 ruby-client} branch of her repository, you can test it by adding the remote and checking out that branch locally:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add jessica git://github.com/jessica/myproject.git\line
$ git fetch jessica\line
$ git checkout -b rubyclient jessica/ruby-client\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If she e-mails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is most useful if you\u8217're working with a person consistently. If someone only has a single patch to contribute once in a while, then accepting it over e-mail may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches. You\u8217're also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two. However, scripts and hosted services may make this easier \u8212- it depends largely on how you develop and how your contributors develop.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other advantage of this approach is that you get the history of the commits as well. Although you may have legitimate merge issues, you know where in your history their work is based; a proper three-way merge is the default rather than having to supply a {\f1 -3} and hope the patch was generated off a public commit to which you have access.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you aren\u8217't working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the {\f1 git pull} command. This does a one-time pull and doesn\u8217't save the URL as a remote reference:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git pull git://github.com/onetimeguy/project.git\line
From git://github.com/onetimeguy/project\line
 * branch            HEAD       -> FETCH_HEAD\line
Merge made by recursive.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Determining What Is Introduced\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have a topic branch that contains contributed work. At this point, you can determine what you\u8217'd like to do with it. This section revisits a couple of commands so you can see how you can use them to review exactly what you\u8217'll be introducing if you merge this into your main branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's often helpful to get a review of all the commits that are in this branch but that aren\u8217't in your master branch. You can exclude commits in the master branch by adding the {\f1 --not} option before the branch name. For example, if your contributor sends you two patches and you create a branch called {\f1 contrib} and applied those patches there, you can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log contrib --not master\line
commit 5b6235bd297351589efc4d73316f0a68d484f118\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri Oct 24 09:53:59 2008 -0700\line
\line
    seeing if this helps the gem\line
\line
commit 7482e0d16d04bea79d0dba8988cc78df655f16a0\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Mon Oct 22 19:38:36 2008 -0700\line
\line
    updated the gemspec to hopefully work better\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see what changes each commit introduces, remember that you can pass the {\f1 -p} option to {\f1 git log} and it will append the diff introduced to each commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use a weird trick to get the correct results. You may think to run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command gives you a diff, but it may be misleading. If your {\f1 master} branch has moved forward since you created the topic branch from it, then you\u8217'll get seemingly strange results. This happens because Git directly compares the snapshots of the last commit of the topic branch you\u8217're on and the snapshot of the last commit on the {\f1 master} branch. For example, if you\u8217've added a line in a file on the {\f1 master} branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If {\f1 master} is a direct ancestor of your topic branch, this isn\u8217't a problem; but if the two histories have diverged, the diff will look like you\u8217're adding all the new stuff in your topic branch and removing everything unique to the {\f1 master} branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What you really want to see are the changes added to the topic branch \u8212- the work you\u8217'll introduce if you merge this branch with master. You do that by having Git compare the last commit on your topic branch with the first common ancestor it has with the master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge-base contrib master\line
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649\line
$ git diff 36c7db\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, that isn\u8217't convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax. In the context of the {\f1 diff} command, you can put three periods after another branch to do a {\f1 diff} between the last commit of the branch you\u8217're on and its common ancestor with another branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff master...contrib\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command shows you only the work your current topic branch has introduced since its common ancestor with master. That is a very useful syntax to remember.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Integrating Contributed Work\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When all the work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it. Furthermore, what overall workflow do you want to use to maintain your project? You have a number of choices, so I\u8217'll cover a few of them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Merging Workflows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One simple workflow merges your work into your {\f1 master} branch. In this scenario, you have a {\f1 master} branch that contains basically stable code. When you have work in a topic branch that you\u8217've done or that someone has contributed and you\u8217've verified, you merge it into your master branch, delete the topic branch, and then continue the process. If we have a repository with work in two branches named {\f1 ruby_client} and {\f1 php_client} that looks like Figure 5-19 and merge {\f1 ruby_client} first and then {\f1 php_client} next, then your history will end up looking like Figure 5-20.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0519.png Figure 5-19. History with several topic branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0520.png Figure 5-20. After a topic branch merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is probably the simplest workflow, but it\u8217's problematic if you\u8217're dealing with larger repositories or projects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have more developers or a larger project, you\u8217'll probably want to use at least a two-phase merge cycle. In this scenario, you have two long-running branches, {\f1 master} and {\f1 develop}, in which you determine that {\f1 master} is updated only when a very stable release is cut and all new code is integrated into the {\f1 develop} branch. You regularly push both of these branches to the public repository. Each time you have a new topic branch to merge in (Figure 5-21), you merge it into {\f1 develop} (Figure 5-22); then, when you tag a release, you fast-forward {\f1 master} to wherever the now-stable {\f1 develop} branch is (Figure 5-23).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0521.png Figure 5-21. Before a topic branch merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0522.png Figure 5-22. After a topic branch merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0523.png Figure 5-23. After a topic branch release.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, when people clone your project\u8217's repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff. You can also continue this concept, having an integrate branch where all the work is merged together. Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Large-Merging Workflows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The Git project has four long-running branches: {\f1 master}, {\f1 next}, and {\f1 pu} (proposed updates) for new work, and {\f1 maint} for maintenance backports. When new work is introduced by contributors, it\u8217's collected into topic branches in the maintainer\u8217's repository in a manner similar to what I\u8217've described (see Figure 5-24). At this point, the topics are evaluated to determine whether they\u8217're safe and ready for consumption or whether they need more work. If they\u8217're safe, they\u8217're merged into {\f1 next}, and that branch is pushed up so everyone can try the topics integrated together.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0524.png Figure 5-24. Managing a complex series of parallel contributed topic branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the topics still need work, they\u8217're merged into {\f1 pu} instead. When it\u8217's determined that they\u8217're totally stable, the topics are re-merged into {\f1 master} and are then rebuilt from the topics that were in {\f1 next} but didn\u8217't yet graduate to {\f1 master}. This means {\f1 master} almost always moves forward, {\f1 next} is rebased occasionally, and {\f1 pu} is rebased even more often (see Figure 5-25).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0525.png Figure 5-25. Merging contributed topic branches into long-term integration branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When a topic branch has finally been merged into {\f1 master}, it\u8217's removed from the repository. The Git project also has a {\f1 maint} branch that is forked off from the last release to provide backported patches in case a maintenance release is required. Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Rebasing and Cherry Picking Workflows\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history. When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or {\f1 develop}, and so on) branch. If that works well, you can fast-forward your {\f1 master} branch, and you\u8217'll end up with a linear project history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other way to move introduced work from one branch to another is to cherry-pick it. A cherry-pick in Git is like a rebase for a single commit. It takes the patch that was introduced in a commit and tries to reapply it on the branch you\u8217're currently on. This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you\u8217'd prefer to cherry-pick it rather than run rebase. For example, suppose you have a project that looks like Figure 5-26.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0526.png Figure 5-26. Example history before a cherry pick.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to pull commit {\f1 e43a6} into your master branch, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf\line
Finished one cherry-pick.\line
[master]: created a0a41a9: "More friendly message when locking the index fails."\line
 3 files changed, 17 insertions(+), 3 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This pulls the same change introduced in {\f1 e43a6}, but you get a new commit SHA-1 value, because the date applied is different. Now your history looks like Figure 5-27.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0527.png Figure 5-27. History after cherry-picking a commit on a topic branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can remove your topic branch and drop the commits you didn\u8217't want to pull in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tagging Your Releases\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you\u8217've decided to cut a release, you\u8217'll probably want to drop a tag so you can re-create that release at any point going forward. You can create a new tag as I discussed in Chapter 2. If you decide to sign the tag as the maintainer, the tagging may look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -s v1.5 -m 'my signed 1.5 tag'\line
You need a passphrase to unlock the secret key for\line
user: "Scott Chacon <schacon@gmail.com>"\line
1024-bit DSA key, ID F721C45A, created 2009-02-09\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags. The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content. To do this, you can figure out which key you want by running {\f1 gpg --list-keys}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ gpg --list-keys\line
/Users/schacon/.gnupg/pubring.gpg\line
---------------------------------\line
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]\line
uid                  Scott Chacon <schacon@gmail.com>\line
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can directly import the key into the Git database by exporting it and piping that through {\f1 git hash-object}, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ gpg -a --export F721C45A | git hash-object -w --stdin\line
659ef797d181633c87ec71ac3f9ba29fe5775b92\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the {\f1 hash-object} command gave you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run {\f1 git push --tags}, the {\f1 maintainer-pgp-pub} tag will be shared with everyone. If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show maintainer-pgp-pub | gpg --import\par}
{\pard \ql \f0 \sa180 \li0 \fi0 They can use that key to verify all your signed tags. Also, if you include instructions in the tag message, running {\f1 git show <tag>} will let you give the end user more specific instructions about tag verification.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Generating a Build Number\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because Git doesn\u8217't have monotonically increasing numbers like \u8216'v123\u8217' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run {\f1 git describe} on that commit. Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you\u8217're describing:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git describe master\line
v1.6.2-rc1-20-g8c5b85c\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, you can export a snapshot or build and name it something understandable to people. In fact, if you build Git from source code cloned from the Git repository, {\f1 git --version} gives you something that looks like this. If you\u8217're describing a commit that you have directly tagged, it gives you the tag name.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 git describe} command favors annotated tags (tags created with the {\f1 -a} or {\f1 -s} flag), so release tags should be created this way if you\u8217're using {\f1 git describe}, to ensure the commit is named properly when described. You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever. For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older {\f1 git describe} output names were invalidated.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Preparing a Release\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you want to release a build. One of the things you\u8217'll want to do is create an archive of the latest snapshot of your code for those poor souls who don\u8217't use Git. The command to do this is {\f1 git archive}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz\line
$ ls *.tar.gz\line
v1.6.2-rc1-20-g8c5b85c.tar.gz\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If someone opens that tarball, they get the latest snapshot of your project under a project directory. You can also create a zip archive in much the same way, but by passing the {\f1 --format=zip} option to {\f1 git archive}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git archive master --prefix='project/' --format=zip > `git describe master`.zip\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Shortlog\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's time to e-mail your mailing list of people who want to know what\u8217's happening in your project. A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the {\f1 git shortlog} command. It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git shortlog --no-merges master --not v1.0.1\line
Chris Wanstrath (8):\line
      Add support for annotated tags to Grit::Tag\line
      Add packed-refs annotated tag support.\line
      Add Grit::Commit#to_patch\line
      Update version and History.txt\line
      Remove stray `puts`\line
      Make ls_tree ignore nils\line
\line
Tom Preston-Werner (4):\line
      fix dates in history\line
      dynamic version method\line
      Version bump to 1.0.2\line
      Regenerated gemspec for version 1.0.2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users\u8217' contributions. Congratulations on being an effective Git developer! In the next chapter, you\u8217'll learn more powerful tools and tips for dealing with complex situations, which will truly make you a Git master.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git Tools\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By now, you\u8217've learned most of the day-to-day commands and workflows that you need to manage or maintain a Git repository for your source code control. You\u8217've accomplished the basic tasks of tracking and committing files, and you\u8217've harnessed the power of the staging area and lightweight topic branching and merging.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217'll explore a number of very powerful things that Git can do that you may not necessarily use on a day-to-day basis but that you may need at some point.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Revision Selection\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git allows you to specify specific commits or a range of commits in several ways. They aren\u8217't necessarily obvious but are helpful to know.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Single Revisions\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can obviously refer to a commit by the SHA-1 hash that it\u8217's given, but there are more human-friendly ways to refer to commits as well. This section outlines the various ways you can refer to a single commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Short SHA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git is smart enough to figure out what commit you meant to type if you provide the first few characters, as long as your partial SHA-1 is at least four characters long and unambiguous \u8212- that is, only one object in the current repository begins with that partial SHA-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, to see a specific commit, suppose you run a {\f1 git log} command and identify the commit where you added certain functionality:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log\line
commit 734713bc047d87bf7eac9674765ae793478c50d3\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri Jan 2 18:32:33 2009 -0800\line
\line
    fixed refs handling, added gc auto, updated tests\line
\line
commit d921970aadf03b3cf0e71becdaab3147ba71cdef\line
Merge: 1c002dd... 35cfb2b...\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Dec 11 15:08:43 2008 -0800\line
\line
    Merge commit 'phedders/rdocs'\line
\line
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Dec 11 14:58:32 2008 -0800\line
\line
    added some blame and merge stuff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, choose {\f1 1c002dd....} If you {\f1 git show} that commit, the following commands are equivalent (assuming the shorter versions are unambiguous):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\line
$ git show 1c002dd4b536e7479f\line
$ git show 1c002d\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git can figure out a short, unique abbreviation for your SHA-1 values. If you pass {\f1 --abbrev-commit} to the {\f1 git log} command, the output will use shorter values but keep them unique; it defaults to using seven characters but makes them longer if necessary to keep the SHA-1 unambiguous:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --abbrev-commit --pretty=oneline\line
ca82a6d changed the version number\line
085bb3b removed unnecessary test code\line
a11bef0 first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Generally, eight to ten characters are more than enough to be unique within a project. One of the largest Git projects, the Linux kernel, is beginning to need 12 characters out of the possible 40 to stay unique.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 A SHORT NOTE ABOUT SHA-1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A lot of people become concerned at some point that they will, by random happenstance, have two objects in their repository that hash to the same SHA-1 value. What then?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you do happen to commit an object that hashes to the same SHA-1 value as a previous object in your repository, Git will see the previous object already in your Git database and assume it was already written. If you try to check out that object again at some point, you\u8217'll always get the data of the first object.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, you should be aware of how ridiculously unlikely this scenario is. The SHA-1 digest is 20 bytes or 160 bits. The number of randomly hashed objects needed to ensure a 50% probability of a single collision is about 2^80 (the formula for determining collision probability is {\f1 p = (n(n-1)/2) * (1/2^160))}. 2^80 is 1.2 x 10^24 or 1 million billion billion. That\u8217's 1,200 times the number of grains of sand on the earth.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here\u8217's an example to give you an idea of what it would take to get a SHA-1 collision. If all 6.5 billion humans on Earth were programming, and every second, each one was producing code that was the equivalent of the entire Linux kernel history (1 million Git objects) and pushing it into one enormous Git repository, it would take 5 years until that repository contained enough objects to have a 50% probability of a single SHA-1 object collision. A higher probability exists that every member of your programming team will be attacked and killed by wolves in unrelated incidents on the same night.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Branch References\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The most straightforward way to specify a commit requires that it have a branch reference pointed at it. Then, you can use a branch name in any Git command that expects a commit object or SHA-1 value. For instance, if you want to show the last commit object on a branch, the following commands are equivalent, assuming that the {\f1 topic1} branch points to {\f1 ca82a6d}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show ca82a6dff817ec66f44342007202690a93763949\line
$ git show topic1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to see which specific SHA a branch points to, or if you want to see what any of these examples boils down to in terms of SHAs, you can use a Git plumbing tool called {\f1 rev-parse}. You can see Chapter 9 for more information about plumbing tools; basically, {\f1 rev-parse} exists for lower-level operations and isn\u8217't designed to be used in day-to-day operations. However, it can be helpful sometimes when you need to see what\u8217's really going on. Here you can run {\f1 rev-parse} on your branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rev-parse topic1\line
ca82a6dff817ec66f44342007202690a93763949\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 RefLog Shortnames\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the things Git does in the background while you\u8217're working away is keep a reflog \u8212- a log of where your HEAD and branch references have been for the last few months.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see your reflog by using {\f1 git reflog}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git reflog\line
734713b... HEAD@\{0\}: commit: fixed refs handling, added gc auto, updated\line
d921970... HEAD@\{1\}: merge phedders/rdocs: Merge made by recursive.\line
1c002dd... HEAD@\{2\}: commit: added some blame and merge stuff\line
1c36188... HEAD@\{3\}: rebase -i (squash): updating HEAD\line
95df984... HEAD@\{4\}: commit: # This is a combination of two commits.\line
1c36188... HEAD@\{5\}: rebase -i (squash): updating HEAD\line
7e05da5... HEAD@\{6\}: rebase -i (pick): updating HEAD\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history. And you can specify older commits with this data, as well. If you want to see the fifth prior value of the HEAD of your repository, you can use the {\f1 @\{n\}} reference that you see in the reflog output:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show HEAD@\{5\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also use this syntax to see where a branch was some specific amount of time ago. For instance, to see where your {\f1 master} branch was yesterday, you can type\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show master@\{yesterday\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That shows you where the branch tip was yesterday. This technique only works for data that\u8217's still in your reflog, so you can\u8217't use it to look for commits older than a few months.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see reflog information formatted like the {\f1 git log} output, you can run {\f1 git log -g}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -g master\line
commit 734713bc047d87bf7eac9674765ae793478c50d3\line
Reflog: master@\{0\} (Scott Chacon <schacon@gmail.com>)\line
Reflog message: commit: fixed refs handling, added gc auto, updated\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri Jan 2 18:32:33 2009 -0800\line
\line
    fixed refs handling, added gc auto, updated tests\line
\line
commit d921970aadf03b3cf0e71becdaab3147ba71cdef\line
Reflog: master@\{1\} (Scott Chacon <schacon@gmail.com>)\line
Reflog message: merge phedders/rdocs: Merge made by recursive.\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Dec 11 15:08:43 2008 -0800\line
\line
    Merge commit 'phedders/rdocs'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that the reflog information is strictly local \u8212- it\u8217's a log of what you\u8217've done in your repository. The references won\u8217't be the same on someone else\u8217's copy of the repository; and right after you initially clone a repository, you\u8217'll have an empty reflog, as no activity has occurred yet in your repository. Running {\f1 git show HEAD@\{2.months.ago\}} will work only if you cloned the project at least two months ago \u8212- if you cloned it five minutes ago, you\u8217'll get no results.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ancestry References\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other main way to specify a commit is via its ancestry. If you place a {\f1 ^} at the end of a reference, Git resolves it to mean the parent of that commit. Suppose you look at the history of your project:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=format:'%h %s' --graph\line
* 734713b fixed refs handling, added gc auto, updated tests\line
*   d921970 Merge commit 'phedders/rdocs'\line
|\\\line
| * 35cfb2b Some rdoc changes\line
* | 1c002dd added some blame and merge stuff\line
|/\line
* 1c36188 ignore *.gem\line
* 9b29157 add open3_detach to gemspec file list\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can see the previous commit by specifying {\f1 HEAD^}, which means \u8220"the parent of HEAD\u8221":\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show HEAD^\line
commit d921970aadf03b3cf0e71becdaab3147ba71cdef\line
Merge: 1c002dd... 35cfb2b...\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Dec 11 15:08:43 2008 -0800\line
\line
    Merge commit 'phedders/rdocs'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also specify a number after the {\f1 ^} \u8212- for example, {\f1 d921970^2} means \u8220"the second parent of d921970.\u8221" This syntax is only useful for merge commits, which have more than one parent. The first parent is the branch you were on when you merged, and the second is the commit on the branch that you merged in:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show d921970^\line
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Dec 11 14:58:32 2008 -0800\line
\line
    added some blame and merge stuff\line
\line
$ git show d921970^2\line
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\line
Author: Paul Hedderly <paul+git@mjr.org>\line
Date:   Wed Dec 10 22:22:03 2008 +0000\line
\line
    Some rdoc changes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other main ancestry specification is the {\f1 ~}. This also refers to the first parent, so {\f1 HEAD~} and {\f1 HEAD^} are equivalent. The difference becomes apparent when you specify a number. {\f1 HEAD~2} means \u8220"the first parent of the first parent,\u8221" or \u8220"the grandparent\u8221" \u8212- it traverses the first parents the number of times you specify. For example, in the history listed earlier, {\f1 HEAD~3} would be\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show HEAD~3\line
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\line
Author: Tom Preston-Werner <tom@mojombo.com>\line
Date:   Fri Nov 7 13:47:59 2008 -0500\line
\line
    ignore *.gem\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This can also be written {\f1 HEAD^^^}, which again is the first parent of the first parent of the first parent:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show HEAD^^^\line
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\line
Author: Tom Preston-Werner <tom@mojombo.com>\line
Date:   Fri Nov 7 13:47:59 2008 -0500\line
\line
    ignore *.gem\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also combine these syntaxes \u8212- you can get the second parent of the previous reference (assuming it was a merge commit) by using {\f1 HEAD~3^2}, and so on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Commit Ranges\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you can specify individual commits, let\u8217's see how to specify ranges of commits. This is particularly useful for managing your branches \u8212- if you have a lot of branches, you can use range specifications to answer questions such as, \u8220"What work is on this branch that I haven\u8217't yet merged into my main branch?\u8221"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Double Dot\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The most common range specification is the double-dot syntax. This basically asks Git to resolve a range of commits that are reachable from one commit but aren\u8217't reachable from another. For example, say you have a commit history that looks like Figure 6-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0601.png Figure 6-1. Example history for range selection.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You want to see what is in your experiment branch that hasn\u8217't yet been merged into your master branch. You can ask Git to show you a log of just those commits with {\f1 master..experiment} \u8212- that means \u8220"all commits reachable by experiment that aren\u8217't reachable by master.\u8221" For the sake of brevity and clarity in these examples, I\u8217'll use the letters of the commit objects from the diagram in place of the actual log output in the order that they would display:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log master..experiment\line
D\line
C\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If, on the other hand, you want to see the opposite \u8212- all commits in {\f1 master} that aren\u8217't in {\f1 experiment} \u8212- you can reverse the branch names. {\f1 experiment..master} shows you everything in {\f1 master} not reachable from {\f1 experiment}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log experiment..master\line
F\line
E\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is useful if you want to keep the {\f1 experiment} branch up to date and preview what you\u8217're about to merge in. Another very frequent use of this syntax is to see what you\u8217're about to push to a remote:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log origin/master..HEAD\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command shows you any commits in your current branch that aren\u8217't in the {\f1 master} branch on your {\f1 origin} remote. If you run a {\f1 git push} and your current branch is tracking {\f1 origin/master}, the commits listed by {\f1 git log origin/master..HEAD} are the commits that will be transferred to the server. You can also leave off one side of the syntax to have Git assume HEAD. For example, you can get the same results as in the previous example by typing {\f1 git log origin/master..} \u8212- Git substitutes HEAD if one side is missing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Multiple Points\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The double-dot syntax is useful as a shorthand; but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren\u8217't in the branch you\u8217're currently on. Git allows you to do this by using either the {\f1 ^} character or {\f1 --not} before any reference from which you don\u8217't want to see reachable commits. Thus these three commands are equivalent:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log refA..refB\line
$ git log ^refA refB\line
$ git log refB --not refA\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax. For instance, if you want to see all commits that are reachable from {\f1 refA} or {\f1 refB} but not from {\f1 refC}, you can type one of these:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log refA refB ^refC\line
$ git log refA refB --not refC\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This makes for a very powerful revision query system that should help you figure out what is in your branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Triple Dot\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them. Look back at the example commit history in Figure 6-1. If you want to see what is in {\f1 master} or {\f1 experiment} but not any common references, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log master...experiment\line
F\line
E\line
D\line
C\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, this gives you normal {\f1 log} output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A common switch to use with the {\f1 log} command in this case is {\f1 --left-right}, which shows you which side of the range each commit is in. This helps make the data more useful:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --left-right master...experiment\line
< F\line
< E\line
> D\line
> C\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With these tools, you can much more easily let Git know what commit or commits you want to inspect.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Interactive Staging\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git comes with a couple of scripts that make some command-line tasks easier. Here, you\u8217'll look at a few interactive commands that can help you easily craft your commits to include only certain combinations and parts of files. These tools are very helpful if you modify a bunch of files and then decide that you want those changes to be in several focused commits rather than one big messy commit. This way, you can make sure your commits are logically separate changesets and can be easily reviewed by the developers working with you. If you run {\f1 git add} with the {\f1 -i} or {\f1 --interactive} option, Git goes into an interactive shell mode, displaying something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add -i\line
           staged     unstaged path\line
  1:    unchanged        +0/-1 TODO\line
  2:    unchanged        +1/-1 index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\line
\line
*** Commands ***\line
  1: status     2: update      3: revert     4: add untracked\line
  5: patch      6: diff        7: quit       8: help\line
What now>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that this command shows you a much different view of your staging area \u8212- basically the same information you get with {\f1 git status} but a bit more succinct and informative. It lists the changes you\u8217've staged on the left and unstaged changes on the right.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After this comes a Commands section. Here you can do a number of things, including staging files, unstaging files, staging parts of files, adding untracked files, and seeing diffs of what has been staged.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Staging and Unstaging Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you type {\f1 2} or {\f1 u} at the {\f1 What now>} prompt, the script prompts you for which files you want to stage:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 What now> 2\line
           staged     unstaged path\line
  1:    unchanged        +0/-1 TODO\line
  2:    unchanged        +1/-1 index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\line
Update>>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To stage the TODO and index.html files, you can type the numbers:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Update>> 1,2\line
           staged     unstaged path\line
* 1:    unchanged        +0/-1 TODO\line
* 2:    unchanged        +1/-1 index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\line
Update>>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 *} next to each file means the file is selected to be staged. If you press Enter after typing nothing at the {\f1 Update>>} prompt, Git takes anything selected and stages it for you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Update>>\line
updated 2 paths\line
\line
*** Commands ***\line
  1: status     2: update      3: revert     4: add untracked\line
  5: patch      6: diff        7: quit       8: help\line
What now> 1\line
           staged     unstaged path\line
  1:        +0/-1      nothing TODO\line
  2:        +1/-1      nothing index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can see that the TODO and index.html files are staged and the simplegit.rb file is still unstaged. If you want to unstage the TODO file at this point, you use the {\f1 3} or {\f1 r} (for revert) option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *** Commands ***\line
  1: status     2: update      3: revert     4: add untracked\line
  5: patch      6: diff        7: quit       8: help\line
What now> 3\line
           staged     unstaged path\line
  1:        +0/-1      nothing TODO\line
  2:        +1/-1      nothing index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\line
Revert>> 1\line
           staged     unstaged path\line
* 1:        +0/-1      nothing TODO\line
  2:        +1/-1      nothing index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\line
Revert>> [enter]\line
reverted one path\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Looking at your Git status again, you can see that you\u8217've unstaged the TODO file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *** Commands ***\line
  1: status     2: update      3: revert     4: add untracked\line
  5: patch      6: diff        7: quit       8: help\line
What now> 1\line
           staged     unstaged path\line
  1:    unchanged        +0/-1 TODO\line
  2:        +1/-1      nothing index.html\line
  3:    unchanged        +5/-1 lib/simplegit.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To see the diff of what you\u8217've staged, you can use the {\f1 6} or {\f1 d} (for diff) command. It shows you a list of your staged files, and you can select the ones for which you would like to see the staged diff. This is much like specifying {\f1 git diff --cached} on the command line:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *** Commands ***\line
  1: status     2: update      3: revert     4: add untracked\line
  5: patch      6: diff        7: quit       8: help\line
What now> 6\line
           staged     unstaged path\line
  1:        +1/-1      nothing index.html\line
Review diff>> 1\line
diff --git a/index.html b/index.html\line
index 4d07108..4335f49 100644\line
--- a/index.html\line
+++ b/index.html\line
@@ -16,7 +16,7 @@ Date Finder\line
\line
 <p id="out">...</p>\line
\line
-<div id="footer">contact : support@github.com</div>\line
+<div id="footer">contact : email.support@github.com</div>\line
\line
 <script type="text/javascript">\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With these basic commands, you can use the interactive add mode to deal with your staging area a little more easily.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Staging Patches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's also possible for Git to stage certain parts of files and not the rest. For example, if you make two changes to your simplegit.rb file and want to stage one of them and not the other, doing so is very easy in Git. From the interactive prompt, type {\f1 5} or {\f1 p} (for patch). Git will ask you which files you would like to partially stage; then, for each section of the selected files, it will display hunks of the file diff and ask if you would like to stage them, one by one:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 diff --git a/lib/simplegit.rb b/lib/simplegit.rb\line
index dd5ecc4..57399e0 100644\line
--- a/lib/simplegit.rb\line
+++ b/lib/simplegit.rb\line
@@ -22,7 +22,7 @@ class SimpleGit\line
   end\line
\line
   def log(treeish = 'master')\line
-    command("git log -n 25 #\{treeish\}")\line
+    command("git log -n 30 #\{treeish\}")\line
   end\line
\line
   def blame(path)\line
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have a lot of options at this point. Typing {\f1 ?} shows a list of what you can do:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\line
y - stage this hunk\line
n - do not stage this hunk\line
a - stage this and all the remaining hunks in the file\line
d - do not stage this hunk nor any of the remaining hunks in the file\line
g - select a hunk to go to\line
/ - search for a hunk matching the given regex\line
j - leave this hunk undecided, see next undecided hunk\line
J - leave this hunk undecided, see next hunk\line
k - leave this hunk undecided, see previous undecided hunk\line
K - leave this hunk undecided, see previous hunk\line
s - split the current hunk into smaller hunks\line
e - manually edit the current hunk\line
? - print help\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Generally, you\u8217'll type {\f1 y} or {\f1 n} if you want to stage each hunk, but staging all of them in certain files or skipping a hunk decision until later can be helpful too. If you stage one part of the file and leave another part unstaged, your status output will look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 What now> 1\line
           staged     unstaged path\line
  1:    unchanged        +0/-1 TODO\line
  2:        +1/-1      nothing index.html\line
  3:        +1/-1        +4/-0 lib/simplegit.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The status of the simplegit.rb file is interesting. It shows you that a couple of lines are staged and a couple are unstaged. You\u8217've partially staged this file. At this point, you can exit the interactive adding script and run {\f1 git commit} to commit the partially staged files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, you don\u8217't need to be in interactive add mode to do the partial-file staging \u8212- you can start the same script by using {\f1 git add -p} or {\f1 git add --patch} on the command line.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Stashing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Often, when you\u8217've been working on part of your project, things are in a messy state and you want to switch branches for a bit to work on something else. The problem is, you don\u8217't want to do a commit of half-done work just so you can get back to this point later. The answer to this issue is the {\f1 git stash} command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Stashing takes the dirty state of your working directory \u8212- that is, your modified tracked files and staged changes \u8212- and saves it on a stack of unfinished changes that you can reapply at any time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Stashing Your Work\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To demonstrate, you\u8217'll go into your project and start working on a couple of files and possibly stage one of the changes. If you run {\f1 git status}, you can see your dirty state:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#      modified:   index.html\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#      modified:   lib/simplegit.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you want to switch branches, but you don\u8217't want to commit what you\u8217've been working on yet; so you\u8217'll stash the changes. To push a new stash onto your stack, run {\f1 git stash}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash\line
Saved working directory and index state \\\line
  "WIP on master: 049d078 added the index file"\line
HEAD is now at 049d078 added the index file\line
(To restore them type "git stash apply")\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your working directory is clean:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
nothing to commit (working directory clean)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you can easily switch branches and do work elsewhere; your changes are stored on your stack. To see which stashes you\u8217've stored, you can use {\f1 git stash list}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash list\line
stash@\{0\}: WIP on master: 049d078 added the index file\line
stash@\{1\}: WIP on master: c264051... Revert "added file_size"\line
stash@\{2\}: WIP on master: 21d80a5... added number to log\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, two stashes were done previously, so you have access to three different stashed works. You can reapply the one you just stashed by using the command shown in the help output of the original stash command: {\f1 git stash apply}. If you want to apply one of the older stashes, you can specify it by naming it, like this: {\f1 git stash apply stash@\{2\}}. If you don\u8217't specify a stash, Git assumes the most recent stash and tries to apply it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash apply\line
# On branch master\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#      modified:   index.html\line
#      modified:   lib/simplegit.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see that Git re-modifies the files you uncommitted when you saved the stash. In this case, you had a clean working directory when you tried to apply the stash, and you tried to apply it on the same branch you saved it from; but having a clean working directory and applying it on the same branch aren\u8217't necessary to successfully apply a stash. You can save a stash on one branch, switch to another branch later, and try to reapply the changes. You can also have modified and uncommitted files in your working directory when you apply a stash \u8212- Git gives you merge conflicts if anything no longer applies cleanly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The changes to your files were reapplied, but the file you staged before wasn\u8217't restaged. To do that, you must run the {\f1 git stash apply} command with a {\f1 --index} option to tell the command to try to reapply the staged changes. If you had run that instead, you\u8217'd have gotten back to your original position:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash apply --index\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#      modified:   index.html\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#      modified:   lib/simplegit.rb\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The apply option only tries to apply the stashed work \u8212- you continue to have it on your stack. To remove it, you can run {\f1 git stash drop} with the name of the stash to remove:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash list\line
stash@\{0\}: WIP on master: 049d078 added the index file\line
stash@\{1\}: WIP on master: c264051... Revert "added file_size"\line
stash@\{2\}: WIP on master: 21d80a5... added number to log\line
$ git stash drop stash@\{0\}\line
Dropped stash@\{0\} (364e91f3f268f0900bc3ee613f9f733e82aaed43)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also run {\f1 git stash pop} to apply the stash and then immediately drop it from your stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Un-applying a Stash\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In some use case scenarios you might want to apply stashed changes, do some work, but then un-apply those changes that originally came from the stash. Git does not provide such a {\f1 stash unapply} command, but it is possible to achieve the effect by simply retrieving the patch associated with a stash and applying it in reverse:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash show -p stash@\{0\} | git apply -R\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, if you don\u8217't specify a stash, Git assumes the most recent stash:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash show -p | git apply -R\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may want to create an alias and effectively add a {\f1 stash-unapply} command to your git. For example:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global alias.stash-unapply '!git stash show -p | git apply -R'\line
$ git stash\line
$ #... work work work\line
$ git stash-unapply\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Creating a Branch from a Stash\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work. If the apply tries to modify a file that you\u8217've since modified, you\u8217'll get a merge conflict and will have to try to resolve it. If you want an easier way to test the stashed changes again, you can run {\f1 git stash branch}, which creates a new branch for you, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git stash branch testchanges\line
Switched to a new branch "testchanges"\line
# On branch testchanges\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#      modified:   index.html\line
#\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#\line
#      modified:   lib/simplegit.rb\line
#\line
Dropped refs/stash@\{0\} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a nice shortcut to recover stashed work easily and work on it in a new branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Rewriting History\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many times, when working with Git, you may want to revise your commit history for some reason. One of the great things about Git is that it allows you to make decisions at the last possible moment. You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn\u8217't mean to be working on something yet with the stash command, and you can rewrite commits that already happened so they look like they happened in a different way. This can involve changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely \u8212- all before you share your work with others.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this section, you\u8217'll cover how to accomplish these very useful tasks so that you can make your commit history look the way you want before you share it with others.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Changing the Last Commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Changing your last commit is probably the most common rewriting of history that you\u8217'll do. You\u8217'll often want to do two basic things to your last commit: change the commit message, or change the snapshot you just recorded by adding, changing and removing files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you only want to modify your last commit message, it\u8217's very simple:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit --amend\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That drops you into your text editor, which has your last commit message in it, ready for you to modify the message. When you save and close the editor, the editor writes a new commit containing that message and makes it your new last commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217've committed and then you want to change the snapshot you committed by adding or changing files, possibly because you forgot to add a newly created file when you originally committed, the process works basically the same way. You stage the changes you want by editing a file and running {\f1 git add} on it or {\f1 git rm} to a tracked file, and the subsequent {\f1 git commit --amend} takes your current staging area and makes it the snapshot for the new commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You need to be careful with this technique because amending changes the SHA-1 of the commit. It\u8217's like a very small rebase \u8212- don\u8217't amend your last commit if you\u8217've already pushed it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Changing Multiple Commit Messages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To modify a commit that is farther back in your history, you must move to more complex tools. Git doesn\u8217't have a modify-history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD they were originally based on instead of moving them to another one. With the interactive rebase tool, you can then stop after each commit you want to modify and change the message, add files, or do whatever you wish. You can run rebase interactively by adding the {\f1 -i} option to {\f1 git rebase}. You must indicate how far back you want to rewrite commits by telling the command which commit to rebase onto.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, if you want to change the last three commit messages, or any of the commit messages in that group, you supply as an argument to {\f1 git rebase -i} the parent of the last commit you want to edit, which is {\f1 HEAD~2^} or {\f1 HEAD~3}. It may be easier to remember the {\f1 ~3} because you\u8217're trying to edit the last three commits; but keep in mind that you\u8217're actually designating four commits ago, the parent of the last commit you want to edit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rebase -i HEAD~3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember again that this is a rebasing command \u8212- every commit included in the range {\f1 HEAD~3..HEAD} will be rewritten, whether you change the message or not. Don\u8217't include any commit you\u8217've already pushed to a central server \u8212- doing so will confuse other developers by providing an alternate version of the same change.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Running this command gives you a list of commits in your text editor that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 pick f7f3f6d changed my name a bit\line
pick 310154e updated README formatting and added blame\line
pick a5f4a0d added cat-file\line
\line
# Rebase 710f0f8..a5f4a0d onto 710f0f8\line
#\line
# Commands:\line
#  p, pick = use commit\line
#  e, edit = use commit, but stop for amending\line
#  s, squash = use commit, but meld into previous commit\line
#\line
# If you remove a line here THAT COMMIT WILL BE LOST.\line
# However, if you remove everything, the rebase will be aborted.\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that these commits are listed in the opposite order than you normally see them using the {\f1 log} command. If you run a {\f1 log}, you see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=format:"%h %s" HEAD~3..HEAD\line
a5f4a0d added cat-file\line
310154e updated README formatting and added blame\line
f7f3f6d changed my name a bit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice the reverse order. The interactive rebase gives you a script that it\u8217's going to run. It will start at the commit you specify on the command line ({\f1 HEAD~3}) and replay the changes introduced in each of these commits from top to bottom. It lists the oldest at the top, rather than the newest, because that\u8217's the first one it will replay.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You need to edit the script so that it stops at the commit you want to edit. To do so, change the word pick to the word edit for each of the commits you want the script to stop after. For example, to modify only the third commit message, you change the file to look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 edit f7f3f6d changed my name a bit\line
pick 310154e updated README formatting and added blame\line
pick a5f4a0d added cat-file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rebase -i HEAD~3\line
Stopped at 7482e0d... updated the gemspec to hopefully work better\line
You can amend the commit now, with\line
\line
       git commit --amend\line
\line
Once you\u8217're satisfied with your changes, run\line
\line
       git rebase --continue\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These instructions tell you exactly what to do. Type\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit --amend\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Change the commit message, and exit the editor. Then, run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rebase --continue\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command will apply the other two commits automatically, and then you\u8217're done. If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit. Each time, Git will stop, let you amend the commit, and continue when you\u8217're finished.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Reordering Commits\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also use interactive rebases to reorder or remove commits entirely. If you want to remove the \u8220"added cat-file\u8221" commit and change the order in which the other two commits are introduced, you can change the rebase script from this\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 pick f7f3f6d changed my name a bit\line
pick 310154e updated README formatting and added blame\line
pick a5f4a0d added cat-file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 to this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 pick 310154e updated README formatting and added blame\line
pick f7f3f6d changed my name a bit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies {\f1 310154e} and then {\f1 f7f3f6d}, and then stops. You effectively change the order of those commits and remove the \u8220"added cat-file\u8221" commit completely.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Squashing Commits\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool. The script puts helpful instructions in the rebase message:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #\line
# Commands:\line
#  p, pick = use commit\line
#  e, edit = use commit, but stop for amending\line
#  s, squash = use commit, but meld into previous commit\line
#\line
# If you remove a line here THAT COMMIT WILL BE LOST.\line
# However, if you remove everything, the rebase will be aborted.\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If, instead of \u8220"pick\u8221" or \u8220"edit\u8221", you specify \u8220"squash\u8221", Git applies both that change and the change directly before it and makes you merge the commit messages together. So, if you want to make a single commit from these three commits, you make the script look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 pick f7f3f6d changed my name a bit\line
squash 310154e updated README formatting and added blame\line
squash a5f4a0d added cat-file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # This is a combination of 3 commits.\line
# The first commit's message is:\line
changed my name a bit\line
\line
# This is the 2nd commit message:\line
\line
updated README formatting and added blame\line
\line
# This is the 3rd commit message:\line
\line
added cat-file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you save that, you have a single commit that introduces the changes of all three previous commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Splitting a Commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with. For example, suppose you want to split the middle commit of your three commits. Instead of \u8220"updated README formatting and added blame\u8221", you want to split it into two commits: \u8220"updated README formatting\u8221" for the first, and \u8220"added blame\u8221" for the second. You can do that in the {\f1 rebase -i} script by changing the instruction on the commit you want to split to \u8220"edit\u8221":\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 pick f7f3f6d changed my name a bit\line
edit 310154e updated README formatting and added blame\line
pick a5f4a0d added cat-file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them. When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit ({\f1 f7f3f6d}), applies the second ({\f1 310154e}), and drops you to the console. There, you can do a mixed reset of that commit with {\f1 git reset HEAD^}, which effectively undoes that commit and leaves the modified files unstaged. Now you can stage and commit files until you have several commits, and run {\f1 git rebase --continue} when you\u8217're done:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git reset HEAD^\line
$ git add README\line
$ git commit -m 'updated README formatting'\line
$ git add lib/simplegit.rb\line
$ git commit -m 'added blame'\line
$ git rebase --continue\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git applies the last commit ({\f1 a5f4a0d}) in the script, and your history looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -4 --pretty=format:"%h %s"\line
1c002dd added cat-file\line
9b29157 added blame\line
35cfb2b updated README formatting\line
f3cc40e changed my name a bit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Once again, this changes the SHAs of all the commits in your list, so make sure no commit shows up in that list that you\u8217've already pushed to a shared repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Nuclear Option: filter-branch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way \u8212- for instance, changing your e-mail address globally or removing a file from every commit. The command is {\f1 filter-branch}, and it can rewrite huge swaths of your history, so you probably shouldn\u8217't use it unless your project isn\u8217't yet public and other people haven\u8217't based work off the commits you\u8217're about to rewrite. However, it can be very useful. You\u8217'll learn a few of the common uses so you can get an idea of some of the things it\u8217's capable of.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Removing a File from Every Commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This occurs fairly commonly. Someone accidentally commits a huge binary file with a thoughtless {\f1 git add .}, and you want to remove it everywhere. Perhaps you accidentally committed a file that contained a password, and you want to make your project open source. {\f1 filter-branch} is the tool you probably want to use to scrub your entire history. To remove a file named passwords.txt from your entire history, you can use the {\f1 --tree-filter} option to {\f1 filter-branch}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\line
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\line
Ref 'refs/heads/master' was rewritten\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 --tree-filter} option runs the specified command after each checkout of the project and then recommits the results. In this case, you remove a file called passwords.txt from every snapshot, whether it exists or not. If you want to remove all accidentally committed editor backup files, you can run something like {\f1 git filter-branch --tree-filter "rm -f *~" HEAD}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll be able to watch Git rewriting trees and commits and then move the branch pointer at the end. It\u8217's generally a good idea to do this in a testing branch and then hard-reset your master branch after you\u8217've determined the outcome is what you really want. To run {\f1 filter-branch} on all your branches, you can pass {\f1 --all} to the command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Making a Subdirectory the New Root\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you\u8217've done an import from another source control system and have subdirectories that make no sense (trunk, tags, and so on). If you want to make the {\f1 trunk} subdirectory be the new project root for every commit, {\f1 filter-branch} can help you do that, too:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git filter-branch --subdirectory-filter trunk HEAD\line
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\line
Ref 'refs/heads/master' was rewritten\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now your new project root is what was in the {\f1 trunk} subdirectory each time. Git will also automatically remove commits that did not affect the subdirectory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Changing E-Mail Addresses Globally\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another common case is that you forgot to run {\f1 git config} to set your name and e-mail address before you started working, or perhaps you want to open-source a project at work and change all your work e-mail addresses to your personal address. In any case, you can change e-mail addresses in multiple commits in a batch with {\f1 filter-branch} as well. You need to be careful to change only the e-mail addresses that are yours, so you use {\f1 --commit-filter}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git filter-branch --commit-filter '\line
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];\line
        then\line
                GIT_AUTHOR_NAME="Scott Chacon";\line
                GIT_AUTHOR_EMAIL="schacon@example.com";\line
                git commit-tree "$@";\line
        else\line
                git commit-tree "$@";\line
        fi' HEAD\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This goes through and rewrites every commit to have your new address. Because commits contain the SHA-1 values of their parents, this command changes every commit SHA in your history, not just those that have the matching e-mail address.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Debugging with Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git also provides a couple of tools to help you debug issues in your projects. Because Git is designed to work with nearly any type of project, these tools are pretty generic, but they can often help you hunt for a bug or culprit when things go wrong.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 File Annotation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you track down a bug in your code and want to know when it was introduced and why, file annotation is often your best tool. It shows you what commit was the last to modify each line of any file. So, if you see that a method in your code is buggy, you can annotate the file with {\f1 git blame} to see when each line of the method was last edited and by whom. This example uses the {\f1 -L} option to limit the output to lines 12 through 22:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git blame -L 12,22 simplegit.rb\line
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')\line
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #\{tree\}")\line
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end\line
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)\line
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')\line
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #\{tree\}")\line
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end\line
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)\line
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)\line
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #\{path\}")\line
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that the first field is the partial SHA-1 of the commit that last modified that line. The next two fields are values extracted from that commit\u8212-the author name and the authored date of that commit \u8212- so you can easily see who modified that line and when. After that come the line number and the content of the file. Also note the {\f1 ^4832fe2} commit lines, which designate that those lines were in this file\u8217's original commit. That commit is when this file was first added to this project, and those lines have been unchanged since. This is a tad confusing, because now you\u8217've seen at least three different ways that Git uses the {\f1 ^} to modify a commit SHA, but that is what it means here.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another cool thing about Git is that it doesn\u8217't track file renames explicitly. It records the snapshots and then tries to figure out what was renamed implicitly, after the fact. One of the interesting features of this is that you can ask it to figure out all sorts of code movement as well. If you pass {\f1 -C} to {\f1 git blame}, Git analyzes the file you\u8217're annotating and tries to figure out where snippets of code within it originally came from if they were copied from elsewhere. Recently, I was refactoring a file named {\f1 GITServerHandler.m} into multiple files, one of which was {\f1 GITPackUpload.m}. By blaming {\f1 GITPackUpload.m} with the {\f1 -C} option, I could see where sections of the code originally came from:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git blame -C -L 141,153 GITPackUpload.m\line
f344f58d GITServerHandler.m (Scott 2009-01-04 141)\line
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC\line
f344f58d GITServerHandler.m (Scott 2009-01-04 143) \{\line
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI\line
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)\line
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) \{\line
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb\line
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is really useful. Normally, you get as the original commit the commit where you copied the code over, because that is the first time you touched those lines in this file. Git tells you the original commit where you wrote those lines, even if it was in another file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Binary Search\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Annotating a file helps if you know where the issue is to begin with. If you don\u8217't know what is breaking, and there have been dozens or hundreds of commits since the last state where you know the code worked, you\u8217'll likely turn to {\f1 git bisect} for help. The {\f1 bisect} command does a binary search through your commit history to help you identify as quickly as possible which commit introduced an issue.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's say you just pushed out a release of your code to a production environment, you\u8217're getting bug reports about something that wasn\u8217't happening in your development environment, and you can\u8217't imagine why the code is doing that. You go back to your code, and it turns out you can reproduce the issue, but you can\u8217't figure out what is going wrong. You can bisect the code to find out. First you run {\f1 git bisect start} to get things going, and then you use {\f1 git bisect bad} to tell the system that the current commit you\u8217're on is broken. Then, you must tell bisect when the last known good state was, using {\f1 git bisect good [good_commit]}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect start\line
$ git bisect bad\line
$ git bisect good v1.0\line
Bisecting: 6 revisions left to test after this\line
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git figured out that about 12 commits came between the commit you marked as the last good commit (v1.0) and the current bad version, and it checked out the middle one for you. At this point, you can run your test to see if the issue exists as of this commit. If it does, then it was introduced sometime before this middle commit; if it doesn\u8217't, then the problem was introduced sometime after the middle commit. It turns out there is no issue here, and you tell Git that by typing {\f1 git bisect good} and continue your journey:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect good\line
Bisecting: 3 revisions left to test after this\line
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217're on another commit, halfway between the one you just tested and your bad commit. You run your test again and find that this commit is broken, so you tell Git that with {\f1 git bisect bad}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect bad\line
Bisecting: 1 revisions left to test after this\line
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This commit is fine, and now Git has all the information it needs to determine where the issue was introduced. It tells you the SHA-1 of the first bad commit and show some of the commit information and which files were modified in that commit so you can figure out what happened that may have introduced this bug:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect good\line
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit\line
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04\line
Author: PJ Hyett <pjhyett@example.com>\line
Date:   Tue Jan 27 14:48:32 2009 -0800\line
\line
    secure this thing\line
\line
:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730\line
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you\u8217're finished, you should run {\f1 git bisect reset} to reset your HEAD to where you were before you started, or you\u8217'll end up in a weird state:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect reset\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a powerful tool that can help you check hundreds of commits for an introduced bug in minutes. In fact, if you have a script that will exit 0 if the project is good or non-0 if the project is bad, you can fully automate {\f1 git bisect}. First, you again tell it the scope of the bisect by providing the known bad and good commits. You can do this by listing them with the {\f1 bisect start} command if you want, listing the known bad commit first and the known good commit second:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git bisect start HEAD v1.0\line
$ git bisect run test-error.sh\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Doing so automatically runs {\f1 test-error.sh} on each checked-out commit until Git finds the first broken commit. You can also run something like {\f1 make} or {\f1 make tests} or whatever you have that runs automated tests for you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Submodules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It often happens that while working on one project, you need to use another project from within it. Perhaps it\u8217's a library that a third party developed or that you\u8217're developing separately and using in multiple parent projects. A common issue arises in these scenarios: you want to be able to treat the two projects as separate yet still be able to use one from within the other.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here\u8217's an example. Suppose you\u8217're developing a web site and creating Atom feeds. Instead of writing your own Atom-generating code, you decide to use a library. You\u8217're likely to have to either include this code from a shared library like a CPAN install or Ruby gem, or copy the source code into your own project tree. The issue with including the library is that it\u8217's difficult to customize the library in any way and often more difficult to deploy it, because you need to make sure every client has that library available. The issue with vendoring the code into your own project is that any custom changes you make are difficult to merge when upstream changes become available.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git addresses this issue using submodules. Submodules allow you to keep a Git repository as a subdirectory of another Git repository. This lets you clone another repository into your project and keep your commits separate.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Starting with Submodules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you want to add the Rack library (a Ruby web server gateway interface) to your project, possibly maintain your own changes to it, but continue to merge in upstream changes. The first thing you should do is clone the external repository into your subdirectory. You add external projects as submodules with the {\f1 git submodule add} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git submodule add git://github.com/chneukirchen/rack.git rack\line
Initialized empty Git repository in /opt/subtest/rack/.git/\line
remote: Counting objects: 3181, done.\line
remote: Compressing objects: 100% (1534/1534), done.\line
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)\line
Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.\line
Resolving deltas: 100% (1951/1951), done.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have the Rack project under a subdirectory named {\f1 rack} within your project. You can go into that subdirectory, make changes, add your own writable remote repository to push your changes into, fetch and merge from the original repository, and more. If you run {\f1 git status} right after you add the submodule, you see two things:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git status\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
#      new file:   .gitmodules\line
#      new file:   rack\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First you notice the {\f1 .gitmodules} file. This is a configuration file that stores the mapping between the project\u8217's URL and the local subdirectory you\u8217've pulled it into:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .gitmodules\line
[submodule "rack"]\line
      path = rack\line
      url = git://github.com/chneukirchen/rack.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have multiple submodules, you\u8217'll have multiple entries in this file. It\u8217's important to note that this file is version-controlled with your other files, like your {\f1 .gitignore} file. It\u8217's pushed and pulled with the rest of your project. This is how other people who clone this project know where to get the submodule projects from.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other listing in the {\f1 git status} output is the rack entry. If you run {\f1 git diff} on that, you see something interesting:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff --cached rack\line
diff --git a/rack b/rack\line
new file mode 160000\line
index 0000000..08d709f\line
--- /dev/null\line
+++ b/rack\line
@@ -0,0 +1 @@\line
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although {\f1 rack} is a subdirectory in your working directory, Git sees it as a submodule and doesn\u8217't track its contents when you\u8217're not in that directory. Instead, Git records it as a particular commit from that repository. When you make changes and commit in that subdirectory, the superproject notices that the HEAD there has changed and records the exact commit you\u8217're currently working off of; that way, when others clone this project, they can re-create the environment exactly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is an important point with submodules: you record them as the exact commit they\u8217're at. You can\u8217't record a submodule at {\f1 master} or some other symbolic reference.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you commit, you see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -m 'first commit with submodule rack'\line
[master 0550271] first commit with submodule rack\line
 2 files changed, 4 insertions(+), 0 deletions(-)\line
 create mode 100644 .gitmodules\line
 create mode 160000 rack\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice the 160000 mode for the rack entry. That is a special mode in Git that basically means you\u8217're recording a commit as a directory entry rather than a subdirectory or a file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can treat the {\f1 rack} directory as a separate project and then update your superproject from time to time with a pointer to the latest commit in that subproject. All the Git commands work independently in the two directories:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -1\line
commit 0550271328a0038865aad6331e620cd7238601bb\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Apr 9 09:03:56 2009 -0700\line
\line
    first commit with submodule rack\line
$ cd rack/\line
$ git log -1\line
commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433\line
Author: Christian Neukirchen <chneukirchen@gmail.com>\line
Date:   Wed Mar 25 14:49:04 2009 +0100\line
\line
    Document version change\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Cloning a Project with Submodules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here you\u8217'll clone a project with a submodule in it. When you receive such a project, you get the directories that contain submodules, but none of the files yet:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://github.com/schacon/myproject.git\line
Initialized empty Git repository in /opt/myproject/.git/\line
remote: Counting objects: 6, done.\line
remote: Compressing objects: 100% (4/4), done.\line
remote: Total 6 (delta 0), reused 0 (delta 0)\line
Receiving objects: 100% (6/6), done.\line
$ cd myproject\line
$ ls -l\line
total 8\line
-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README\line
drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack\line
$ ls rack/\line
$\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 rack} directory is there, but empty. You must run two commands: {\f1 git submodule init} to initialize your local configuration file, and {\f1 git submodule update} to fetch all the data from that project and check out the appropriate commit listed in your superproject:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git submodule init\line
Submodule 'rack' (git://github.com/chneukirchen/rack.git) registered for path 'rack'\line
$ git submodule update\line
Initialized empty Git repository in /opt/myproject/rack/.git/\line
remote: Counting objects: 3181, done.\line
remote: Compressing objects: 100% (1534/1534), done.\line
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)\line
Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.\line
Resolving deltas: 100% (1951/1951), done.\line
Submodule path 'rack': checked out '08d709f78b8c5b0fbeb7821e37fa53e69afcf433'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now your {\f1 rack} subdirectory is at the exact state it was in when you committed earlier. If another developer makes changes to the rack code and commits, and you pull that reference down and merge it in, you get something a bit odd:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge origin/master\line
Updating 0550271..85a3eee\line
Fast forward\line
 rack |    2 +-\line
 1 files changed, 1 insertions(+), 1 deletions(-)\line
[master*]$ git status\line
# On branch master\line
# Changes not staged for commit:\line
#   (use "git add <file>..." to update what will be committed)\line
#   (use "git checkout -- <file>..." to discard changes in working directory)\line
#\line
#      modified:   rack\line
#\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You merged in what is basically a change to the pointer for your submodule; but it doesn\u8217't update the code in the submodule directory, so it looks like you have a dirty state in your working directory:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff\line
diff --git a/rack b/rack\line
index 6c5e70b..08d709f 160000\line
--- a/rack\line
+++ b/rack\line
@@ -1 +1 @@\line
-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\line
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is the case because the pointer you have for the submodule isn\u8217't what is actually in the submodule directory. To fix this, you must run {\f1 git submodule update} again:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git submodule update\line
remote: Counting objects: 5, done.\line
remote: Compressing objects: 100% (3/3), done.\line
remote: Total 3 (delta 1), reused 2 (delta 0)\line
Unpacking objects: 100% (3/3), done.\line
From git@github.com:schacon/rack\line
   08d709f..6c5e70b  master     -> origin/master\line
Submodule path 'rack': checked out '6c5e70b984a60b3cecd395edd5b48a7575bf58e0'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to do this every time you pull down a submodule change in the main project. It\u8217's strange, but it works.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One common problem happens when a developer makes a change locally in a submodule but doesn\u8217't push it to a public server. Then, they commit a pointer to that non-public state and push up the superproject. When other developers try to run {\f1 git submodule update}, the submodule system can\u8217't find the commit that is referenced, because it exists only on the first developer\u8217's system. If that happens, you see an error like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git submodule update\line
fatal: reference isn\u8217't a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\line
Unable to checkout '6c5e70b984a60b3cecd395edd5ba7575bf58e0' in submodule path 'rack'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to see who last changed the submodule:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -1 rack\line
commit 85a3eee996800fcfa91e2119372dd4172bf76678\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Thu Apr 9 09:19:14 2009 -0700\line
\line
    added a submodule reference I will never make public. hahahahaha!\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you e-mail that guy and yell at him.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Superprojects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sometimes, developers want to get a combination of a large project\u8217's subdirectories, depending on what team they\u8217're on. This is common if you\u8217're coming from CVS or Subversion, where you\u8217've defined a module or collection of subdirectories, and you want to keep this type of workflow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A good way to do this in Git is to make each of the subfolders a separate Git repository and then create superproject Git repositories that contain multiple submodules. A benefit of this approach is that you can more specifically define the relationships between the projects with tags and branches in the superprojects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Issues with Submodules\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using submodules isn\u8217't without hiccups, however. First, you must be relatively careful when working in the submodule directory. When you run {\f1 git submodule update}, it checks out the specific version of the project, but not within a branch. This is called having a detached HEAD \u8212- it means the HEAD file points directly to a commit, not to a symbolic reference. The issue is that you generally don\u8217't want to work in a detached HEAD environment, because it\u8217's easy to lose changes. If you do an initial {\f1 submodule update}, commit in that submodule directory without creating a branch to work in, and then run {\f1 git submodule update} again from the superproject without committing in the meantime, Git will overwrite your changes without telling you. Technically you won\u8217't lose the work, but you won\u8217't have a branch pointing to it, so it will be somewhat difficult to retrieve.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To avoid this issue, create a branch when you work in a submodule directory with {\f1 git checkout -b work} or something equivalent. When you do the submodule update a second time, it will still revert your work, but at least you have a pointer to get back to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Switching branches with submodules in them can also be tricky. If you create a new branch, add a submodule there, and then switch back to a branch without that submodule, you still have the submodule directory as an untracked directory:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout -b rack\line
Switched to a new branch "rack"\line
$ git submodule add git@github.com:schacon/rack.git rack\line
Initialized empty Git repository in /opt/myproj/rack/.git/\line
...\line
Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.\line
Resolving deltas: 100% (1952/1952), done.\line
$ git commit -am 'added rack submodule'\line
[rack cc49a69] added rack submodule\line
 2 files changed, 4 insertions(+), 0 deletions(-)\line
 create mode 100644 .gitmodules\line
 create mode 160000 rack\line
$ git checkout master\line
Switched to branch "master"\line
$ git status\line
# On branch master\line
# Untracked files:\line
#   (use "git add <file>..." to include in what will be committed)\line
#\line
#      rack/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to either move it out of the way or remove it, in which case you have to clone it again when you switch back\u8212-and you may lose local changes or branches that you didn\u8217't push up.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last main caveat that many people run into involves switching from subdirectories to submodules. If you\u8217've been tracking files in your project and you want to move them out into a submodule, you must be careful or Git will get angry at you. Assume that you have the rack files in a subdirectory of your project, and you want to switch it to a submodule. If you delete the subdirectory and then run {\f1 submodule add}, Git yells at you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rm -Rf rack/\line
$ git submodule add git@github.com:schacon/rack.git rack\line
'rack' already exists in the index\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to unstage the {\f1 rack} directory first. Then you can add the submodule:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm -r rack\line
$ git submodule add git@github.com:schacon/rack.git rack\line
Initialized empty Git repository in /opt/testsub/rack/.git/\line
remote: Counting objects: 3184, done.\line
remote: Compressing objects: 100% (1465/1465), done.\line
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)\line
Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.\line
Resolving deltas: 100% (1952/1952), done.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now suppose you did that in a branch. If you try to switch back to a branch where those files are still in the actual tree rather than a submodule \u8212- you get this error:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
error: Untracked working tree file 'rack/AUTHORS' would be overwritten by merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to move the {\f1 rack} submodule directory out of the way before you can switch to a branch that doesn\u8217't have it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ mv rack /tmp/\line
$ git checkout master\line
Switched to branch "master"\line
$ ls\line
README  rack\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, when you switch back, you get an empty {\f1 rack} directory. You can either run {\f1 git submodule update} to reclone, or you can move your {\f1 /tmp/rack} directory back into the empty directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Subtree Merging\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you\u8217've seen the difficulties of the submodule system, let\u8217's look at an alternate way to solve the same problem. When Git merges, it looks at what it has to merge together and then chooses an appropriate merging strategy to use. If you\u8217're merging two branches, Git uses a {\i recursive} strategy. If you\u8217're merging more than two branches, Git picks the {\i octopus} strategy. These strategies are automatically chosen for you because the recursive strategy can handle complex three-way merge situations \u8212- for example, more than one common ancestor \u8212- but it can only handle merging two branches. The octopus merge can handle multiple branches but is more cautious to avoid difficult conflicts, so it\u8217's chosen as the default strategy if you\u8217're trying to merge more than two branches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, there are other strategies you can choose as well. One of them is the {\i subtree} merge, and you can use it to deal with the subproject issue. Here you\u8217'll see how to do the same rack embedding as in the last section, but using subtree merges instead.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one and vice versa. When you specify a subtree merge, Git is smart enough to figure out that one is a subtree of the other and merge appropriately \u8212- it\u8217's pretty amazing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You first add the Rack application to your project. You add the Rack project as a remote reference in your own project and then check it out into its own branch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add rack_remote git@github.com:schacon/rack.git\line
$ git fetch rack_remote\line
warning: no common commits\line
remote: Counting objects: 3184, done.\line
remote: Compressing objects: 100% (1465/1465), done.\line
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)\line
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.\line
Resolving deltas: 100% (1952/1952), done.\line
From git@github.com:schacon/rack\line
 * [new branch]      build      -> rack_remote/build\line
 * [new branch]      master     -> rack_remote/master\line
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4\line
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9\line
$ git checkout -b rack_branch rack_remote/master\line
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.\line
Switched to a new branch "rack_branch"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have the root of the Rack project in your {\f1 rack_branch} branch and your own project in the {\f1 master} branch. If you check out one and then the other, you can see that they have different project roots:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ls\line
AUTHORS        KNOWN-ISSUES   Rakefile      contrib        lib\line
COPYING        README         bin           example        test\line
$ git checkout master\line
Switched to branch "master"\line
$ ls\line
README\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You want to pull the Rack project into your {\f1 master} project as a subdirectory. You can do that in Git with {\f1 git read-tree}. You\u8217'll learn more about {\f1 read-tree} and its friends in Chapter 9, but for now know that it reads the root tree of one branch into your current staging area and working directory. You just switched back to your {\f1 master} branch, and you pull the {\f1 rack} branch into the {\f1 rack} subdirectory of your {\f1 master} branch of your main project:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git read-tree --prefix=rack/ -u rack_branch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you commit, it looks like you have all the Rack files under that subdirectory \u8212- as though you copied them in from a tarball. What gets interesting is that you can fairly easily merge changes from one of the branches to the other. So, if the Rack project updates, you can pull in upstream changes by switching to that branch and pulling:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout rack_branch\line
$ git pull\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can merge those changes back into your master branch. You can use {\f1 git merge -s subtree} and it will work fine; but Git will also merge the histories together, which you probably don\u8217't want. To pull in the changes and prepopulate the commit message, use the {\f1 --squash} and {\f1 --no-commit} options as well as the {\f1 -s subtree} strategy option:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git checkout master\line
$ git merge --squash -s subtree --no-commit rack_branch\line
Squash commit -- not updating HEAD\line
Automatic merge went well; stopped before committing as requested\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All the changes from your Rack project are merged in and ready to be committed locally. You can also do the opposite \u8212- make changes in the {\f1 rack} subdirectory of your master branch and then merge them into your {\f1 rack_branch} branch later to submit them to the maintainers or push them upstream.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To get a diff between what you have in your {\f1 rack} subdirectory and the code in your {\f1 rack_branch} branch \u8212- to see if you need to merge them \u8212- you can\u8217't use the normal {\f1 diff} command. Instead, you must run {\f1 git diff-tree} with the branch you want to compare to:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff-tree -p rack_branch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or, to compare what is in your {\f1 rack} subdirectory with what the {\f1 master} branch on the server was the last time you fetched, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff-tree -p rack_remote/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217've seen a number of advanced tools that allow you to manipulate your commits and staging area more precisely. When you notice issues, you should be able to easily figure out what commit introduced them, when, and by whom. If you want to use subprojects in your project, you\u8217've learned a few ways to accommodate those needs. At this point, you should be able to do most of the things in Git that you\u8217'll need on the command line day to day and feel comfortable doing so.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Customizing Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So far, I\u8217've covered the basics of how Git works and how to use it, and I\u8217've introduced a number of tools that Git provides to help you use it easily and efficiently. In this chapter, I\u8217'll go through some operations that you can use to make Git operate in a more customized fashion by introducing several important configuration settings and the hooks system. With these tools, it\u8217's easy to get Git to work exactly the way you, your company, or your group needs it to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Configuration\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you briefly saw in the Chapter 1, you can specify Git configuration settings with the {\f1 git config} command. One of the first things you did was set up your name and e-mail address:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global user.name "John Doe"\line
$ git config --global user.email johndoe@example.com\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217'll learn a few of the more interesting options that you can set in this manner to customize your Git usage.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You saw some simple Git configuration details in the first chapter, but I\u8217'll go over them again quickly here. Git uses a series of configuration files to determine non-default behavior that you may want. The first place Git looks for these values is in an {\f1 /etc/gitconfig} file, which contains values for every user on the system and all of their repositories. If you pass the option {\f1 --system} to {\f1 git config}, it reads and writes from this file specifically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next place Git looks is the {\f1 ~/.gitconfig} file, which is specific to each user. You can make Git read and write to this file by passing the {\f1 --global} option.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, Git looks for configuration values in the config file in the Git directory ({\f1 .git/config}) of whatever repository you\u8217're currently using. These values are specific to that single repository. Each level overwrites values in the previous level, so values in {\f1 .git/config} trump those in {\f1 /etc/gitconfig}, for instance. You can also set these values by manually editing the file and inserting the correct syntax, but it\u8217's generally easier to run the {\f1 git config} command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Basic Client Configuration\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The configuration options recognized by Git fall into two categories: client side and server side. The majority of the options are client side\u8212-configuring your personal working preferences. Although tons of options are available, I\u8217'll only cover the few that either are commonly used or can significantly affect your workflow. Many options are useful only in edge cases that I won\u8217't go over here. If you want to see a list of all the options your version of Git recognizes, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --help\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The manual page for {\f1 git config} lists all the available options in quite a bit of detail.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 core.editor\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By default, Git uses whatever you\u8217've set as your default text editor or else falls back to the Vi editor to create and edit your commit and tag messages. To change that default to something else, you can use the {\f1 core.editor} setting:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.editor emacs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, no matter what is set as your default shell editor variable, Git will fire up Emacs to edit messages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 commit.template\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you set this to the path of a file on your system, Git will use that file as the default message when you commit. For instance, suppose you create a template file at {\f1 $HOME/.gitmessage.txt} that looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 subject line\line
\line
what happened\line
\line
[ticket: X]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To tell Git to use it as the default message that appears in your editor when you run {\f1 git commit}, set the {\f1 commit.template} configuration value:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global commit.template $HOME/.gitmessage.txt\line
$ git commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, your editor will open to something like this for your placeholder commit message when you commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 subject line\line
\line
what happened\line
\line
[ticket: X]\line
# Please enter the commit message for your changes. Lines starting\line
# with '#' will be ignored, and an empty message aborts the commit.\line
# On branch master\line
# Changes to be committed:\line
#   (use "git reset HEAD <file>..." to unstage)\line
#\line
# modified:   lib/test.rb\line
#\line
~\line
~\line
".git/COMMIT_EDITMSG" 14L, 297C\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a commit-message policy in place, then putting a template for that policy on your system and configuring Git to use it by default can help increase the chance of that policy being followed regularly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 core.pager\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The core.pager setting determines what pager is used when Git pages output such as {\f1 log} and {\f1 diff}. You can set it to {\f1 more} or to your favorite pager (by default, it\u8217's {\f1 less}), or you can turn it off by setting it to a blank string:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.pager ''\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run that, Git will page the entire output of all commands, no matter how long it is.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 user.signingkey\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're making signed annotated tags (as discussed in Chapter 2), setting your GPG signing key as a configuration setting makes things easier. Set your key ID like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global user.signingkey <gpg-key-id>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can sign tags without having to specify your key every time with the {\f1 git tag} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -s <tag-name>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 core.excludesfile\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can put patterns in your project\u8217's {\f1 .gitignore} file to have Git not see them as untracked files or try to stage them when you run {\f1 git add} on them, as discussed in Chapter 2. However, if you want another file outside of your project to hold those values or have extra values, you can tell Git where that file is with the {\f1 core.excludesfile} setting. Simply set it to the path of a file that has content similar to what a {\f1 .gitignore} file would have.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 help.autocorrect\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This option is available only in Git 1.6.1 and later. If you mistype a command in Git 1.6, it shows you something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git com\line
git: 'com' is not a git-command. See 'git --help'.\line
\line
Did you mean this?\line
     commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you set {\f1 help.autocorrect} to 1, Git will automatically run the command if it has only one match under this scenario.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Colors in Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git can color its output to your terminal, which can help you visually parse the output quickly and easily. A number of options can help you set the coloring to your preference.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 color.ui\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git automatically colors most of its output if you ask it to. You can get very specific about what you want colored and how; but to turn on all the default terminal coloring, set {\f1 color.ui} to true:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global color.ui true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When that value is set, Git colors its output if the output goes to a terminal. Other possible settings are false, which never colors the output, and always, which sets colors all the time, even if you\u8217're redirecting Git commands to a file or piping them to another command. This setting was added in Git version 1.5.5; if you have an older version, you\u8217'll have to specify all the color settings individually.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll rarely want {\f1 color.ui = always}. In most scenarios, if you want color codes in your redirected output, you can instead pass a {\f1 --color} flag to the Git command to force it to use color codes. The {\f1 color.ui = true} setting is almost always what you\u8217'll want to use.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 {\f1 color.*}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to be more specific about which commands are colored and how, or you have an older version, Git provides verb-specific coloring settings. Each of these can be set to {\f1 true}, {\f1 false}, or {\f1 always}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 color.branch\line
color.diff\line
color.interactive\line
color.status\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition, each of these has subsettings you can use to set specific colors for parts of the output, if you want to override each color. For example, to set the meta information in your diff output to blue foreground, black background, and bold text, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global color.diff.meta "blue black bold"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can set the color to any of the following values: normal, black, red, green, yellow, blue, magenta, cyan, or white. If you want an attribute like bold in the previous example, you can choose from bold, dim, ul, blink, and reverse.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 See the {\f1 git config} manpage for all the subsettings you can configure, if you want to do that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 External Merge and Diff Tools\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although Git has an internal implementation of diff, which is what you\u8217've been using, you can set up an external tool instead. You can also set up a graphical merge conflict-resolution tool instead of having to resolve conflicts manually. I\u8217'll demonstrate setting up the Perforce Visual Merge Tool (P4Merge) to do your diffs and merge resolutions, because it\u8217's a nice graphical tool and it\u8217's free.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to try this out, P4Merge works on all major platforms, so you should be able to do so. I\u8217'll use path names in the examples that work on Mac and Linux systems; for Windows, you\u8217'll have to change {\f1 /usr/local/bin} to an executable path in your environment.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can download P4Merge here:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 http://www.perforce.com/perforce/downloads/component.html\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To begin, you\u8217'll set up external wrapper scripts to run your commands. I\u8217'll use the Mac path for the executable; in other systems, it will be where your {\f1 p4merge} binary is installed. Set up a merge wrapper script named {\f1 extMerge} that calls your binary with all the arguments provided:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /usr/local/bin/extMerge\line
#!/bin/sh\line
/Applications/p4merge.app/Contents/MacOS/p4merge $*\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The diff wrapper checks to make sure seven arguments are provided and passes two of them to your merge script. By default, Git passes the following arguments to the diff program:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 path old-file old-hex old-mode new-file new-hex new-mode\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because you only want the {\f1 old-file} and {\f1 new-file} arguments, you use the wrapper script to pass the ones you need.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /usr/local/bin/extDiff\line
#!/bin/sh\line
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You also need to make sure these tools are executable:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ sudo chmod +x /usr/local/bin/extMerge\line
$ sudo chmod +x /usr/local/bin/extDiff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can set up your config file to use your custom merge resolution and diff tools. This takes a number of custom settings: {\f1 merge.tool} to tell Git what strategy to use, {\f1 mergetool.*.cmd} to specify how to run the command, {\f1 mergetool.trustExitCode} to tell Git if the exit code of that program indicates a successful merge resolution or not, and {\f1 diff.external} to tell Git what command to run for diffs. So, you can either run four config commands\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global merge.tool extMerge\line
$ git config --global mergetool.extMerge.cmd \\\line
    'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'\line
$ git config --global mergetool.trustExitCode false\line
$ git config --global diff.external extDiff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 or you can edit your {\f1 ~/.gitconfig} file to add these lines:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [merge]\line
  tool = extMerge\line
[mergetool "extMerge"]\line
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"\line
  trustExitCode = false\line
[diff]\line
  external = extDiff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After all this is set, if you run diff commands such as this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff 32d1776b1^ 32d1776b1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Instead of getting the diff output on the command line, Git fires up P4Merge, which looks something like Figure 7-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0701.png Figure 7-1. P4Merge.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you try to merge two branches and subsequently have merge conflicts, you can run the command {\f1 git mergetool}; it starts P4Merge to let you resolve the conflicts through that GUI tool.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The nice thing about this wrapper setup is that you can change your diff and merge tools easily. For example, to change your {\f1 extDiff} and {\f1 extMerge} tools to run the KDiff3 tool instead, all you have to do is edit your {\f1 extMerge} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /usr/local/bin/extMerge\line
#!/bin/sh\line
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Git will use the KDiff3 tool for diff viewing and merge conflict resolution.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git comes preset to use a number of other merge-resolution tools without your having to set up the cmd configuration. You can set your merge tool to kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, or gvimdiff. If you\u8217're not interested in using KDiff3 for diff but rather want to use it just for merge resolution, and the kdiff3 command is in your path, then you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global merge.tool kdiff3\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run this instead of setting up the {\f1 extMerge} and {\f1 extDiff} files, Git will use KDiff3 for merge resolution and the normal Git diff tool for diffs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Formatting and Whitespace\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform. It\u8217's very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them or Windows programmers add carriage returns at the end of lines they touch in cross-platform projects. Git has a few configuration options to help with these issues.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 core.autocrlf\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're programming on Windows or using another system but working with people who are programming on Windows, you\u8217'll probably run into line-ending issues at some point. This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character. This is a subtle but incredibly annoying fact of cross-platform work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git can handle this by auto-converting CRLF line endings into LF when you commit, and vice versa when it checks out code onto your filesystem. You can turn on this functionality with the {\f1 core.autocrlf} setting. If you\u8217're on a Windows machine, set it to {\f1 true} \u8212- this converts LF endings into CRLF when you check out code:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.autocrlf true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're on a Linux or Mac system that uses LF line endings, then you don\u8217't want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it. You can tell Git to convert CRLF to LF on commit but not the other way around by setting {\f1 core.autocrlf} to input:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.autocrlf input\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This setup should leave you with CRLF endings in Windows checkouts but LF endings on Mac and Linux systems and in the repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to {\f1 false}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.autocrlf false\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 core.whitespace\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git comes preset to detect and fix some whitespace issues. It can look for four primary whitespace issues \u8212- two are enabled by default and can be turned off, and two aren\u8217't enabled by default but can be activated.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The two that are turned on by default are {\f1 trailing-space}, which looks for spaces at the end of a line, and {\f1 space-before-tab}, which looks for spaces before tabs at the beginning of a line.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The two that are disabled by default but can be turned on are {\f1 indent-with-non-tab}, which looks for lines that begin with eight or more spaces instead of tabs, and {\f1 cr-at-eol}, which tells Git that carriage returns at the end of lines are OK.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can tell Git which of these you want enabled by setting {\f1 core.whitespace} to the values you want on or off, separated by commas. You can disable settings by either leaving them out of the setting string or prepending a {\f1 -} in front of the value. For example, if you want all but {\f1 cr-at-eol} to be set, you can do this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global core.whitespace \\\line
    trailing-space,space-before-tab,indent-with-non-tab\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git will detect these issues when you run a {\f1 git diff} command and try to color them so you can possibly fix them before you commit. It will also use these values to help you when you apply patches with {\f1 git apply}. When you\u8217're applying patches, you can ask Git to warn you if it\u8217's applying patches with the specified whitespace issues:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git apply --whitespace=warn <patch>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or you can have Git try to automatically fix the issue before applying the patch:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git apply --whitespace=fix <patch>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These options apply to the {\f1 git rebase} command as well. If you\u8217've committed whitespace issues but haven\u8217't yet pushed upstream, you can run a {\f1 rebase} with the {\f1 --whitespace=fix} option to have Git automatically fix whitespace issues as it\u8217's rewriting the patches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Server Configuration\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 receive.fsckObjects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By default, Git doesn\u8217't check for consistency all the objects it receives during a push. Although Git can check to make sure each object still matches its SHA-1 checksum and points to valid objects, it doesn\u8217't do that by default on every push. This is a relatively expensive operation and may add a lot of time to each push, depending on the size of the repository or the push. If you want Git to check object consistency on every push, you can force it to do so by setting {\f1 receive.fsckObjects} to true:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --system receive.fsckObjects true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Git will check the integrity of your repository before each push is accepted to make sure faulty clients aren\u8217't introducing corrupt data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 receive.denyNonFastForwards\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you rebase commits that you\u8217've already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn\u8217't contain the commit that the remote branch currently points to, you\u8217'll be denied. This is generally good policy; but in the case of the rebase, you may determine that you know what you\u8217're doing and can force-update the remote branch with a {\f1 -f} flag to your push command.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To disable the ability to force-update remote branches to non-fast-forward references, set {\f1 receive.denyNonFastForwards}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --system receive.denyNonFastForwards true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other way you can do this is via server-side receive hooks, which I\u8217'll cover in a bit. That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 receive.denyDeletes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the workarounds to the {\f1 denyNonFastForwards} policy is for the user to delete the branch and then push it back up with the new reference. In newer versions of Git (beginning with version 1.6.1), you can set {\f1 receive.denyDeletes} to true:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --system receive.denyDeletes true\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This denies branch and tag deletion over a push across the board \u8212- no user can do it. To remove remote branches, you must remove the ref files from the server manually. There are also more interesting ways to do this on a per-user basis via ACLs, as you\u8217'll learn at the end of this chapter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Attributes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some of these settings can also be specified for a path, so that Git applies those settings only for a subdirectory or subset of files. These path-specific settings are called Git attributes and are set either in a {\f1 .gitattributes} file in one of your directories (normally the root of your project) or in the {\f1 .git/info/attributes} file if you don\u8217't want the attributes file committed with your project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using attributes, you can do things like specify separate merge strategies for individual files or directories in your project, tell Git how to diff non-text files, or have Git filter content before you check it into or out of Git. In this section, you\u8217'll learn about some of the attributes you can set on your paths in your Git project and see a few examples of using this feature in practice.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Binary Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One cool trick for which you can use Git attributes is telling Git which files are binary (in cases it otherwise may not be able to figure out) and giving Git special instructions about how to handle those files. For instance, some text files may be machine generated and not diffable, whereas some binary files can be diffed \u8212- you\u8217'll see how to tell Git which is which.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Identifying Binary Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some files look like text files but for all intents and purposes are to be treated as binary data. For instance, Xcode projects on the Mac contain a file that ends in {\f1 .pbxproj}, which is basically a JSON (plain text javascript data format) dataset written out to disk by the IDE that records your build settings and so on. Although it\u8217's technically a text file, because it\u8217's all ASCII, you don\u8217't want to treat it as such because it\u8217's really a lightweight database \u8212- you can\u8217't merge the contents if two people changed it, and diffs generally aren\u8217't helpful. The file is meant to be consumed by a machine. In essence, you want to treat it like a binary file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To tell Git to treat all {\f1 pbxproj} files as binary data, add the following line to your {\f1 .gitattributes} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *.pbxproj -crlf -diff\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, Git won\u8217't try to convert or fix CRLF issues; nor will it try to compute or print a diff for changes in this file when you run git show or git diff on your project. In the 1.6 series of Git, you can also use a macro that is provided that means {\f1 -crlf -diff}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *.pbxproj binary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Diffing Binary Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the 1.6 series of Git, you can use the Git attributes functionality to effectively diff binary files. You do this by telling Git how to convert your binary data to a text format that can be compared via the normal diff.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 MS Word files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because this is a pretty cool and not widely known feature, I\u8217'll go over a few examples. First, you\u8217'll use this technique to solve one of the most annoying problems known to humanity: version-controlling Word documents. Everyone knows that Word is the most horrific editor around; but, oddly, everyone uses it. If you want to version-control Word documents, you can stick them in a Git repository and commit every once in a while; but what good does that do? If you run {\f1 git diff} normally, you only see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff\line
diff --git a/chapter1.doc b/chapter1.doc\line
index 88839c4..4afcb7c 100644\line
Binary files a/chapter1.doc and b/chapter1.doc differ\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can\u8217't directly compare two versions unless you check them out and scan them manually, right? It turns out you can do this fairly well using Git attributes. Put the following line in your {\f1 .gitattributes} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *.doc diff=word\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This tells Git that any file that matches this pattern (.doc) should use the \u8220"word\u8221" filter when you try to view a diff that contains changes. What is the \u8220"word\u8221" filter? You have to set it up. Here you\u8217'll configure Git to use the {\f1 strings} program to convert Word documents into readable text files, which it will then diff properly:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config diff.word.textconv strings\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This command adds a section to your {\f1 .git/config} that looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [diff "word"]\line
    textconv = strings\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Side note: There are different kinds of {\f1 .doc} files. Some use an UTF-16 encoding or other \u8220"codepages\u8221" and {\f1 strings} won\u8217't find anything useful in there. Your mileage may vary.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now Git knows that if it tries to do a diff between two snapshots, and any of the files end in {\f1 .doc}, it should run those files through the \u8220"word\u8221" filter, which is defined as the {\f1 strings} program. This effectively makes nice text-based versions of your Word files before attempting to diff them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here\u8217's an example. I put Chapter 1 of this book into Git, added some text to a paragraph, and saved the document. Then, I ran {\f1 git diff} to see what changed:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git diff\line
diff --git a/chapter1.doc b/chapter1.doc\line
index c1c8a0a..b93c9e4 100644\line
--- a/chapter1.doc\line
+++ b/chapter1.doc\line
@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git basics\line
 re going to cover how to get it and set it up for the first time if you don\line
 t already have it on your system.\line
 In Chapter Two we will go over basic Git usage - how to use Git for the 80%\line
-s going on, modify stuff and contribute changes. If the book spontaneously\line
+s going on, modify stuff and contribute changes. If the book spontaneously\line
+Let's see if this works.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git successfully and succinctly tells me that I added the string \u8220"Let\u8217's see if this works\u8221", which is correct. It\u8217's not perfect \u8212- it adds a bunch of random stuff at the end \u8212- but it certainly works. If you can find or write a Word-to-plain-text converter that works well enough, that solution will likely be incredibly effective. However, {\f1 strings} is available on most Mac and Linux systems, so it may be a good first try to do this with many binary formats.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 OpenDocument Text files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The same approach that we used for MS Word files ({\f1 *.doc}) can be used for OpenDocument Text files ({\f1 *.odt}) created by OpenOffice.org.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Add the following line to your {\f1 .gitattributes} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *.odt diff=odt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now set up the {\f1 odt} diff filter in {\f1 .git/config}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [diff "odt"]\line
    binary = true\line
    textconv = /usr/local/bin/odt-to-txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 OpenDocument files are actually zip\u8217'ped directories containing multiple files (the content in an XML format, stylesheets, images, etc.). We\u8217'll need to write a script to extract the content and return it as plain text. Create a file {\f1 /usr/local/bin/odt-to-txt} (you are free to put it into a different directory) with the following content:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #! /usr/bin/env perl\line
# Simplistic OpenDocument Text (.odt) to plain text converter.\line
# Author: Philipp Kempgen\line
\line
if (! defined($ARGV[0])) \{\line
    print STDERR "No filename given!\\n";\line
    print STDERR "Usage: $0 filename\\n";\line
    exit 1;\line
\}\line
\line
my $content = '';\line
open my $fh, '-|', 'unzip', '-qq', '-p', $ARGV[0], 'content.xml' or die $!;\line
\{\line
    local $/ = undef;  # slurp mode\line
    $content = <$fh>;\line
\}\line
close $fh;\line
$_ = $content;\line
s/<text:span\\b[^>]*>//g;           # remove spans\line
s/<text:h\\b[^>]*>/\\n\\n*****  /g;   # headers\line
s/<text:list-item\\b[^>]*>\\s*<text:p\\b[^>]*>/\\n    --  /g;  # list items\line
s/<text:list\\b[^>]*>/\\n\\n/g;       # lists\line
s/<text:p\\b[^>]*>/\\n  /g;          # paragraphs\line
s/<[^>]+>//g;                      # remove all XML tags\line
s/\\n\{2,\}/\\n\\n/g;                   # remove multiple blank lines\line
s/\\A\\n+//;                         # remove leading blank lines\line
print "\\n", $_, "\\n\\n";\par}
{\pard \ql \f0 \sa180 \li0 \fi0 And make it executable\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 chmod +x /usr/local/bin/odt-to-txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now {\f1 git diff} will be able to tell you what changed in {\f1 .odt} files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 Image files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another interesting problem you can solve this way involves diffing image files. One way to do this is to run PNG files through a filter that extracts their EXIF information \u8212- metadata that is recorded with most image formats. If you download and install the {\f1 exiftool} program, you can use it to convert your images into text about the metadata, so at least the diff will show you a textual representation of any changes that happened:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo '*.png diff=exif' >> .gitattributes\line
$ git config diff.exif.textconv exiftool\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you replace an image in your project and run {\f1 git diff}, you see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 diff --git a/image.png b/image.png\line
index 88839c4..4afcb7c 100644\line
--- a/image.png\line
+++ b/image.png\line
@@ -1,12 +1,12 @@\line
 ExifTool Version Number         : 7.74\line
-File Size                       : 70 kB\line
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00\line
+File Size                       : 94 kB\line
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00\line
 File Type                       : PNG\line
 MIME Type                       : image/png\line
-Image Width                     : 1058\line
-Image Height                    : 889\line
+Image Width                     : 1056\line
+Image Height                    : 827\line
 Bit Depth                       : 8\line
 Color Type                      : RGB with Alpha\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can easily see that the file size and image dimensions have both changed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Keyword Expansion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 SVN- or CVS-style keyword expansion is often requested by developers used to those systems. The main problem with this in Git is that you can\u8217't modify a file with information about the commit after you\u8217've committed, because Git checksums the file first. However, you can inject text into a file when it\u8217's checked out and remove it again before it\u8217's added to a commit. Git attributes offers you two ways to do this.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, you can inject the SHA-1 checksum of a blob into an {\f1 $Id$} field in the file automatically. If you set this attribute on a file or set of files, then the next time you check out that branch, Git will replace that field with the SHA-1 of the blob. It\u8217's important to notice that it isn\u8217't the SHA of the commit, but of the blob itself:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo '*.txt ident' >> .gitattributes\line
$ echo '$Id$' > test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next time you check out this file, Git injects the SHA of the blob:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rm test.txt\line
$ git checkout -- test.txt\line
$ cat test.txt\line
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, that result is of limited use. If you\u8217've used keyword substitution in CVS or Subversion, you can include a datestamp \u8212- the SHA isn\u8217't all that helpful, because it\u8217's fairly random and you can\u8217't tell if one SHA is older or newer than another.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It turns out that you can write your own filters for doing substitutions in files on commit/checkout. These are the \u8220"clean\u8221" and \u8220"smudge\u8221" filters. In the {\f1 .gitattributes} file, you can set a filter for particular paths and then set up scripts that will process files just before they\u8217're checked out (\u8220"smudge\u8221", see Figure 7-2) and just before they\u8217're committed (\u8220"clean\u8221", see Figure 7-3). These filters can be set to do all sorts of fun things.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0702.png Figure 7-2. The \u8220"smudge\u8221" filter is run on checkout.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0703.png Figure 7-3. The \u8220"clean\u8221" filter is run when files are staged.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The original commit message for this functionality gives a simple example of running all your C source code through the {\f1 indent} program before committing. You can set it up by setting the filter attribute in your {\f1 .gitattributes} file to filter {\f1 *.c} files with the \u8220"indent\u8221" filter:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 *.c     filter=indent\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, tell Git what the \u8220"indent\u8221" filter does on smudge and clean:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config --global filter.indent.clean indent\line
$ git config --global filter.indent.smudge cat\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, when you commit files that match {\f1 *.c}, Git will run them through the indent program before it commits them and then run them through the {\f1 cat} program before it checks them back out onto disk. The {\f1 cat} program is basically a no-op: it spits out the same data that it gets in. This combination effectively filters all C source code files through {\f1 indent} before committing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another interesting example gets {\f1 $Date$} keyword expansion, RCS style. To do this properly, you need a small script that takes a filename, figures out the last commit date for this project, and inserts the date into the file. Here is a small Ruby script that does that:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #! /usr/bin/env ruby\line
data = STDIN.read\line
last_date = `git log --pretty=format:"%ad" -1`\line
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All the script does is get the latest commit date from the {\f1 git log} command, stick that into any {\f1 $Date$} strings it sees in stdin, and print the results \u8212- it should be simple to do in whatever language you\u8217're most comfortable in. You can name this file {\f1 expand_date} and put it in your path. Now, you need to set up a filter in Git (call it {\f1 dater}) and tell it to use your {\f1 expand_date} filter to smudge the files on checkout. You\u8217'll use a Perl expression to clean that up on commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git config filter.dater.smudge expand_date\line
$ git config filter.dater.clean 'perl -pe "s/\\\\\\$Date[^\\\\\\$]*\\\\\\$/\\\\\\$Date\\\\\\$/"'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This Perl snippet strips out anything it sees in a {\f1 $Date$} string, to get back to where you started. Now that your filter is ready, you can test it by setting up a file with your {\f1 $Date$} keyword and then setting up a Git attribute for that file that engages the new filter:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo '# $Date$' > date_test.txt\line
$ echo 'date*.txt filter=dater' >> .gitattributes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you commit those changes and check out the file again, you see the keyword properly substituted:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git add date_test.txt .gitattributes\line
$ git commit -m "Testing date expansion in Git"\line
$ rm date_test.txt\line
$ git checkout date_test.txt\line
$ cat date_test.txt\line
# $Date: Tue Apr 21 07:26:52 2009 -0700$\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see how powerful this technique can be for customized applications. You have to be careful, though, because the {\f1 .gitattributes} file is committed and passed around with the project but the driver (in this case, {\f1 dater}) isn\u8217't; so, it won\u8217't work everywhere. When you design these filters, they should be able to fail gracefully and have the project still work properly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Exporting Your Repository\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git attribute data also allows you to do some interesting things when exporting an archive of your project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 export-ignore\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can tell Git not to export certain files or directories when generating an archive. If there is a subdirectory or file that you don\u8217't want to include in your archive file but that you do want checked into your project, you can determine those files via the {\f1 export-ignore} attribute.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, say you have some test files in a {\f1 test/} subdirectory, and it doesn\u8217't make sense to include them in the tarball export of your project. You can add the following line to your Git attributes file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 test/ export-ignore\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, when you run git archive to create a tarball of your project, that directory won\u8217't be included in the archive.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 export-subst\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another thing you can do for your archives is some simple keyword substitution. Git lets you put the string {\f1 $Format:$} in any file with any of the {\f1 --pretty=format} formatting shortcodes, many of which you saw in Chapter 2. For instance, if you want to include a file named {\f1 LAST_COMMIT} in your project, and the last commit date was automatically injected into it when {\f1 git archive} ran, you can set up the file like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'Last commit date: $Format:%cd$' > LAST_COMMIT\line
$ echo "LAST_COMMIT export-subst" >> .gitattributes\line
$ git add LAST_COMMIT .gitattributes\line
$ git commit -am 'adding LAST_COMMIT file for archives'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you run {\f1 git archive}, the contents of that file when people open the archive file will look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat LAST_COMMIT\line
Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Merge Strategies\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also use Git attributes to tell Git to use different merge strategies for specific files in your project. One very useful option is to tell Git to not try to merge specific files when they have conflicts, but rather to use your side of the merge over someone else\u8217's.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is helpful if a branch in your project has diverged or is specialized, but you want to be able to merge changes back in from it, and you want to ignore certain files. Say you have a database settings file called database.xml that is different in two branches, and you want to merge in your other branch without messing up the database file. You can set up an attribute like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 database.xml merge=ours\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you merge in the other branch, instead of having merge conflicts with the database.xml file, you see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git merge topic\line
Auto-merging database.xml\line
Merge made by recursive.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, database.xml stays at whatever version you originally had.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Like many other Version Control Systems, Git has a way to fire off custom scripts when certain important actions occur. There are two groups of these hooks: client side and server side. The client-side hooks are for client operations such as committing and merging. The server-side hooks are for Git server operations such as receiving pushed commits. You can use these hooks for all sorts of reasons, and you\u8217'll learn about a few of them here.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Installing a Hook\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The hooks are all stored in the {\f1 hooks} subdirectory of the Git directory. In most projects, that\u8217's {\f1 .git/hooks}. By default, Git populates this directory with a bunch of example scripts, many of which are useful by themselves; but they also document the input values of each script. All the examples are written as shell scripts, with some Perl thrown in, but any properly named executable scripts will work fine \u8212- you can write them in Ruby or Python or what have you. For post-1.6 versions of Git, these example hook files end with .sample; you\u8217'll need to rename them. For pre-1.6 versions of Git, the example files are named properly but are not executable.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To enable a hook script, put a file in the {\f1 hooks} subdirectory of your Git directory that is named appropriately and is executable. From that point forward, it should be called. I\u8217'll cover most of the major hook filenames here.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Client-Side Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are a lot of client-side hooks. This section splits them into committing-workflow hooks, e-mail-workflow scripts, and the rest of the client-side scripts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Committing-Workflow Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first four hooks have to do with the committing process. The {\f1 pre-commit} hook is run first, before you even type in a commit message. It\u8217's used to inspect the snapshot that\u8217's about to be committed, to see if you\u8217've forgotten something, to make sure tests run, or to examine whatever you need to inspect in the code. Exiting non-zero from this hook aborts the commit, although you can bypass it with {\f1 git commit --no-verify}. You can do things like check for code style (run lint or something equivalent), check for trailing whitespace (the default hook does exactly that), or check for appropriate documentation on new methods.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 prepare-commit-msg} hook is run before the commit message editor is fired up but after the default message is created. It lets you edit the default message before the commit author sees it. This hook takes a few options: the path to the file that holds the commit message so far, the type of commit, and the commit SHA-1 if this is an amended commit. This hook generally isn\u8217't useful for normal commits; rather, it\u8217's good for commits where the default message is auto-generated, such as templated commit messages, merge commits, squashed commits, and amended commits. You may use it in conjunction with a commit template to programmatically insert information.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 commit-msg} hook takes one parameter, which again is the path to a temporary file that contains the current commit message. If this script exits non-zero, Git aborts the commit process, so you can use it to validate your project state or commit message before allowing a commit to go through. In the last section of this chapter, I\u8217'll demonstrate using this hook to check that your commit message is conformant to a required pattern.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After the entire commit process is completed, the {\f1 post-commit} hook runs. It doesn\u8217't take any parameters, but you can easily get the last commit by running {\f1 git log -1 HEAD}. Generally, this script is used for notification or something similar.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The committing-workflow client-side scripts can be used in just about any workflow. They\u8217're often used to enforce certain policies, although it\u8217's important to note that these scripts aren\u8217't transferred during a clone. You can enforce policy on the server side to reject pushes of commits that don\u8217't conform to some policy, but it\u8217's entirely up to the developer to use these scripts on the client side. So, these are scripts to help developers, and they must be set up and maintained by them, although they can be overridden or modified by them at any time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 E-mail Workflow Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can set up three client-side hooks for an e-mail-based workflow. They\u8217're all invoked by the {\f1 git am} command, so if you aren\u8217't using that command in your workflow, you can safely skip to the next section. If you\u8217're taking patches over e-mail prepared by {\f1 git format-patch}, then some of these may be helpful to you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first hook that is run is {\f1 applypatch-msg}. It takes a single argument: the name of the temporary file that contains the proposed commit message. Git aborts the patch if this script exits non-zero. You can use this to make sure a commit message is properly formatted or to normalize the message by having the script edit it in place.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next hook to run when applying patches via {\f1 git am} is {\f1 pre-applypatch}. It takes no arguments and is run after the patch is applied, so you can use it to inspect the snapshot before making the commit. You can run tests or otherwise inspect the working tree with this script. If something is missing or the tests don\u8217't pass, exiting non-zero also aborts the {\f1 git am} script without committing the patch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last hook to run during a {\f1 git am} operation is {\f1 post-applypatch}. You can use it to notify a group or the author of the patch you pulled in that you\u8217've done so. You can\u8217't stop the patching process with this script.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Other Client Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 pre-rebase} hook runs before you rebase anything and can halt the process by exiting non-zero. You can use this hook to disallow rebasing any commits that have already been pushed. The example {\f1 pre-rebase} hook that Git installs does this, although it assumes that next is the name of the branch you publish. You\u8217'll likely need to change that to whatever your stable, published branch is.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After you run a successful {\f1 git checkout}, the {\f1 post-checkout} hook runs; you can use it to set up your working directory properly for your project environment. This may mean moving in large binary files that you don\u8217't want source controlled, auto-generating documentation, or something along those lines.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, the {\f1 post-merge} hook runs after a successful {\f1 merge} command. You can use it to restore data in the working tree that Git can\u8217't track, such as permissions data. This hook can likewise validate the presence of files external to Git control that you may want copied in when the working tree changes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Server-Side Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to the client-side hooks, you can use a couple of important server-side hooks as a system administrator to enforce nearly any kind of policy for your project. These scripts run before and after pushes to the server. The pre hooks can exit non-zero at any time to reject the push as well as print an error message back to the client; you can set up a push policy that\u8217's as complex as you wish.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 pre-receive and post-receive\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first script to run when handling a push from a client is {\f1 pre-receive}. It takes a list of references that are being pushed from stdin; if it exits non-zero, none of them are accepted. You can use this hook to do things like make sure none of the updated references are non-fast-forwards; or to check that the user doing the pushing has create, delete, or push access or access to push updates to all the files they\u8217're modifying with the push.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 post-receive} hook runs after the entire process is completed and can be used to update other services or notify users. It takes the same stdin data as the {\f1 pre-receive} hook. Examples include e-mailing a list, notifying a continuous integration server, or updating a ticket-tracking system \u8212- you can even parse the commit messages to see if any tickets need to be opened, modified, or closed. This script can\u8217't stop the push process, but the client doesn\u8217't disconnect until it has completed; so, be careful when you try to do anything that may take a long time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 update\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The update script is very similar to the {\f1 pre-receive} script, except that it\u8217's run once for each branch the pusher is trying to update. If the pusher is trying to push to multiple branches, {\f1 pre-receive} runs only once, whereas update runs once per branch they\u8217're pushing to. Instead of reading from stdin, this script takes three arguments: the name of the reference (branch), the SHA-1 that reference pointed to before the push, and the SHA-1 the user is trying to push. If the update script exits non-zero, only that reference is rejected; other references can still be updated.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 An Example Git-Enforced Policy\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this section, you\u8217'll use what you\u8217've learned to establish a Git workflow that checks for a custom commit message format, enforces fast-forward-only pushes, and allows only certain users to modify certain subdirectories in a project. You\u8217'll build client scripts that help the developer know if their push will be rejected and server scripts that actually enforce the policies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 I used Ruby to write these, both because it\u8217's my preferred scripting language and because I feel it\u8217's the most pseudocode-looking of the scripting languages; thus you should be able to roughly follow the code even if you don\u8217't use Ruby. However, any language will work fine. All the sample hook scripts distributed with Git are in either Perl or Bash scripting, so you can also see plenty of examples of hooks in those languages by looking at the samples.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Server-Side Hook\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All the server-side work will go into the update file in your hooks directory. The update file runs once per branch being pushed and takes the reference being pushed to, the old revision where that branch was, and the new revision being pushed. You also have access to the user doing the pushing if the push is being run over SSH. If you\u8217've allowed everyone to connect with a single user (like \u8220"git\u8221") via public-key authentication, you may have to give that user a shell wrapper that determines which user is connecting based on the public key, and set an environment variable specifying that user. Here I assume the connecting user is in the {\f1 $USER} environment variable, so your update script begins by gathering all the information you need:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #!/usr/bin/env ruby\line
\line
$refname = ARGV[0]\line
$oldrev  = ARGV[1]\line
$newrev  = ARGV[2]\line
$user    = ENV['USER']\line
\line
puts "Enforcing Policies... \\n(#\{$refname\}) (#\{$oldrev[0,6]\}) (#\{$newrev[0,6]\})"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Yes, I\u8217'm using global variables. Don\u8217't judge me \u8212- it\u8217's easier to demonstrate in this manner.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Enforcing a Specific Commit-Message Format\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your first challenge is to enforce that each commit message must adhere to a particular format. Just to have a target, assume that each message has to include a string that looks like \u8220"ref: 1234\u8221" because you want each commit to link to a work item in your ticketing system. You must look at each commit being pushed up, see if that string is in the commit message, and, if the string is absent from any of the commits, exit non-zero so the push is rejected.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can get a list of the SHA-1 values of all the commits that are being pushed by taking the {\f1 $newrev} and {\f1 $oldrev} values and passing them to a Git plumbing command called {\f1 git rev-list}. This is basically the {\f1 git log} command, but by default it prints out only the SHA-1 values and no other information. So, to get a list of all the commit SHAs introduced between one commit SHA and another, you can run something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rev-list 538c33..d14fc7\line
d14fc7c847ab946ec39590d87783c69b031bdfb7\line
9f585da4401b0a3999e84113824d15245c13f0be\line
234071a1be950e2a8d078e6141f5cd20c1e61ad3\line
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a\line
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can take that output, loop through each of those commit SHAs, grab the message for it, and test that message against a regular expression that looks for a pattern.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have to figure out how to get the commit message from each of these commits to test. To get the raw commit data, you can use another plumbing command called {\f1 git cat-file}. I\u8217'll go over all these plumbing commands in detail in Chapter 9; but for now, here\u8217's what that command gives you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file commit ca82a6\line
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\line
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
author Scott Chacon <schacon@gmail.com> 1205815931 -0700\line
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700\line
\line
changed the version number\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A simple way to get the commit message from a commit when you have the SHA-1 value is to go to the first blank line and take everything after that. You can do so with the {\f1 sed} command on Unix systems:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file commit ca82a6 | sed '1,/^$/d'\line
changed the version number\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can use that incantation to grab the commit message from each commit that is trying to be pushed and exit if you see anything that doesn\u8217't match. To exit the script and reject the push, exit non-zero. The whole method looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $regex = /\\[ref: (\\d+)\\]/\line
\line
# enforced custom commit message format\line
def check_message_format\line
  missed_revs = `git rev-list #\{$oldrev\}..#\{$newrev\}`.split("\\n")\line
  missed_revs.each do |rev|\line
    message = `git cat-file commit #\{rev\} | sed '1,/^$/d'`\line
    if !$regex.match(message)\line
      puts "[POLICY] Your message is not formatted correctly"\line
      exit 1\line
    end\line
  end\line
end\line
check_message_format\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Putting that in your {\f1 update} script will reject updates that contain commits that have messages that don\u8217't adhere to your rule.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Enforcing a User-Based ACL System\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose you want to add a mechanism that uses an access control list (ACL) that specifies which users are allowed to push changes to which parts of your projects. Some people have full access, and others only have access to push changes to certain subdirectories or specific files. To enforce this, you\u8217'll write those rules to a file named {\f1 acl} that lives in your bare Git repository on the server. You\u8217'll have the {\f1 update} hook look at those rules, see what files are being introduced for all the commits being pushed, and determine whether the user doing the push has access to update all those files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first thing you\u8217'll do is write your ACL. Here you\u8217'll use a format very much like the CVS ACL mechanism: it uses a series of lines, where the first field is {\f1 avail} or {\f1 unavail}, the next field is a comma-delimited list of the users to which the rule applies, and the last field is the path to which the rule applies (blank meaning open access). All of these fields are delimited by a pipe ({\f1 |}) character.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, you have a couple of administrators, some documentation writers with access to the {\f1 doc} directory, and one developer who only has access to the {\f1 lib} and {\f1 tests} directories, and your ACL file looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 avail|nickh,pjhyett,defunkt,tpw\line
avail|usinclair,cdickens,ebronte|doc\line
avail|schacon|lib\line
avail|schacon|tests\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You begin by reading this data into a structure that you can use. In this case, to keep the example simple, you\u8217'll only enforce the {\f1 avail} directives. Here is a method that gives you an associative array where the key is the user name and the value is an array of paths to which the user has write access:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def get_acl_access_data(acl_file)\line
  # read in ACL data\line
  acl_file = File.read(acl_file).split("\\n").reject \{ |line| line == '' \}\line
  access = \{\}\line
  acl_file.each do |line|\line
    avail, users, path = line.split('|')\line
    next unless avail == 'avail'\line
    users.split(',').each do |user|\line
      access[user] ||= []\line
      access[user] << path\line
    end\line
  end\line
  access\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 On the ACL file you looked at earlier, this {\f1 get_acl_access_data} method returns a data structure that looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{"defunkt"=>[nil],\line
 "tpw"=>[nil],\line
 "nickh"=>[nil],\line
 "pjhyett"=>[nil],\line
 "schacon"=>["lib", "tests"],\line
 "cdickens"=>["doc"],\line
 "usinclair"=>["doc"],\line
 "ebronte"=>["doc"]\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have the permissions sorted out, you need to determine what paths the commits being pushed have modified, so you can make sure the user who\u8217's pushing has access to all of them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can pretty easily see what files have been modified in a single commit with the {\f1 --name-only} option to the {\f1 git log} command (mentioned briefly in Chapter 2):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -1 --name-only --pretty=format:'' 9f585d\line
\line
README\line
lib/test.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you use the ACL structure returned from the {\f1 get_acl_access_data} method and check it against the listed files in each of the commits, you can determine whether the user has access to push all of their commits:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # only allows certain users to modify certain subdirectories in a project\line
def check_directory_perms\line
  access = get_acl_access_data('acl')\line
\line
  # see if anyone is trying to push something they can't\line
  new_commits = `git rev-list #\{$oldrev\}..#\{$newrev\}`.split("\\n")\line
  new_commits.each do |rev|\line
    files_modified = `git log -1 --name-only --pretty=format:'' #\{rev\}`.split("\\n")\line
    files_modified.each do |path|\line
      next if path.size == 0\line
      has_file_access = false\line
      access[$user].each do |access_path|\line
        if !access_path || # user has access to everything\line
          (path.index(access_path) == 0) # access to this path\line
          has_file_access = true\line
        end\line
      end\line
      if !has_file_access\line
        puts "[POLICY] You do not have access to push to #\{path\}"\line
        exit 1\line
      end\line
    end\line
  end\line
end\line
\line
check_directory_perms\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Most of that should be easy to follow. You get a list of new commits being pushed to your server with {\f1 git rev-list}. Then, for each of those, you find which files are modified and make sure the user who\u8217's pushing has access to all the paths being modified. One Rubyism that may not be clear is {\f1 path.index(access_path) == 0}, which is true if path begins with {\f1 access_path} \u8212- this ensures that {\f1 access_path} is not just in one of the allowed paths, but an allowed path begins with each accessed path.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now your users can\u8217't push any commits with badly formed messages or with modified files outside of their designated paths.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Enforcing Fast-Forward-Only Pushes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The only thing left is to enforce fast-forward-only pushes. In Git versions 1.6 or newer, you can set the {\f1 receive.denyDeletes} and {\f1 receive.denyNonFastForwards} settings. But enforcing this with a hook will work in older versions of Git, and you can modify it to do so only for certain users or whatever else you come up with later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The logic for checking this is to see if any commits are reachable from the older revision that aren\u8217't reachable from the newer one. If there are none, then it was a fast-forward push; otherwise, you deny it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # enforces fast-forward only pushes\line
def check_fast_forward\line
  missed_refs = `git rev-list #\{$newrev\}..#\{$oldrev\}`\line
  missed_ref_count = missed_refs.split("\\n").size\line
  if missed_ref_count > 0\line
    puts "[POLICY] Cannot push a non fast-forward reference"\line
    exit 1\line
  end\line
end\line
\line
check_fast_forward\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Everything is set up. If you run {\f1 chmod u+x .git/hooks/update}, which is the file into which you should have put all this code, and then try to push a non-fast-forward reference, you\u8217'll get something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push -f origin master\line
Counting objects: 5, done.\line
Compressing objects: 100% (3/3), done.\line
Writing objects: 100% (3/3), 323 bytes, done.\line
Total 3 (delta 1), reused 0 (delta 0)\line
Unpacking objects: 100% (3/3), done.\line
Enforcing Policies...\line
(refs/heads/master) (8338c5) (c5b616)\line
[POLICY] Cannot push a non fast-forward reference\line
error: hooks/update exited with error code 1\line
error: hook declined to update refs/heads/master\line
To git@gitserver:project.git\line
 ! [remote rejected] master -> master (hook declined)\line
error: failed to push some refs to 'git@gitserver:project.git'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are a couple of interesting things here. First, you see this where the hook starts running.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Enforcing Policies...\line
(refs/heads/master) (8338c5) (c5b616)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that you printed that out to stdout at the very beginning of your update script. It\u8217's important to note that anything your script prints to stdout will be transferred to the client.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next thing you\u8217'll notice is the error message.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [POLICY] Cannot push a non fast-forward reference\line
error: hooks/update exited with error code 1\line
error: hook declined to update refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first line was printed out by you, the other two were Git telling you that the update script exited non-zero and that is what is declining your push. Lastly, you have this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 To git@gitserver:project.git\line
 ! [remote rejected] master -> master (hook declined)\line
error: failed to push some refs to 'git@gitserver:project.git'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll see a remote rejected message for each reference that your hook declined, and it tells you that it was declined specifically because of a hook failure.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Furthermore, if the ref marker isn\u8217't there in any of your commits, you\u8217'll see the error message you\u8217're printing out for that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [POLICY] Your message is not formatted correctly\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Or if someone tries to edit a file they don\u8217't have access to and push a commit containing it, they will see something similar. For instance, if a documentation author tries to push a commit modifying something in the {\f1 lib} directory, they see\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [POLICY] You do not have access to push to lib/test.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's all. From now on, as long as that {\f1 update} script is there and executable, your repository will never be rewound and will never have a commit message without your pattern in it, and your users will be sandboxed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Client-Side Hooks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The downside to this approach is the whining that will inevitably result when your users\u8217' commit pushes are rejected. Having their carefully crafted work rejected at the last minute can be extremely frustrating and confusing; and furthermore, they will have to edit their history to correct it, which isn\u8217't always for the faint of heart.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The answer to this dilemma is to provide some client-side hooks that users can use to notify them when they\u8217're doing something that the server is likely to reject. That way, they can correct any problems before committing and before those issues become more difficult to fix. Because hooks aren\u8217't transferred with a clone of a project, you must distribute these scripts some other way and then have your users copy them to their {\f1 .git/hooks} directory and make them executable. You can distribute these hooks within the project or in a separate project, but there is no way to set them up automatically.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To begin, you should check your commit message just before each commit is recorded, so you know the server won\u8217't reject your changes due to badly formatted commit messages. To do this, you can add the {\f1 commit-msg} hook. If you have it read the message from the file passed as the first argument and compare that to the pattern, you can force Git to abort the commit if there is no match:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #!/usr/bin/env ruby\line
message_file = ARGV[0]\line
message = File.read(message_file)\line
\line
$regex = /\\[ref: (\\d+)\\]/\line
\line
if !$regex.match(message)\line
  puts "[POLICY] Your message is not formatted correctly"\line
  exit 1\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If that script is in place (in {\f1 .git/hooks/commit-msg}) and executable, and you commit with a message that isn\u8217't properly formatted, you see this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -am 'test'\line
[POLICY] Your message is not formatted correctly\par}
{\pard \ql \f0 \sa180 \li0 \fi0 No commit was completed in that instance. However, if your message contains the proper pattern, Git allows you to commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -am 'test [ref: 132]'\line
[master e05c914] test [ref: 132]\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you want to make sure you aren\u8217't modifying files that are outside your ACL scope. If your project\u8217's {\f1 .git} directory contains a copy of the ACL file you used previously, then the following {\f1 pre-commit} script will enforce those constraints for you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #!/usr/bin/env ruby\line
\line
$user    = ENV['USER']\line
\line
# [ insert acl_access_data method from above ]\line
\line
# only allows certain users to modify certain subdirectories in a project\line
def check_directory_perms\line
  access = get_acl_access_data('.git/acl')\line
\line
  files_modified = `git diff-index --cached --name-only HEAD`.split("\\n")\line
  files_modified.each do |path|\line
    next if path.size == 0\line
    has_file_access = false\line
    access[$user].each do |access_path|\line
    if !access_path || (path.index(access_path) == 0)\line
      has_file_access = true\line
    end\line
    if !has_file_access\line
      puts "[POLICY] You do not have access to push to #\{path\}"\line
      exit 1\line
    end\line
  end\line
end\line
\line
check_directory_perms\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is roughly the same script as the server-side part, but with two important differences. First, the ACL file is in a different place, because this script runs from your working directory, not from your Git directory. You have to change the path to the ACL file from this\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 access = get_acl_access_data('acl')\par}
{\pard \ql \f0 \sa180 \li0 \fi0 to this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 access = get_acl_access_data('.git/acl')\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other important difference is the way you get a listing of the files that have been changed. Because the server-side method looks at the log of commits, and, at this point, the commit hasn\u8217't been recorded yet, you must get your file listing from the staging area instead. Instead of\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 files_modified = `git log -1 --name-only --pretty=format:'' #\{ref\}`\par}
{\pard \ql \f0 \sa180 \li0 \fi0 you have to use\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 files_modified = `git diff-index --cached --name-only HEAD`\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But those are the only two differences \u8212- otherwise, the script works the same way. One caveat is that it expects you to be running locally as the same user you push as to the remote machine. If that is different, you must set the {\f1 $user} variable manually.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last thing you have to do is check that you\u8217're not trying to push non-fast-forwarded references, but that is a bit less common. To get a reference that isn\u8217't a fast-forward, you either have to rebase past a commit you\u8217've already pushed up or try pushing a different local branch up to the same remote branch.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because the server will tell you that you can\u8217't push a non-fast-forward anyway, and the hook prevents forced pushes, the only accidental thing you can try to catch is rebasing commits that have already been pushed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here is an example pre-rebase script that checks for that. It gets a list of all the commits you\u8217're about to rewrite and checks whether they exist in any of your remote references. If it sees one that is reachable from one of your remote references, it aborts the rebase:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 #!/usr/bin/env ruby\line
\line
base_branch = ARGV[0]\line
if ARGV[1]\line
  topic_branch = ARGV[1]\line
else\line
  topic_branch = "HEAD"\line
end\line
\line
target_shas = `git rev-list #\{base_branch\}..#\{topic_branch\}`.split("\\n")\line
remote_refs = `git branch -r`.split("\\n").map \{ |r| r.strip \}\line
\line
target_shas.each do |sha|\line
  remote_refs.each do |remote_ref|\line
    shas_pushed = `git rev-list ^#\{sha\}^@ refs/remotes/#\{remote_ref\}`\line
    if shas_pushed.split("\\n").include?(sha)\line
      puts "[POLICY] Commit #\{sha\} has already been pushed to #\{remote_ref\}"\line
      exit 1\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This script uses a syntax that wasn\u8217't covered in the Revision Selection section of Chapter 6. You get a list of commits that have already been pushed up by running this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 git rev-list ^#\{sha\}^@ refs/remotes/#\{remote_ref\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 SHA^@} syntax resolves to all the parents of that commit. You\u8217're looking for any commit that is reachable from the last commit on the remote and that isn\u8217't reachable from any parent of any of the SHAs you\u8217're trying to push up \u8212- meaning it\u8217's a fast-forward.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The main drawback to this approach is that it can be very slow and is often unnecessary \u8212- if you don\u8217't try to force the push with {\f1 -f}, the server will warn you and not accept the push. However, it\u8217's an interesting exercise and can in theory help you avoid a rebase that you might later have to go back and fix.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217've covered most of the major ways that you can customize your Git client and server to best fit your workflow and projects. You\u8217've learned about all sorts of configuration settings, file-based attributes, and event hooks, and you\u8217've built an example policy-enforcing server. You should now be able to make Git fit nearly any workflow you can dream up.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git and Other Systems\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The world isn\u8217't perfect. Usually, you can\u8217't immediately switch every project you come in contact with to Git. Sometimes you\u8217're stuck on a project using another VCS, and many times that system is Subversion. You\u8217'll spend the first part of this chapter learning about {\f1 git svn}, the bidirectional Subversion gateway tool in Git.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At some point, you may want to convert your existing project to Git. The second part of this chapter covers how to migrate your project into Git: first from Subversion, then from Perforce, and finally via a custom import script for a nonstandard importing case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git and Subversion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Currently, the majority of open source development projects and a large number of corporate projects use Subversion to manage their source code. It\u8217's the most popular open source VCS and has been around for nearly a decade. It\u8217's also very similar in many ways to CVS, which was the big boy of the source-control world before that.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of Git\u8217's great features is a bidirectional bridge to Subversion called {\f1 git svn}. This tool allows you to use Git as a valid client to a Subversion server, so you can use all the local features of Git and then push to a Subversion server as if you were using Subversion locally. This means you can do local branching and merging, use the staging area, use rebasing and cherry-picking, and so on, while your collaborators continue to work in their dark and ancient ways. It\u8217's a good way to sneak Git into the corporate environment and help your fellow developers become more efficient while you lobby to get the infrastructure changed to support Git fully. The Subversion bridge is the gateway drug to the DVCS world.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 git svn\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The base command in Git for all the Subversion bridging commands is {\f1 git svn}. You preface everything with that. It takes quite a few commands, so you\u8217'll learn about the common ones while going through a few small workflows.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note that when you\u8217're using {\f1 git svn}, you\u8217're interacting with Subversion, which is a system that is far less sophisticated than Git. Although you can easily do local branching and merging, it\u8217's generally best to keep your history as linear as possible by rebasing your work and avoiding doing things like simultaneously interacting with a Git remote repository.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Don\u8217't rewrite your history and try to push again, and don\u8217't push to a parallel Git repository to collaborate with fellow Git developers at the same time. Subversion can have only a single linear history, and confusing it is very easy. If you\u8217're working with a team, and some are using SVN and others are using Git, make sure everyone is using the SVN server to collaborate \u8212- doing so will make your life easier.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Setting Up\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To demonstrate this functionality, you need a typical SVN repository that you have write access to. If you want to copy these examples, you\u8217'll have to make a writeable copy of my test repository. In order to do that easily, you can use a tool called {\f1 svnsync} that comes with more recent versions of Subversion \u8212- it should be distributed with at least 1.4. For these tests, I created a new Subversion repository on Google code that was a partial copy of the {\f1 protobuf} project, which is a tool that encodes structured data for network transmission.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To follow along, you first need to create a new local Subversion repository:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ mkdir /tmp/test-svn\line
$ svnadmin create /tmp/test-svn\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, enable all users to change revprops \u8212- the easy way is to add a pre-revprop-change script that always exits 0:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat /tmp/test-svn/hooks/pre-revprop-change\line
#!/bin/sh\line
exit 0;\line
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can now sync this project to your local machine by calling {\f1 svnsync init} with the to and from repositories.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ svnsync init file:///tmp/test-svn http://progit-example.googlecode.com/svn/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This sets up the properties to run the sync. You can then clone the code by running\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ svnsync sync file:///tmp/test-svn\line
Committed revision 1.\line
Copied properties for revision 1.\line
Committed revision 2.\line
Copied properties for revision 2.\line
Committed revision 3.\line
...\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although this operation may take only a few minutes, if you try to copy the original repository to another remote repository instead of a local one, the process will take nearly an hour, even though there are fewer than 100 commits. Subversion has to clone one revision at a time and then push it back into another repository \u8212- it\u8217's ridiculously inefficient, but it\u8217's the only easy way to do this.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Getting Started\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have a Subversion repository to which you have write access, you can go through a typical workflow. You\u8217'll start with the {\f1 git svn clone} command, which imports an entire Subversion repository into a local Git repository. Remember that if you\u8217're importing from a real hosted Subversion repository, you should replace the {\f1 file:///tmp/test-svn} here with the URL of your Subversion repository:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags\line
Initialized empty Git repository in /Users/schacon/projects/testsvnsync/svn/.git/\line
r1 = b4e387bc68740b5af56c2a5faf4003ae42bd135c (trunk)\line
      A    m4/acx_pthread.m4\line
      A    m4/stl_hash.m4\line
...\line
r75 = d1957f3b307922124eec6314e15bcda59e3d9610 (trunk)\line
Found possible branch point: file:///tmp/test-svn/trunk => \\\line
    file:///tmp/test-svn /branches/my-calc-branch, 75\line
Found branch parent: (my-calc-branch) d1957f3b307922124eec6314e15bcda59e3d9610\line
Following parent with do_switch\line
Successfully followed parent\line
r76 = 8624824ecc0badd73f40ea2f01fce51894189b01 (my-calc-branch)\line
Checked out HEAD:\line
 file:///tmp/test-svn/branches/my-calc-branch r76\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This runs the equivalent of two commands \u8212- {\f1 git svn init} followed by {\f1 git svn fetch} \u8212- on the URL you provide. This can take a while. The test project has only about 75 commits and the codebase isn\u8217't that big, so it takes just a few minutes. However, Git has to check out each version, one at a time, and commit it individually. For a project with hundreds or thousands of commits, this can literally take hours or even days to finish.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 -T trunk -b branches -t tags} part tells Git that this Subversion repository follows the basic branching and tagging conventions. If you name your trunk, branches, or tags differently, you can change these options. Because this is so common, you can replace this entire part with {\f1 -s}, which means standard layout and implies all those options. The following command is equivalent:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn clone file:///tmp/test-svn -s\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, you should have a valid Git repository that has imported your branches and tags:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -a\line
* master\line
  my-calc-branch\line
  tags/2.0.2\line
  tags/release-2.0.1\line
  tags/release-2.0.2\line
  tags/release-2.0.2rc1\line
  trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to note how this tool namespaces your remote references differently. When you\u8217're cloning a normal Git repository, you get all the branches on that remote server available locally as something like {\f1 origin/[branch]} - namespaced by the name of the remote. However, {\f1 git svn} assumes that you won\u8217't have multiple remotes and saves all its references to points on the remote server with no namespacing. You can use the Git plumbing command {\f1 show-ref} to look at all your full reference names:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show-ref\line
1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/heads/master\line
aee1ecc26318164f355a883f5d99cff0c852d3c4 refs/remotes/my-calc-branch\line
03d09b0e2aad427e34a6d50ff147128e76c0e0f5 refs/remotes/tags/2.0.2\line
50d02cc0adc9da4319eeba0900430ba219b9c376 refs/remotes/tags/release-2.0.1\line
4caaa711a50c77879a91b8b90380060f672745cb refs/remotes/tags/release-2.0.2\line
1c4cb508144c513ff1214c3488abe66dcb92916f refs/remotes/tags/release-2.0.2rc1\line
1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/remotes/trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A normal Git repository looks more like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git show-ref\line
83e38c7a0af325a9722f2fdc56b10188806d83a1 refs/heads/master\line
3e15e38c198baac84223acfc6224bb8b99ff2281 refs/remotes/gitserver/master\line
0a30dd3b0c795b80212ae723640d4e5d48cabdff refs/remotes/origin/master\line
25812380387fdd55f916652be4881c6f11600d6f refs/remotes/origin/testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have two remote servers: one named {\f1 gitserver} with a {\f1 master} branch; and another named {\f1 origin} with two branches, {\f1 master} and {\f1 testing}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice how in the example of remote references imported from {\f1 git svn}, tags are added as remote branches, not as real Git tags. Your Subversion import looks like it has a remote named tags with branches under it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Committing Back to Subversion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have a working repository, you can do some work on the project and push your commits back upstream, using Git effectively as a SVN client. If you edit one of the files and commit it, you have a commit that exists in Git locally that doesn\u8217't exist on the Subversion server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git commit -am 'Adding git-svn instructions to the README'\line
[master 97031e5] Adding git-svn instructions to the README\line
 1 files changed, 1 insertions(+), 1 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you need to push your change upstream. Notice how this changes the way you work with Subversion \u8212- you can do several commits offline and then push them all at once to the Subversion server. To push to a Subversion server, you run the {\f1 git svn dcommit} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn dcommit\line
Committing to file:///tmp/test-svn/trunk ...\line
       M      README.txt\line
Committed r79\line
       M      README.txt\line
r79 = 938b1a547c2cc92033b74d32030e86468294a5c8 (trunk)\line
No changes between current HEAD and refs/remotes/trunk\line
Resetting to the latest refs/remotes/trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This takes all the commits you\u8217've made on top of the Subversion server code, does a Subversion commit for each, and then rewrites your local Git commit to include a unique identifier. This is important because it means that all the SHA-1 checksums for your commits change. Partly for this reason, working with Git-based remote versions of your projects concurrently with a Subversion server isn\u8217't a good idea. If you look at the last commit, you can see the new {\f1 git-svn-id} that was added:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -1\line
commit 938b1a547c2cc92033b74d32030e86468294a5c8\line
Author: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\line
Date:   Sat May 2 22:06:44 2009 +0000\line
\line
    Adding git-svn instructions to the README\line
\line
    git-svn-id: file:///tmp/test-svn/trunk@79 4c93b258-373f-11de-be05-5f7a86268029\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that the SHA checksum that originally started with {\f1 97031e5} when you committed now begins with {\f1 938b1a5}. If you want to push to both a Git server and a Subversion server, you have to push ({\f1 dcommit}) to the Subversion server first, because that action changes your commit data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pulling in New Changes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're working with other developers, then at some point one of you will push, and then the other one will try to push a change that conflicts. That change will be rejected until you merge in their work. In {\f1 git svn}, it looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn dcommit\line
Committing to file:///tmp/test-svn/trunk ...\line
Merge conflict during commit: Your file or directory 'README.txt' is probably \\\line
out-of-date: resource out of date; try updating at /Users/schacon/libexec/git-\\\line
core/git-svn line 482\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To resolve this situation, you can run {\f1 git svn rebase}, which pulls down any changes on the server that you don\u8217't have yet and rebases any work you have on top of what is on the server:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn rebase\line
       M      README.txt\line
r80 = ff829ab914e8775c7c025d741beb3d523ee30bc4 (trunk)\line
First, rewinding head to replay your work on top of it...\line
Applying: first user change\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, all your work is on top of what is on the Subversion server, so you can successfully {\f1 dcommit}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn dcommit\line
Committing to file:///tmp/test-svn/trunk ...\line
       M      README.txt\line
Committed r81\line
       M      README.txt\line
r81 = 456cbe6337abe49154db70106d1836bc1332deed (trunk)\line
No changes between current HEAD and refs/remotes/trunk\line
Resetting to the latest refs/remotes/trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's important to remember that unlike Git, which requires you to merge upstream work you don\u8217't yet have locally before you can push, {\f1 git svn} makes you do that only if the changes conflict. If someone else pushes a change to one file and then you push a change to another file, your {\f1 dcommit} will work fine:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn dcommit\line
Committing to file:///tmp/test-svn/trunk ...\line
       M      configure.ac\line
Committed r84\line
       M      autogen.sh\line
r83 = 8aa54a74d452f82eee10076ab2584c1fc424853b (trunk)\line
       M      configure.ac\line
r84 = cdbac939211ccb18aa744e581e46563af5d962d0 (trunk)\line
W: d2f23b80f67aaaa1f6f5aaef48fce3263ac71a92 and refs/remotes/trunk differ, \\\line
  using rebase:\line
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 \\\line
  015e4c98c482f0fa71e4d5434338014530b37fa6 M   autogen.sh\line
First, rewinding head to replay your work on top of it...\line
Nothing to do.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is important to remember, because the outcome is a project state that didn\u8217't exist on either of your computers when you pushed. If the changes are incompatible but don\u8217't conflict, you may get issues that are difficult to diagnose. This is different than using a Git server \u8212- in Git, you can fully test the state on your client system before publishing it, whereas in SVN, you can\u8217't ever be certain that the states immediately before commit and after commit are identical.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should also run this command to pull in changes from the Subversion server, even if you\u8217're not ready to commit yourself. You can run {\f1 git svn fetch} to grab the new data, but {\f1 git svn rebase} does the fetch and then updates your local commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn rebase\line
       M      generate_descriptor_proto.sh\line
r82 = bd16df9173e424c6f52c337ab6efa7f7643282f1 (trunk)\line
First, rewinding head to replay your work on top of it...\line
Fast-forwarded master to refs/remotes/trunk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Running {\f1 git svn rebase} every once in a while makes sure your code is always up to date. You need to be sure your working directory is clean when you run this, though. If you have local changes, you must either stash your work or temporarily commit it before running {\f1 git svn rebase} \u8212- otherwise, the command will stop if it sees that the rebase will result in a merge conflict.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Git Branching Issues\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you\u8217've become comfortable with a Git workflow, you\u8217'll likely create topic branches, do work on them, and then merge them in. If you\u8217're pushing to a Subversion server via git svn, you may want to rebase your work onto a single branch each time instead of merging branches together. The reason to prefer rebasing is that Subversion has a linear history and doesn\u8217't deal with merges like Git does, so git svn follows only the first parent when converting the snapshots into Subversion commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Suppose your history looks like the following: you created an {\f1 experiment} branch, did two commits, and then merged them back into {\f1 master}. When you {\f1 dcommit}, you see output like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn dcommit\line
Committing to file:///tmp/test-svn/trunk ...\line
       M      CHANGES.txt\line
Committed r85\line
       M      CHANGES.txt\line
r85 = 4bfebeec434d156c36f2bcd18f4e3d97dc3269a2 (trunk)\line
No changes between current HEAD and refs/remotes/trunk\line
Resetting to the latest refs/remotes/trunk\line
COPYING.txt: locally modified\line
INSTALL.txt: locally modified\line
       M      COPYING.txt\line
       M      INSTALL.txt\line
Committed r86\line
       M      INSTALL.txt\line
       M      COPYING.txt\line
r86 = 2647f6b86ccfcaad4ec58c520e369ec81f7c283c (trunk)\line
No changes between current HEAD and refs/remotes/trunk\line
Resetting to the latest refs/remotes/trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Running {\f1 dcommit} on a branch with merged history works fine, except that when you look at your Git project history, it hasn\u8217't rewritten either of the commits you made on the {\f1 experiment} branch \u8212- instead, all those changes appear in the SVN version of the single merge commit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When someone else clones that work, all they see is the merge commit with all the work squashed into it; they don\u8217't see the commit data about where it came from or when it was committed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Subversion Branching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Branching in Subversion isn\u8217't the same as branching in Git; if you can avoid using it much, that\u8217's probably best. However, you can create and commit to branches in Subversion using git svn.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Creating a New SVN Branch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To create a new branch in Subversion, you run {\f1 git svn branch [branchname]}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn branch opera\line
Copying file:///tmp/test-svn/trunk at r87 to file:///tmp/test-svn/branches/opera...\line
Found possible branch point: file:///tmp/test-svn/trunk => \\\line
  file:///tmp/test-svn/branches/opera, 87\line
Found branch parent: (opera) 1f6bfe471083cbca06ac8d4176f7ad4de0d62e5f\line
Following parent with do_switch\line
Successfully followed parent\line
r89 = 9b6fe0b90c5c9adf9165f700897518dbc54a7cbf (opera)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This does the equivalent of the {\f1 svn copy trunk branches/opera} command in Subversion and operates on the Subversion server. It\u8217's important to note that it doesn\u8217't check you out into that branch; if you commit at this point, that commit will go to {\f1 trunk} on the server, not {\f1 opera}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Switching Active Branches\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git figures out what branch your dcommits go to by looking for the tip of any of your Subversion branches in your history \u8212- you should have only one, and it should be the last one with a {\f1 git-svn-id} in your current branch history.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want to work on more than one branch simultaneously, you can set up local branches to {\f1 dcommit} to specific Subversion branches by starting them at the imported Subversion commit for that branch. If you want an {\f1 opera} branch that you can work on separately, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch opera remotes/opera\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, if you want to merge your {\f1 opera} branch into {\f1 trunk} (your {\f1 master} branch), you can do so with a normal {\f1 git merge}. But you need to provide a descriptive commit message (via {\f1 -m}), or the merge will say \u8220"Merge branch opera\u8221" instead of something useful.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember that although you\u8217're using {\f1 git merge} to do this operation, and the merge likely will be much easier than it would be in Subversion (because Git will automatically detect the appropriate merge base for you), this isn\u8217't a normal Git merge commit. You have to push this data back to a Subversion server that can\u8217't handle a commit that tracks more than one parent; so, after you push it up, it will look like a single commit that squashed in all the work of another branch under a single commit. After you merge one branch into another, you can\u8217't easily go back and continue working on that branch, as you normally can in Git. The {\f1 dcommit} command that you run erases any information that says what branch was merged in, so subsequent merge-base calculations will be wrong \u8212- the dcommit makes your {\f1 git merge} result look like you ran {\f1 git merge --squash}. Unfortunately, there\u8217's no good way to avoid this situation \u8212- Subversion can\u8217't store this information, so you\u8217'll always be crippled by its limitations while you\u8217're using it as your server. To avoid issues, you should delete the local branch (in this case, {\f1 opera}) after you merge it into trunk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Subversion Commands\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 git svn} toolset provides a number of commands to help ease the transition to Git by providing some functionality that\u8217's similar to what you had in Subversion. Here are a few commands that give you what Subversion used to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 SVN Style History\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're used to Subversion and want to see your history in SVN output style, you can run {\f1 git svn log} to view your commit history in SVN formatting:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn log\line
------------------------------------------------------------------------\line
r87 | schacon | 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009) | 2 lines\line
\line
autogen change\line
\line
------------------------------------------------------------------------\line
r86 | schacon | 2009-05-02 16:00:21 -0700 (Sat, 02 May 2009) | 2 lines\line
\line
Merge branch 'experiment'\line
\line
------------------------------------------------------------------------\line
r85 | schacon | 2009-05-02 16:00:09 -0700 (Sat, 02 May 2009) | 2 lines\line
\line
updated the changelog\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should know two important things about {\f1 git svn log}. First, it works offline, unlike the real {\f1 svn log} command, which asks the Subversion server for the data. Second, it only shows you commits that have been committed up to the Subversion server. Local Git commits that you haven\u8217't dcommited don\u8217't show up; neither do commits that people have made to the Subversion server in the meantime. It\u8217's more like the last known state of the commits on the Subversion server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 SVN Annotation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Much as the {\f1 git svn log} command simulates the {\f1 svn log} command offline, you can get the equivalent of {\f1 svn annotate} by running {\f1 git svn blame [FILE]}. The output looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn blame README.txt\line
 2   temporal Protocol Buffers - Google's data interchange format\line
 2   temporal Copyright 2008 Google Inc.\line
 2   temporal http://code.google.com/apis/protocolbuffers/\line
 2   temporal\line
22   temporal C++ Installation - Unix\line
22   temporal =======================\line
 2   temporal\line
79    schacon Committing in git-svn.\line
78    schacon\line
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol\line
 2   temporal Buffer compiler (protoc) execute the following:\line
 2   temporal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, it doesn\u8217't show commits that you did locally in Git or that have been pushed to Subversion in the meantime.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 SVN Server Information\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also get the same sort of information that {\f1 svn info} gives you by running {\f1 git svn info}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn info\line
Path: .\line
URL: https://schacon-test.googlecode.com/svn/trunk\line
Repository Root: https://schacon-test.googlecode.com/svn\line
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029\line
Revision: 87\line
Node Kind: directory\line
Schedule: normal\line
Last Changed Author: schacon\line
Last Changed Rev: 87\line
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is like {\f1 blame} and {\f1 log} in that it runs offline and is up to date only as of the last time you communicated with the Subversion server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Ignoring What Subversion Ignores\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you clone a Subversion repository that has {\f1 svn:ignore} properties set anywhere, you\u8217'll likely want to set corresponding {\f1 .gitignore} files so you don\u8217't accidentally commit files that you shouldn\u8217't. {\f1 git svn} has two commands to help with this issue. The first is {\f1 git svn create-ignore}, which automatically creates corresponding {\f1 .gitignore} files for you so your next commit can include them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The second command is {\f1 git svn show-ignore}, which prints to stdout the lines you need to put in a {\f1 .gitignore} file so you can redirect the output into your project exclude file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git svn show-ignore > .git/info/exclude\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That way, you don\u8217't litter the project with {\f1 .gitignore} files. This is a good option if you\u8217're the only Git user on a Subversion team, and your teammates don\u8217't want {\f1 .gitignore} files in the project.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Git-Svn Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 git svn} tools are useful if you\u8217're stuck with a Subversion server for now or are otherwise in a development environment that necessitates running a Subversion server. You should consider it crippled Git, however, or you\u8217'll hit issues in translation that may confuse you and your collaborators. To stay out of trouble, try to follow these guidelines:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Keep a linear Git history that doesn\u8217't contain merge commits made by {\f1 git merge}. Rebase any work you do outside of your mainline branch back onto it; don\u8217't merge it in.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Don\u8217't set up and collaborate on a separate Git server. Possibly have one to speed up clones for new developers, but don\u8217't push anything to it that doesn\u8217't have a {\f1 git-svn-id} entry. You may even want to add a {\f1 pre-receive} hook that checks each commit message for a {\f1 git-svn-id} and rejects pushes that contain commits without it.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you follow those guidelines, working with a Subversion server can be more bearable. However, if it\u8217's possible to move to a real Git server, doing so can gain your team a lot more.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Migrating to Git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have an existing codebase in another VCS but you\u8217've decided to start using Git, you must migrate your project one way or another. This section goes over some importers that are included with Git for common systems and then demonstrates how to develop your own custom importer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Importing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll learn how to import data from two of the bigger professionally used SCM systems \u8212- Subversion and Perforce \u8212- both because they make up the majority of users I hear of who are currently switching, and because high-quality tools for both systems are distributed with Git.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Subversion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you read the previous section about using {\f1 git svn}, you can easily use those instructions to {\f1 git svn clone} a repository; then, stop using the Subversion server, push to a new Git server, and start using that. If you want the history, you can accomplish that as quickly as you can pull the data out of the Subversion server (which may take a while).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, the import isn\u8217't perfect; and because it will take so long, you may as well do it right. The first problem is the author information. In Subversion, each person committing has a user on the system who is recorded in the commit information. The examples in the previous section show {\f1 schacon} in some places, such as the {\f1 blame} output and the {\f1 git svn log}. If you want to map this to better Git author data, you need a mapping from the Subversion users to the Git authors. Create a file called {\f1 users.txt} that has this mapping in a format like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 schacon = Scott Chacon <schacon@geemail.com>\line
selse = Someo Nelse <selse@geemail.com>\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To get a list of the author names that SVN uses, you can run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ svn log --xml | grep -P "^<author" | sort -u | \\\line
      perl -pe 's/<author>(.*?)<\\/author>/$1 = /'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That gives you the log output in XML format \u8212- you can look for the authors, create a unique list, and then strip out the XML. (Obviously this only works on a machine with {\f1 grep}, {\f1 sort}, and {\f1 perl} installed.) Then, redirect that output into your users.txt file so you can add the equivalent Git user data next to each entry.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can provide this file to {\f1 git svn} to help it map the author data more accurately. You can also tell {\f1 git svn} not to include the metadata that Subversion normally imports, by passing {\f1 --no-metadata} to the {\f1 clone} or {\f1 init} command. This makes your {\f1 import} command look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git-svn clone http://my-project.googlecode.com/svn/ \\\line
      --authors-file=users.txt --no-metadata -s my_project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you should have a nicer Subversion import in your {\f1 my_project} directory. Instead of commits that look like this\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 commit 37efa680e8473b615de980fa935944215428a35a\line
Author: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>\line
Date:   Sun May 3 00:12:22 2009 +0000\line
\line
    fixed install - go to trunk\line
\line
    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-\line
    be05-5f7a86268029\par}
{\pard \ql \f0 \sa180 \li0 \fi0 they look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2\line
Author: Scott Chacon <schacon@geemail.com>\line
Date:   Sun May 3 00:12:22 2009 +0000\line
\line
    fixed install - go to trunk\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Not only does the Author field look a lot better, but the {\f1 git-svn-id} is no longer there, either.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You need to do a bit of {\f1 post-import} cleanup. For one thing, you should clean up the weird references that {\f1 git svn} set up. First you\u8217'll move the tags so they\u8217're actual tags rather than strange remote branches, and then you\u8217'll move the rest of the branches so they\u8217're local.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To move the tags to be proper Git tags, run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while read tagname; do git tag "$tagname" "tags/$tagname"; git branch -r -d "tags/$tagname"; done\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This takes the references that were remote branches that started with {\f1 tag/} and makes them real (lightweight) tags.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, move the rest of the references under {\f1 refs/remotes} to be local branches:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read branchname; do git branch "$branchname" "refs/remotes/$branchname"; git branch -r -d "$branchname"; done\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now all the old branches are real Git branches and all the old tags are real Git tags. The last thing to do is add your new Git server as a remote and push to it. Here is an example of adding your server as a remote:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add origin git@my-git-server:myrepository.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because you want all your branches and tags to go up, you can now run this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin --all\line
$ git push origin --tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All your branches and tags should be on your new Git server in a nice, clean import.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Perforce\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next system you\u8217'll look at importing from is Perforce. A Perforce importer is also distributed with Git, but only in the {\f1 contrib} section of the source code \u8212- it isn\u8217't available by default like {\f1 git svn}. To run it, you must get the Git source code, which you can download from git.kernel.org:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone git://git.kernel.org/pub/scm/git/git.git\line
$ cd git/contrib/fast-import\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this {\f1 fast-import} directory, you should find an executable Python script named {\f1 git-p4}. You must have Python and the {\f1 p4} tool installed on your machine for this import to work. For example, you\u8217'll import the Jam project from the Perforce Public Depot. To set up your client, you must export the P4PORT environment variable to point to the Perforce depot:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ export P4PORT=public.perforce.com:1666\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Run the {\f1 git-p4 clone} command to import the Jam project from the Perforce server, supplying the depot and project path and the path into which you want to import the project:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git-p4 clone //public/jam/src@all /opt/p4import\line
Importing from //public/jam/src@all into /opt/p4import\line
Reinitialized existing Git repository in /opt/p4import/.git/\line
Import destination: refs/remotes/p4/master\line
Importing revision 4409 (100%)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you go to the {\f1 /opt/p4import} directory and run {\f1 git log}, you can see your imported work:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -2\line
commit 1fd4ec126171790efd2db83548b85b1bbbc07dc2\line
Author: Perforce staff <support@perforce.com>\line
Date:   Thu Aug 19 10:18:45 2004 -0800\line
\line
    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\line
    the main part of the document.  Built new tar/zip balls.\line
\line
    Only 16 months later.\line
\line
    [git-p4: depot-paths = "//public/jam/src/": change = 4409]\line
\line
commit ca8870db541a23ed867f38847eda65bf4363371d\line
Author: Richard Geiger <rmg@perforce.com>\line
Date:   Tue Apr 22 20:51:34 2003 -0800\line
\line
    Update derived jamgram.c\line
\line
    [git-p4: depot-paths = "//public/jam/src/": change = 3108]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see the {\f1 git-p4} identifier in each commit. It\u8217's fine to keep that identifier there, in case you need to reference the Perforce change number later. However, if you\u8217'd like to remove the identifier, now is the time to do so \u8212- before you start doing work on the new repository. You can use {\f1 git filter-branch} to remove the identifier strings en masse:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git filter-branch --msg-filter '\line
        sed -e "/^\\[git-p4:/d"\line
'\line
Rewrite 1fd4ec126171790efd2db83548b85b1bbbc07dc2 (123/123)\line
Ref 'refs/heads/master' was rewritten\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run {\f1 git log}, you can see that all the SHA-1 checksums for the commits have changed, but the {\f1 git-p4} strings are no longer in the commit messages:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -2\line
commit 10a16d60cffca14d454a15c6164378f4082bc5b0\line
Author: Perforce staff <support@perforce.com>\line
Date:   Thu Aug 19 10:18:45 2004 -0800\line
\line
    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into\line
    the main part of the document.  Built new tar/zip balls.\line
\line
    Only 16 months later.\line
\line
commit 2b6c6db311dd76c34c66ec1c40a49405e6b527b2\line
Author: Richard Geiger <rmg@perforce.com>\line
Date:   Tue Apr 22 20:51:34 2003 -0800\line
\line
    Update derived jamgram.c\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your import is ready to push up to your new Git server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 A Custom Importer\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If your system isn\u8217't Subversion or Perforce, you should look for an importer online \u8212- quality importers are available for CVS, Clear Case, Visual Source Safe, even a directory of archives. If none of these tools works for you, you have a rarer tool, or you otherwise need a more custom importing process, you should use {\f1 git fast-import}. This command reads simple instructions from stdin to write specific Git data. It\u8217's much easier to create Git objects this way than to run the raw Git commands or try to write the raw objects (see Chapter 9 for more information). This way, you can write an import script that reads the necessary information out of the system you\u8217're importing from and prints straightforward instructions to stdout. You can then run this program and pipe its output through {\f1 git fast-import}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To quickly demonstrate, you\u8217'll write a simple importer. Suppose you work in current, you back up your project by occasionally copying the directory into a time-stamped {\f1 back_YYYY_MM_DD} backup directory, and you want to import this into Git. Your directory structure looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ls /opt/import_from\line
back_2009_01_02\line
back_2009_01_04\line
back_2009_01_14\line
back_2009_02_03\line
current\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In order to import a Git directory, you need to review how Git stores its data. As you may remember, Git is fundamentally a linked list of commit objects that point to a snapshot of content. All you have to do is tell {\f1 fast-import} what the content snapshots are, what commit data points to them, and the order they go in. Your strategy will be to go through the snapshots one at a time and create commits with the contents of each directory, linking each commit back to the previous one.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you did in the \u8220"An Example Git Enforced Policy\u8221" section of Chapter 7, we\u8217'll write this in Ruby, because it\u8217's what I generally work with and it tends to be easy to read. You can write this example pretty easily in anything you\u8217're familiar with \u8212- it just needs to print the appropriate information to stdout. And, if you are running on Windows, this means you\u8217'll need to take special care to not introduce carriage returns at the end your lines \u8212- git fast-import is very particular about just wanting line feeds (LF) not the carriage return line feeds (CRLF) that Windows uses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To begin, you\u8217'll change into the target directory and identify every subdirectory, each of which is a snapshot that you want to import as a commit. You\u8217'll change into each subdirectory and print the commands necessary to export it. Your basic main loop looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 last_mark = nil\line
\line
# loop through the directories\line
Dir.chdir(ARGV[0]) do\line
  Dir.glob("*").each do |dir|\line
    next if File.file?(dir)\line
\line
    # move into the target directory\line
    Dir.chdir(dir) do\line
      last_mark = print_export(dir, last_mark)\line
    end\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You run {\f1 print_export} inside each directory, which takes the manifest and mark of the previous snapshot and returns the manifest and mark of this one; that way, you can link them properly. \u8220"Mark\u8221" is the {\f1 fast-import} term for an identifier you give to a commit; as you create commits, you give each one a mark that you can use to link to it from other commits. So, the first thing to do in your {\f1 print_export} method is generate a mark from the directory name:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 mark = convert_dir_to_mark(dir)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll do this by creating an array of directories and using the index value as the mark, because a mark must be an integer. Your method looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $marks = []\line
def convert_dir_to_mark(dir)\line
  if !$marks.include?(dir)\line
    $marks << dir\line
  end\line
  ($marks.index(dir) + 1).to_s\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have an integer representation of your commit, you need a date for the commit metadata. Because the date is expressed in the name of the directory, you\u8217'll parse it out. The next line in your {\f1 print_export} file is\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 date = convert_dir_to_date(dir)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 where {\f1 convert_dir_to_date} is defined as\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def convert_dir_to_date(dir)\line
  if dir == 'current'\line
    return Time.now().to_i\line
  else\line
    dir = dir.gsub('back_', '')\line
    (year, month, day) = dir.split('_')\line
    return Time.local(year, month, day).to_i\line
  end\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That returns an integer value for the date of each directory. The last piece of meta-information you need for each commit is the committer data, which you hardcode in a global variable:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $author = 'Scott Chacon <schacon@example.com>'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you\u8217're ready to begin printing out the commit data for your importer. The initial information states that you\u8217're defining a commit object and what branch it\u8217's on, followed by the mark you\u8217've generated, the committer information and commit message, and then the previous commit, if any. The code looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 # print the import information\line
puts 'commit refs/heads/master'\line
puts 'mark :' + mark\line
puts "committer #\{$author\} #\{date\} -0700"\line
export_data('imported from ' + dir)\line
puts 'from :' + last_mark if last_mark\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You hardcode the time zone (-0700) because doing so is easy. If you\u8217're importing from another system, you must specify the time zone as an offset. The commit message must be expressed in a special format:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 data (size)\\n(contents)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The format consists of the word data, the size of the data to be read, a newline, and finally the data. Because you need to use the same format to specify the file contents later, you create a helper method, {\f1 export_data}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def export_data(string)\line
  print "data #\{string.size\}\\n#\{string\}"\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All that\u8217's left is to specify the file contents for each snapshot. This is easy, because you have each one in a directory \u8212- you can print out the {\f1 deleteall} command followed by the contents of each file in the directory. Git will then record each snapshot appropriately:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 puts 'deleteall'\line
Dir.glob("**/*").each do |file|\line
  next if !File.file?(file)\line
  inline_data(file)\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: Because many systems think of their revisions as changes from one commit to another, fast-import can also take commands with each commit to specify which files have been added, removed, or modified and what the new contents are. You could calculate the differences between snapshots and provide only this data, but doing so is more complex \u8212- you may as well give Git all the data and let it figure it out. If this is better suited to your data, check the {\f1 fast-import} man page for details about how to provide your data in this manner.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The format for listing the new file contents or specifying a modified file with the new contents is as follows:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 M 644 inline path/to/file\line
data (size)\line
(file contents)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here, 644 is the mode (if you have executable files, you need to detect and specify 755 instead), and inline says you\u8217'll list the contents immediately after this line. Your {\f1 inline_data} method looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def inline_data(file, code = 'M', mode = '644')\line
  content = File.read(file)\line
  puts "#\{code\} #\{mode\} inline #\{file\}"\line
  export_data(content)\line
end\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You reuse the {\f1 export_data} method you defined earlier, because it\u8217's the same as the way you specified your commit message data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The last thing you need to do is to return the current mark so it can be passed to the next iteration:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 return mark\par}
{\pard \ql \f0 \sa180 \li0 \fi0 NOTE: If you are running on Windows you\u8217'll need to make sure that you add one extra step. As metioned before, Windows uses CRLF for new line characters while git fast-import expects only LF. To get around this problem and make git fast-import happy, you need to tell ruby to use LF instead of CRLF:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $stdout.binmode\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's it. If you run this script, you\u8217'll get content that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ruby import.rb /opt/import_from\line
commit refs/heads/master\line
mark :1\line
committer Scott Chacon <schacon@geemail.com> 1230883200 -0700\line
data 29\line
imported from back_2009_01_02deleteall\line
M 644 inline file.rb\line
data 12\line
version two\line
commit refs/heads/master\line
mark :2\line
committer Scott Chacon <schacon@geemail.com> 1231056000 -0700\line
data 29\line
imported from back_2009_01_04from :1\line
deleteall\line
M 644 inline file.rb\line
data 14\line
version three\line
M 644 inline new.rb\line
data 16\line
new version one\line
(...)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To run the importer, pipe this output through {\f1 git fast-import} while in the Git directory you want to import into. You can create a new directory and then run {\f1 git init} in it for a starting point, and then run your script:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git init\line
Initialized empty Git repository in /opt/import_to/.git/\line
$ ruby import.rb /opt/import_from | git fast-import\line
git-fast-import statistics:\line
---------------------------------------------------------------------\line
Alloc'd objects:       5000\line
Total objects:           18 (         1 duplicates                  )\line
      blobs  :            7 (         1 duplicates          0 deltas)\line
      trees  :            6 (         0 duplicates          1 deltas)\line
      commits:            5 (         0 duplicates          0 deltas)\line
      tags   :            0 (         0 duplicates          0 deltas)\line
Total branches:           1 (         1 loads     )\line
      marks:           1024 (         5 unique    )\line
      atoms:              3\line
Memory total:          2255 KiB\line
       pools:          2098 KiB\line
     objects:           156 KiB\line
---------------------------------------------------------------------\line
pack_report: getpagesize()            =       4096\line
pack_report: core.packedGitWindowSize =   33554432\line
pack_report: core.packedGitLimit      =  268435456\line
pack_report: pack_used_ctr            =          9\line
pack_report: pack_mmap_calls          =          5\line
pack_report: pack_open_windows        =          1 /          1\line
pack_report: pack_mapped              =       1356 /       1356\line
---------------------------------------------------------------------\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As you can see, when it completes successfully, it gives you a bunch of statistics about what it accomplished. In this case, you imported 18 objects total for 5 commits into 1 branch. Now, you can run {\f1 git log} to see your new history:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -2\line
commit 10bfe7d22ce15ee25b60a824c8982157ca593d41\line
Author: Scott Chacon <schacon@example.com>\line
Date:   Sun May 3 12:57:39 2009 -0700\line
\line
    imported from current\line
\line
commit 7e519590de754d079dd73b44d695a42c9d2df452\line
Author: Scott Chacon <schacon@example.com>\line
Date:   Tue Feb 3 01:00:00 2009 -0700\line
\line
    imported from back_2009_02_03\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There you go \u8212- a nice, clean Git repository. It\u8217's important to note that nothing is checked out \u8212- you don\u8217't have any files in your working directory at first. To get them, you must reset your branch to where {\f1 master} is now:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ls\line
$ git reset --hard master\line
HEAD is now at 10bfe7d imported from current\line
$ ls\line
file.rb  lib\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can do a lot more with the {\f1 fast-import} tool \u8212- handle different modes, binary data, multiple branches and merging, tags, progress indicators, and more. A number of examples of more complex scenarios are available in the {\f1 contrib/fast-import} directory of the Git source code; one of the better ones is the {\f1 git-p4} script I just covered.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should feel comfortable using Git with Subversion or importing nearly any existing repository into a new Git one without losing data. The next chapter will cover the raw internals of Git so you can craft every single byte, if need be.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Git Internals\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may have skipped to this chapter from a previous chapter, or you may have gotten here after reading the rest of the book \u8212- in either case, this is where you\u8217'll go over the inner workings and implementation of Git. I found that learning this information was fundamentally important to understanding how useful and powerful Git is, but others have argued to me that it can be confusing and unnecessarily complex for beginners. Thus, I\u8217've made this discussion the last chapter in the book so you could read it early or later in your learning process. I leave it up to you to decide.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you\u8217're here, let\u8217's get started. First, if it isn\u8217't yet clear, Git is fundamentally a content-addressable filesystem with a VCS user interface written on top of it. You\u8217'll learn more about what this means in a bit.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the early days of Git (mostly pre 1.5), the user interface was much more complex because it emphasized this filesystem rather than a polished VCS. In the last few years, the UI has been refined until it\u8217's as clean and easy to use as any system out there; but often, the stereotype lingers about the early Git UI that was complex and difficult to learn.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The content-addressable filesystem layer is amazingly cool, so I\u8217'll cover that first in this chapter; then, you\u8217'll learn about the transport mechanisms and the repository maintenance tasks that you may eventually have to deal with.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Plumbing and Porcelain\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This book covers how to use Git with 30 or so verbs such as {\f1 checkout}, {\f1 branch}, {\f1 remote}, and so on. But because Git was initially a toolkit for a VCS rather than a full user-friendly VCS, it has a bunch of verbs that do low-level work and were designed to be chained together UNIX style or called from scripts. These commands are generally referred to as \u8220"plumbing\u8221" commands, and the more user-friendly commands are called \u8220"porcelain\u8221" commands.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The book\u8217's first eight chapters deal almost exclusively with porcelain commands. But in this chapter, you\u8217'll be dealing mostly with the lower-level plumbing commands, because they give you access to the inner workings of Git and help demonstrate how and why Git does what it does. These commands aren\u8217't meant to be used manually on the command line, but rather to be used as building blocks for new tools and custom scripts.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you run {\f1 git init} in a new or existing directory, Git creates the {\f1 .git} directory, which is where almost everything that Git stores and manipulates is located. If you want to back up or clone your repository, copying this single directory elsewhere gives you nearly everything you need. This entire chapter basically deals with the stuff in this directory. Here\u8217's what it looks like:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ls\line
HEAD\line
branches/\line
config\line
description\line
hooks/\line
index\line
info/\line
objects/\line
refs/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You may see some other files in there, but this is a fresh {\f1 git init} repository \u8212- it\u8217's what you see by default. The {\f1 branches} directory isn\u8217't used by newer Git versions, and the {\f1 description} file is only used by the GitWeb program, so don\u8217't worry about those. The {\f1 config} file contains your project-specific configuration options, and the {\f1 info} directory keeps a global exclude file for ignored patterns that you don\u8217't want to track in a .gitignore file. The {\f1 hooks} directory contains your client- or server-side hook scripts, which are discussed in detail in Chapter 7.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This leaves four important entries: the {\f1 HEAD} and {\f1 index} files and the {\f1 objects} and {\f1 refs} directories. These are the core parts of Git. The {\f1 objects} directory stores all the content for your database, the {\f1 refs} directory stores pointers into commit objects in that data (branches), the {\f1 HEAD} file points to the branch you currently have checked out, and the {\f1 index} file is where Git stores your staging area information. You\u8217'll now look at each of these sections in detail to see how Git operates.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git is a content-addressable filesystem. Great. What does that mean? It means that at the core of Git is a simple key-value data store. You can insert any kind of content into it, and it will give you back a key that you can use to retrieve the content again at any time. To demonstrate, you can use the plumbing command {\f1 hash-object}, which takes some data, stores it in your {\f1 .git} directory, and gives you back the key the data is stored as. First, you initialize a new Git repository and verify that there is nothing in the {\f1 objects} directory:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ mkdir test\line
$ cd test\line
$ git init\line
Initialized empty Git repository in /tmp/test/.git/\line
$ find .git/objects\line
.git/objects\line
.git/objects/info\line
.git/objects/pack\line
$ find .git/objects -type f\line
$\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git has initialized the {\f1 objects} directory and created {\f1 pack} and {\f1 info} subdirectories in it, but there are no regular files. Now, store some text in your Git database:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'test content' | git hash-object -w --stdin\line
d670460b4b4aece5915caf5c68d12f560a9fe3e4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 -w} tells {\f1 hash-object} to store the object; otherwise, the command simply tells you what the key would be. {\f1 --stdin} tells the command to read the content from stdin; if you don\u8217't specify this, {\f1 hash-object} expects the path to a file. The output from the command is a 40-character checksum hash. This is the SHA-1 hash \u8212- a checksum of the content you\u8217're storing plus a header, which you\u8217'll learn about in a bit. Now you can see how Git has stored your data:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/objects -type f\line
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can see a file in the {\f1 objects} directory. This is how Git stores the content initially \u8212- as a single file per piece of content, named with the SHA-1 checksum of the content and its header. The subdirectory is named with the first 2 characters of the SHA, and the filename is the remaining 38 characters.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can pull the content back out of Git with the {\f1 cat-file} command. This command is sort of a Swiss army knife for inspecting Git objects. Passing {\f1 -p} to it instructs the {\f1 cat-file} command to figure out the type of content and display it nicely for you:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\line
test content\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can add content to Git and pull it back out again. You can also do this with content in files. For example, you can do some simple version control on a file. First, create a new file and save its contents in your database:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'version 1' > test.txt\line
$ git hash-object -w test.txt\line
83baae61804e65cc73a7201a7252750c76066a30\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, write some new content to the file, and save it again:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'version 2' > test.txt\line
$ git hash-object -w test.txt\line
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your database contains the two new versions of the file as well as the first content you stored there:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/objects -type f\line
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\line
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\line
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can revert the file back to the first version\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\line
$ cat test.txt\line
version 1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 or the second version:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\line
$ cat test.txt\line
version 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But remembering the SHA-1 key for each version of your file isn\u8217't practical; plus, you aren\u8217't storing the filename in your system \u8212- just the content. This object type is called a blob. You can have Git tell you the object type of any object in Git, given its SHA-1 key, with {\f1 cat-file -t}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\line
blob\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tree Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next type you\u8217'll look at is the tree object, which solves the problem of storing the filename and also allows you to store a group of files together. Git stores content in a manner similar to a UNIX filesystem, but a bit simplified. All the content is stored as tree and blob objects, with trees corresponding to UNIX directory entries and blobs corresponding more or less to inodes or file contents. A single tree object contains one or more tree entries, each of which contains a SHA-1 pointer to a blob or subtree with its associated mode, type, and filename. For example, the most recent tree in the simplegit project may look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p master^\{tree\}\line
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\line
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\line
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 master^\{tree\}} syntax specifies the tree object that is pointed to by the last commit on your {\f1 master} branch. Notice that the {\f1 lib} subdirectory isn\u8217't a blob but a pointer to another tree:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\line
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Conceptually, the data that Git is storing is something like Figure 9-1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0901.png Figure 9-1. Simple version of the Git data model.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can create your own tree. Git normally creates a tree by taking the state of your staging area or index and writing a tree object from it. So, to create a tree object, you first have to set up an index by staging some files. To create an index with a single entry \u8212- the first version of your test.txt file \u8212- you can use the plumbing command {\f1 update-index}. You use this command to artificially add the earlier version of the test.txt file to a new staging area. You must pass it the {\f1 --add} option because the file doesn\u8217't yet exist in your staging area (you don\u8217't even have a staging area set up yet) and {\f1 --cacheinfo} because the file you\u8217're adding isn\u8217't in your directory but is in your database. Then, you specify the mode, SHA-1, and filename:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git update-index --add --cacheinfo 100644 \\\line
  83baae61804e65cc73a7201a7252750c76066a30 test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, you\u8217're specifying a mode of {\f1 100644}, which means it\u8217's a normal file. Other options are {\f1 100755}, which means it\u8217's an executable file; and {\f1 120000}, which specifies a symbolic link. The mode is taken from normal UNIX modes but is much less flexible \u8212- these three modes are the only ones that are valid for files (blobs) in Git (although other modes are used for directories and submodules).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can use the {\f1 write-tree} command to write the staging area out to a tree object. No {\f1 -w} option is needed \u8212- calling {\f1 write-tree} automatically creates a tree object from the state of the index if that tree doesn\u8217't yet exist:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git write-tree\line
d8329fc1cc938780ffdd9f94e0d364e0ea74f579\line
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\line
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also verify that this is a tree object:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\line
tree\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217'll now create a new tree with the second version of test.txt and a new file as well:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'new file' > new.txt\line
$ git update-index test.txt\line
$ git update-index --add new.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your staging area now has the new version of test.txt as well as the new file new.txt. Write out that tree (recording the state of the staging area or index to a tree object) and see what it looks like:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git write-tree\line
0155eb4229851634a0f03eb265b69f5a2d56f341\line
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\line
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\line
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that this tree has both file entries and also that the test.txt SHA is the \u8220"version 2\u8221" SHA from earlier ({\f1 1f7a7a}). Just for fun, you\u8217'll add the first tree as a subdirectory into this one. You can read trees into your staging area by calling {\f1 read-tree}. In this case, you can read an existing tree into your staging area as a subtree by using the {\f1 --prefix} option to {\f1 read-tree}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\line
$ git write-tree\line
3c4e9cd789d88d8d89c1073707c3585e41b0e614\line
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\line
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\line
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\line
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you created a working directory from the new tree you just wrote, you would get the two files in the top level of the working directory and a subdirectory named {\f1 bak} that contained the first version of the test.txt file. You can think of the data that Git contains for these structures as being like Figure 9-2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0902.png Figure 9-2. The content structure of your current Git data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Commit Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have three trees that specify the different snapshots of your project that you want to track, but the earlier problem remains: you must remember all three SHA-1 values in order to recall the snapshots. You also don\u8217't have any information about who saved the snapshots, when they were saved, or why they were saved. This is the basic information that the commit object stores for you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To create a commit object, you call {\f1 commit-tree} and specify a single tree SHA-1 and which commit objects, if any, directly preceded it. Start with the first tree you wrote:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'first commit' | git commit-tree d8329f\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you can look at your new commit object with {\f1 cat-file}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p fdf4fc3\line
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\line
author Scott Chacon <schacon@gmail.com> 1243040974 -0700\line
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700\line
\line
first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information pulled from your {\f1 user.name} and {\f1 user.email} configuration settings, with the current timestamp; a blank line, and then the commit message.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you\u8217'll write the other two commit objects, each referencing the commit that came directly before it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3\line
cac0cab538b970a37ea1e769cbbde608743bc96d\line
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab\line
1a410efbd13591db07496601ebc7a059dd55cfe9\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each of the three commit objects points to one of the three snapshot trees you created. Oddly enough, you have a real Git history now that you can view with the {\f1 git log} command, if you run it on the last commit SHA-1:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --stat 1a410e\line
commit 1a410efbd13591db07496601ebc7a059dd55cfe9\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri May 22 18:15:24 2009 -0700\line
\line
    third commit\line
\line
 bak/test.txt |    1 +\line
 1 files changed, 1 insertions(+), 0 deletions(-)\line
\line
commit cac0cab538b970a37ea1e769cbbde608743bc96d\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri May 22 18:14:29 2009 -0700\line
\line
    second commit\line
\line
 new.txt  |    1 +\line
 test.txt |    2 +-\line
 2 files changed, 2 insertions(+), 1 deletions(-)\line
\line
commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri May 22 18:09:34 2009 -0700\line
\line
    first commit\line
\line
 test.txt |    1 +\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Amazing. You\u8217've just done the low-level operations to build up a Git history without using any of the front ends. This is essentially what Git does when you run the {\f1 git add} and {\f1 git commit} commands \u8212- it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them. These three main Git objects \u8212- the blob, the tree, and the commit \u8212- are initially stored as separate files in your {\f1 .git/objects} directory. Here are all the objects in the example directory now, commented with what they store:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/objects -type f\line
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\line
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\line
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\line
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\line
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\line
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\line
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\line
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\line
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\line
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you follow all the internal pointers, you get an object graph something like Figure 9-3.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0903.png Figure 9-3. All the objects in your Git directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Object Storage\par}
{\pard \ql \f0 \sa180 \li0 \fi0 I mentioned earlier that a header is stored with the content. Let\u8217's take a minute to look at how Git stores its objects. You\u8217'll see how to store a blob object \u8212- in this case, the string \u8220"what is up, doc?\u8221" \u8212- interactively in the Ruby scripting language. You can start up interactive Ruby mode with the {\f1 irb} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ irb\line
>> content = "what is up, doc?"\line
=> "what is up, doc?"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git constructs a header that starts with the type of the object, in this case a blob. Then, it adds a space followed by the size of the content and finally a null byte:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 >> header = "blob #\{content.length\}\\0"\line
=> "blob 16\\000"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content. You can calculate the SHA-1 value of a string in Ruby by including the SHA1 digest library with the {\f1 require} command and then calling {\f1 Digest::SHA1.hexdigest()} with the string:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 >> store = header + content\line
=> "blob 16\\000what is up, doc?"\line
>> require 'digest/sha1'\line
=> true\line
>> sha1 = Digest::SHA1.hexdigest(store)\line
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git compresses the new content with zlib, which you can do in Ruby with the zlib library. First, you need to require the library and then run {\f1 Zlib::Deflate.deflate()} on the content:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 >> require 'zlib'\line
=> true\line
>> zlib_content = Zlib::Deflate.deflate(store)\line
=> "x\\234K\\312\\311OR04c(\\317H,Q\\310,V(-\\320QH\\311O\\266\\a\\000_\\034\\a\\235"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finally, you\u8217'll write your zlib-deflated content to an object on disk. You\u8217'll determine the path of the object you want to write out (the first two characters of the SHA-1 value being the subdirectory name, and the last 38 characters being the filename within that directory). In Ruby, you can use the {\f1 FileUtils.mkdir_p()} function to create the subdirectory if it doesn\u8217't exist. Then, open the file with {\f1 File.open()} and write out the previously zlib-compressed content to the file with a {\f1 write()} call on the resulting file handle:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 >> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]\line
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"\line
>> require 'fileutils'\line
=> true\line
>> FileUtils.mkdir_p(File.dirname(path))\line
=> ".git/objects/bd"\line
>> File.open(path, 'w') \{ |f| f.write zlib_content \}\line
=> 32\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's it \u8212- you\u8217've created a valid Git blob object. All Git objects are stored the same way, just with different types \u8212- instead of the string blob, the header will begin with commit or tree. Also, although the blob content can be nearly anything, the commit and tree content are very specifically formatted.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Git References\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can run something like {\f1 git log 1a410e} to look through your whole history, but you still have to remember that {\f1 1a410e} is the last commit in order to walk that history to find all those objects. You need a file in which you can store the SHA-1 value under a simple name so you can use that pointer rather than the raw SHA-1 value.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In Git, these are called \u8220"references\u8221" or \u8220"refs\u8221"; you can find the files that contain the SHA-1 values in the {\f1 .git/refs} directory. In the current project, this directory contains no files, but it does contain a simple structure:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/refs\line
.git/refs\line
.git/refs/heads\line
.git/refs/tags\line
$ find .git/refs -type f\line
$\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To create a new reference that will help you remember where your latest commit is, you can technically do something as simple as this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" > .git/refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you can use the head reference you just created instead of the SHA-1 value in your Git commands:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline  master\line
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\line
cac0cab538b970a37ea1e769cbbde608743bc96d second commit\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You aren\u8217't encouraged to directly edit the reference files. Git provides a safer command to do this if you want to update a reference called {\f1 update-ref}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That\u8217's basically what a branch in Git is: a simple pointer or reference to the head of a line of work. To create a branch back at the second commit, you can do this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git update-ref refs/heads/test cac0ca\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your branch will contain only work from that commit down:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline test\line
cac0cab538b970a37ea1e769cbbde608743bc96d second commit\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, your Git database conceptually looks something like Figure 9-4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Insert 18333fig0904.png Figure 9-4. Git directory objects with branch head references included.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you run commands like {\f1 git branch (branchname)}, Git basically runs that {\f1 update-ref} command to add the SHA-1 of the last commit of the branch you\u8217're on into whatever new reference you want to create.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The HEAD\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The question now is, when you run {\f1 git branch (branchname)}, how does Git know the SHA-1 of the last commit? The answer is the HEAD file. The HEAD file is a symbolic reference to the branch you\u8217're currently on. By symbolic reference, I mean that unlike a normal reference, it doesn\u8217't generally contain a SHA-1 value but rather a pointer to another reference. If you look at the file, you\u8217'll normally see something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/HEAD\line
ref: refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run {\f1 git checkout test}, Git updates the file to look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/HEAD\line
ref: refs/heads/test\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you run {\f1 git commit}, it creates the commit object, specifying the parent of that commit object to be whatever SHA-1 value the reference in HEAD points to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also manually edit this file, but again a safer command exists to do so: {\f1 symbolic-ref}. You can read the value of your HEAD via this command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git symbolic-ref HEAD\line
refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also set the value of HEAD:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git symbolic-ref HEAD refs/heads/test\line
$ cat .git/HEAD\line
ref: refs/heads/test\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can\u8217't set a symbolic reference outside of the refs style:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git symbolic-ref HEAD test\line
fatal: Refusing to point HEAD outside of refs/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Tags\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217've just gone over Git\u8217's three main object types, but there is a fourth. The tag object is very much like a commit object \u8212- it contains a tagger, a date, a message, and a pointer. The main difference is that a tag object points to a commit rather than a tree. It\u8217's like a branch reference, but it never moves \u8212- it always points to the same commit but gives it a friendlier name.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As discussed in Chapter 2, there are two types of tags: annotated and lightweight. You can make a lightweight tag by running something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is all a lightweight tag is \u8212- a branch that never moves. An annotated tag is more complex, however. If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit. You can see this by creating an annotated tag ({\f1 -a} specifies that it\u8217's an annotated tag):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here\u8217's the object SHA-1 value it created:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/refs/tags/v1.1\line
9585191f37f7b0fb9444f35a9bf50de191beadc2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, run the {\f1 cat-file} command on that SHA-1 value:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2\line
object 1a410efbd13591db07496601ebc7a059dd55cfe9\line
type commit\line
tag v1.1\line
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700\line
\line
test tag\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice that the object entry points to the commit SHA-1 value that you tagged. Also notice that it doesn\u8217't need to point to a commit; you can tag any Git object. In the Git source code, for example, the maintainer has added their GPG public key as a blob object and then tagged it. You can view the public key by running\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file blob junio-gpg-pub\par}
{\pard \ql \f0 \sa180 \li0 \fi0 in the Git source code repository. The Linux kernel repository also has a non-commit-pointing tag object \u8212- the first tag created points to the initial tree of the import of the source code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Remotes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The third type of reference that you\u8217'll see is a remote reference. If you add a remote and push to it, Git stores the value you last pushed to that remote for each branch in the {\f1 refs/remotes} directory. For instance, you can add a remote called {\f1 origin} and push your {\f1 master} branch to it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add origin git@github.com:schacon/simplegit-progit.git\line
$ git push origin master\line
Counting objects: 11, done.\line
Compressing objects: 100% (5/5), done.\line
Writing objects: 100% (7/7), 716 bytes, done.\line
Total 7 (delta 2), reused 4 (delta 1)\line
To git@github.com:schacon/simplegit-progit.git\line
   a11bef0..ca82a6d  master -> master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Then, you can see what the {\f1 master} branch on the {\f1 origin} remote was the last time you communicated with the server, by checking the {\f1 refs/remotes/origin/master} file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/refs/remotes/origin/master\line
ca82a6dff817ec66f44342007202690a93763949\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remote references differ from branches ({\f1 refs/heads} references) mainly in that they can\u8217't be checked out. Git moves them around as bookmarks to the last known state of where those branches were on those servers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Packfiles\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's go back to the objects database for your test Git repository. At this point, you have 11 objects \u8212- 4 blobs, 3 trees, 3 commits, and 1 tag:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/objects -type f\line
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\line
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\line
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\line
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\line
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\line
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag\line
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\line
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\line
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\line
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\line
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git compresses the contents of these files with zlib, and you\u8217're not storing much, so all these files collectively take up only 925 bytes. You\u8217'll add some larger content to the repository to demonstrate an interesting feature of Git. Add the repo.rb file from the Grit library you worked with earlier \u8212- this is about a 12K source code file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ curl https://raw.github.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb\line
$ git add repo.rb\line
$ git commit -m 'added repo.rb'\line
[master 484a592] added repo.rb\line
 3 files changed, 459 insertions(+), 2 deletions(-)\line
 delete mode 100644 bak/test.txt\line
 create mode 100644 repo.rb\line
 rewrite test.txt (100%)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you look at the resulting tree, you can see the SHA-1 value your repo.rb file got for the blob object:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p master^\{tree\}\line
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\line
100644 blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb\line
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can then check how big is that object on your disk:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ du -b .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e\line
4102    .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, modify that file a little, and see what happens:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ echo '# testing' >> repo.rb \line
$ git commit -am 'modified repo a bit'\line
[master ab1afef] modified repo a bit\line
 1 files changed, 1 insertions(+), 0 deletions(-)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Check the tree created by that commit, and you see something interesting:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p master^\{tree\}\line
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\line
100644 blob 05408d195263d853f09dca71d55116663690c27c      repo.rb\line
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The blob is now a different blob, which means that although you added only a single line to the end of a 400-line file, Git stored that new content as a completely new object:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ du -b .git/objects/05/408d195263d853f09dca71d55116663690c27c\line
4109    .git/objects/05/408d195263d853f09dca71d55116663690c27c\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have two nearly identical 4K objects on your disk. Wouldn\u8217't it be nice if Git could store one of them in full but then the second object only as the delta between it and the first?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It turns out that it can. The initial format in which Git saves objects on disk is called a loose object format. However, occasionally Git packs up several of these objects into a single binary file called a packfile in order to save space and be more efficient. Git does this if you have too many loose objects around, if you run the {\f1 git gc} command manually, or if you push to a remote server. To see what happens, you can manually ask Git to pack up the objects by calling the {\f1 git gc} command:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git gc\line
Counting objects: 17, done.\line
Delta compression using 2 threads.\line
Compressing objects: 100% (13/13), done.\line
Writing objects: 100% (17/17), done.\line
Total 17 (delta 1), reused 10 (delta 0)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you look in your objects directory, you\u8217'll find that most of your objects are gone, and a new pair of files has appeared:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/objects -type f\line
.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293\line
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\line
.git/objects/info/packs\line
.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx\line
.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The objects that remain are the blobs that aren\u8217't pointed to by any commit \u8212- in this case, the \u8220"what is up, doc?\u8221" example and the \u8220"test content\u8221" example blobs you created earlier. Because you never added them to any commits, they\u8217're considered dangling and aren\u8217't packed up in your new packfile.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other files are your new packfile and an index. The packfile is a single file containing the contents of all the objects that were removed from your filesystem. The index is a file that contains offsets into that packfile so you can quickly seek to a specific object. What is cool is that although the objects on disk before you ran the {\f1 gc} were collectively about 8K in size, the new packfile is only 4K. You\u8217've halved your disk usage by packing your objects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 How does Git do this? When Git packs objects, it looks for files that are named and sized similarly, and stores just the deltas from one version of the file to the next. You can look into the packfile and see what Git did to save space. The {\f1 git verify-pack} plumbing command allows you to see what was packed up:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git verify-pack -v \\\line
  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx\line
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 5400\line
05408d195263d853f09dca71d55116663690c27c blob   12908 3478 874\line
09f01cea547666f58d6a8d809583841a7c6f0130 tree   106 107 5086\line
1a410efbd13591db07496601ebc7a059dd55cfe9 commit 225 151 322\line
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 5381\line
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   101 105 5211\line
484a59275031909e19aadb7c92262719cfcdf19a commit 226 153 169\line
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 5362\line
9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    136 127 5476\line
9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   7 18 5193 1 \\\line
  05408d195263d853f09dca71d55116663690c27c\line
ab1afef80fac8e34258ff41fc1b867c702daa24b commit 232 157 12\line
cac0cab538b970a37ea1e769cbbde608743bc96d commit 226 154 473\line
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 5316\line
e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4352\line
f8f51d7d8a1760462eca26eebafde32087499533 tree   106 107 749\line
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 856\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit 177 122 627\line
chain length = 1: 1 object\line
pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here, the {\f1 9bc1d} blob, which if you remember was the first version of your repo.rb file, is referencing the {\f1 05408} blob, which was the second version of the file. The third column in the output is the size of the object\u8217's content, so you can see that the content of {\f1 05408} takes up 12K, but that of {\f1 9bc1d} only takes up 7 bytes. What is also interesting is that the second version of the file is the one that is stored intact, whereas the original version is stored as a delta \u8212- this is because you\u8217're most likely to need faster access to the most recent version of the file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The really nice thing about this is that it can be repacked at any time. Git will occasionally repack your database automatically, always trying to save more space. You can also manually repack at any time by running {\f1 git gc} by hand.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 The Refspec\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Throughout this book, you\u8217've used simple mappings from remote branches to local references; but they can be more complex. Suppose you add a remote like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git remote add origin git@github.com:schacon/simplegit-progit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It adds a section to your {\f1 .git/config} file, specifying the name of the remote ({\f1 origin}), the URL of the remote repository, and the refspec for fetching:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [remote "origin"]\line
       url = git@github.com:schacon/simplegit-progit.git\line
       fetch = +refs/heads/*:refs/remotes/origin/*\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The format of the refspec is an optional {\f1 +}, followed by {\f1 <src>:<dst>}, where {\f1 <src>} is the pattern for references on the remote side and {\f1 <dst>} is where those references will be written locally. The {\f1 +} tells Git to update the reference even if it isn\u8217't a fast-forward.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the default case that is automatically written by a {\f1 git remote add} command, Git fetches all the references under {\f1 refs/heads/} on the server and writes them to {\f1 refs/remotes/origin/} locally. So, if there is a {\f1 master} branch on the server, you can access the log of that branch locally via\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log origin/master\line
$ git log remotes/origin/master\line
$ git log refs/remotes/origin/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 They\u8217're all equivalent, because Git expands each of them to {\f1 refs/remotes/origin/master}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you want Git instead to pull down only the {\f1 master} branch each time, and not every other branch on the remote server, you can change the fetch line to\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 fetch = +refs/heads/master:refs/remotes/origin/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is just the default refspec for {\f1 git fetch} for that remote. If you want to do something one time, you can specify the refspec on the command line, too. To pull the {\f1 master} branch on the remote down to {\f1 origin/mymaster} locally, you can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin master:refs/remotes/origin/mymaster\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also specify multiple refspecs. On the command line, you can pull down several branches like so:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fetch origin master:refs/remotes/origin/mymaster \\\line
   topic:refs/remotes/origin/topic\line
From git@github.com:schacon/simplegit\line
 ! [rejected]        master     -> origin/mymaster  (non fast forward)\line
 * [new branch]      topic      -> origin/topic\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, the master branch pull was rejected because it wasn\u8217't a fast-forward reference. You can override that by specifying the {\f1 +} in front of the refspec.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also specify multiple refspecs for fetching in your configuration file. If you want to always fetch the master and experiment branches, add two lines:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [remote "origin"]\line
       url = git@github.com:schacon/simplegit-progit.git\line
       fetch = +refs/heads/master:refs/remotes/origin/master\line
       fetch = +refs/heads/experiment:refs/remotes/origin/experiment\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can\u8217't use partial globs in the pattern, so this would be invalid:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 fetch = +refs/heads/qa*:refs/remotes/origin/qa*\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, you can use namespacing to accomplish something like that. If you have a QA team that pushes a series of branches, and you want to get the master branch and any of the QA team\u8217's branches but nothing else, you can use a config section like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [remote "origin"]\line
       url = git@github.com:schacon/simplegit-progit.git\line
       fetch = +refs/heads/master:refs/remotes/origin/master\line
       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you have a complex workflow process that has a QA team pushing branches, developers pushing branches, and integration teams pushing and collaborating on remote branches, you can namespace them easily this way.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Pushing Refspecs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It\u8217's nice that you can fetch namespaced references that way, but how does the QA team get their branches into a {\f1 qa/} namespace in the first place? You accomplish that by using refspecs to push.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the QA team wants to push their {\f1 master} branch to {\f1 qa/master} on the remote server, they can run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin master:refs/heads/qa/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If they want Git to do that automatically each time they run {\f1 git push origin}, they can add a {\f1 push} value to their config file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 [remote "origin"]\line
       url = git@github.com:schacon/simplegit-progit.git\line
       fetch = +refs/heads/*:refs/remotes/origin/*\line
       push = refs/heads/master:refs/heads/qa/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, this will cause a {\f1 git push origin} to push the local {\f1 master} branch to the remote {\f1 qa/master} branch by default.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Deleting References\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also use the refspec to delete references from the remote server by running something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git push origin :topic\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because the refspec is {\f1 <src>:<dst>}, by leaving off the {\f1 <src>} part, this basically says to make the topic branch on the remote nothing, which deletes it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Transfer Protocols\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git can transfer data between two repositories in two major ways: over HTTP and via the so-called smart protocols used in the {\f1 file://}, {\f1 ssh://}, and {\f1 git://} transports. This section will quickly cover how these two main protocols operate.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Dumb Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git transport over HTTP is often referred to as the dumb protocol because it requires no Git-specific code on the server side during the transport process. The fetch process is a series of GET requests, where the client can assume the layout of the Git repository on the server. Let\u8217's follow the {\f1 http-fetch} process for the simplegit library:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone http://github.com/schacon/simplegit-progit.git\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first thing this command does is pull down the {\f1 info/refs} file. This file is written by the {\f1 update-server-info} command, which is why you need to enable that as a {\f1 post-receive} hook in order for the HTTP transport to work properly:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET info/refs\line
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now you have a list of the remote references and SHAs. Next, you look for what the HEAD reference is so you know what to check out when you\u8217're finished:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET HEAD\line
ref: refs/heads/master\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You need to check out the {\f1 master} branch when you\u8217've completed the process. At this point, you\u8217're ready to start the walking process. Because your starting point is the {\f1 ca82a6} commit object you saw in the {\f1 info/refs} file, you start by fetching that:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/ca/82a6dff817ec66f44342007202690a93763949\line
(179 bytes of binary data)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You get an object back \u8212- that object is in loose format on the server, and you fetched it over a static HTTP GET request. You can zlib-uncompress it, strip off the header, and look at the commit content:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git cat-file -p ca82a6dff817ec66f44342007202690a93763949\line
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\line
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
author Scott Chacon <schacon@gmail.com> 1205815931 -0700\line
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700\line
\line
changed the version number\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, you have two more objects to retrieve \u8212- {\f1 cfda3b}, which is the tree of content that the commit we just retrieved points to; and {\f1 085bb3}, which is the parent commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
(179 bytes of data)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That gives you your next commit object. Grab the tree object:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf\line
(404 - Not Found)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Oops \u8212- it looks like that tree object isn\u8217't in loose format on the server, so you get a 404 response back. There are a couple of reasons for this \u8212- the object could be in an alternate repository, or it could be in a packfile in this repository. Git checks for any listed alternates first:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/info/http-alternates\line
(empty file)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If this comes back with a list of alternate URLs, Git checks for loose files and packfiles there \u8212- this is a nice mechanism for projects that are forks of one another to share objects on disk. However, because no alternates are listed in this case, your object must be in a packfile. To see what packfiles are available on this server, you need to get the {\f1 objects/info/packs} file, which contains a listing of them (also generated by {\f1 update-server-info}):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/info/packs\line
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There is only one packfile on the server, so your object is obviously in there, but you\u8217'll check the index file to make sure. This is also useful if you have multiple packfiles on the server, so you can see which packfile contains the object you need:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx\line
(4k of binary data)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that you have the packfile index, you can see if your object is in it \u8212- because the index lists the SHAs of the objects contained in the packfile and the offsets to those objects. Your object is there, so go ahead and get the whole packfile:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 => GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack\line
(13k of binary data)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You have your tree object, so you continue walking your commits. They\u8217're all also within the packfile you just downloaded, so you don\u8217't have to do any more requests to your server. Git checks out a working copy of the {\f1 master} branch that was pointed to by the HEAD reference you downloaded at the beginning.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The entire output of this process looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git clone http://github.com/schacon/simplegit-progit.git\line
Initialized empty Git repository in /private/tmp/simplegit-progit/.git/\line
got ca82a6dff817ec66f44342007202690a93763949\line
walk ca82a6dff817ec66f44342007202690a93763949\line
got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
Getting alternates list for http://github.com/schacon/simplegit-progit.git\line
Getting pack list for http://github.com/schacon/simplegit-progit.git\line
Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835\line
Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835\line
 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf\line
walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
walk a11bef06a3f659402fe7563abf99ad00de2209e6\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Smart Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The HTTP method is simple but a bit inefficient. Using smart protocols is a more common method of transferring data. These protocols have a process on the remote end that is intelligent about Git \u8212- it can read local data and figure out what the client has or needs and generate custom data for it. There are two sets of processes for transferring data: a pair for uploading data and a pair for downloading data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Uploading Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To upload data to a remote process, Git uses the {\f1 send-pack} and {\f1 receive-pack} processes. The {\f1 send-pack} process runs on the client and connects to a {\f1 receive-pack} process on the remote side.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example, say you run {\f1 git push origin master} in your project, and {\f1 origin} is defined as a URL that uses the SSH protocol. Git fires up the {\f1 send-pack} process, which initiates a connection over SSH to your server. It tries to run a command on the remote server via an SSH call that looks something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh -x git@github.com "git-receive-pack 'schacon/simplegit-progit.git'"\line
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs\line
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic\line
0000\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 git-receive-pack} command immediately responds with one line for each reference it currently has \u8212- in this case, just the {\f1 master} branch and its SHA. The first line also has a list of the server\u8217's capabilities (here, {\f1 report-status} and {\f1 delete-refs}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each line starts with a 4-byte hex value specifying how long the rest of the line is. Your first line starts with 005b, which is 91 in hex, meaning that 91 bytes remain on that line. The next line starts with 003e, which is 62, so you read the remaining 62 bytes. The next line is 0000, meaning the server is done with its references listing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now that it knows the server\u8217's state, your {\f1 send-pack} process determines what commits it has that the server doesn\u8217't. For each reference that this push will update, the {\f1 send-pack} process tells the {\f1 receive-pack} process that information. For instance, if you\u8217're updating the {\f1 master} branch and adding an {\f1 experiment} branch, the {\f1 send-pack} response may look something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status\line
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment\line
0000\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The SHA-1 value of all \u8217'0\u8217's means that nothing was there before \u8212- because you\u8217're adding the experiment reference. If you were deleting a reference, you would see the opposite: all \u8217'0\u8217's on the right side.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git sends a line for each reference you\u8217're updating with the old SHA, the new SHA, and the reference that is being updated. The first line also has the client\u8217's capabilities. Next, the client uploads a packfile of all the objects the server doesn\u8217't have yet. Finally, the server responds with a success (or failure) indication:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 000Aunpack ok\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Downloading Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you download data, the {\f1 fetch-pack} and {\f1 upload-pack} processes are involved. The client initiates a {\f1 fetch-pack} process that connects to an {\f1 upload-pack} process on the remote side to negotiate what data will be transferred down.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are different ways to initiate the {\f1 upload-pack} process on the remote repository. You can run via SSH in the same manner as the {\f1 receive-pack} process. You can also initiate the process via the Git daemon, which listens on a server on port 9418 by default. The {\f1 fetch-pack} process sends data that looks like this to the daemon after connecting:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 003fgit-upload-pack schacon/simplegit-progit.git\\0host=myserver.com\\0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It starts with the 4 bytes specifying how much data is following, then the command to run followed by a null byte, and then the server\u8217's hostname followed by a final null byte. The Git daemon checks that the command can be run and that the repository exists and has public permissions. If everything is cool, it fires up the {\f1 upload-pack} process and hands off the request to it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you\u8217're doing the fetch over SSH, {\f1 fetch-pack} instead runs something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ ssh -x git@github.com "git-upload-pack 'schacon/simplegit-progit.git'"\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In either case, after {\f1 fetch-pack} connects, {\f1 upload-pack} sends back something like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 0088ca82a6dff817ec66f44342007202690a93763949 HEAD\\0multi_ack thin-pack \\\line
  side-band side-band-64k ofs-delta shallow no-progress include-tag\line
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master\line
003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic\line
0000\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is very similar to what {\f1 receive-pack} responds with, but the capabilities are different. In addition, it sends back the HEAD reference so the client knows what to check out if this is a clone.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point, the {\f1 fetch-pack} process looks at what objects it has and responds with the objects that it needs by sending \u8220"want\u8221" and then the SHA it wants. It sends all the objects it already has with \u8220"have\u8221" and then the SHA. At the end of this list, it writes \u8220"done\u8221" to initiate the {\f1 upload-pack} process to begin sending the packfile of the data it needs:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta\line
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\line
0000\line
0009done\par}
{\pard \ql \f0 \sa180 \li0 \fi0 That is a very basic case of the transfer protocols. In more complex cases, the client supports {\f1 multi_ack} or {\f1 side-band} capabilities; but this example shows you the basic back and forth used by the smart protocol processes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Maintenance and Data Recovery\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Occasionally, you may have to do some cleanup \u8212- make a repository more compact, clean up an imported repository, or recover lost work. This section will cover some of these scenarios.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Maintenance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Occasionally, Git automatically runs a command called \u8220"auto gc\u8221". Most of the time, this command does nothing. However, if there are too many loose objects (objects not in a packfile) or too many packfiles, Git launches a full-fledged {\f1 git gc} command. The {\f1 gc} stands for garbage collect, and the command does a number of things: it gathers up all the loose objects and places them in packfiles, it consolidates packfiles into one big packfile, and it removes objects that aren\u8217't reachable from any commit and are a few months old.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can run auto gc manually as follows:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git gc --auto\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Again, this generally does nothing. You must have around 7,000 loose objects or more than 50 packfiles for Git to fire up a real gc command. You can modify these limits with the {\f1 gc.auto} and {\f1 gc.autopacklimit} config settings, respectively.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The other thing {\f1 gc} will do is pack up your references into a single file. Suppose your repository contains the following branches and tags:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ find .git/refs -type f\line
.git/refs/heads/experiment\line
.git/refs/heads/master\line
.git/refs/tags/v1.0\line
.git/refs/tags/v1.1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you run {\f1 git gc}, you\u8217'll no longer have these files in the {\f1 refs} directory. Git will move them for the sake of efficiency into a file named {\f1 .git/packed-refs} that looks like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ cat .git/packed-refs\line
# pack-refs with: peeled\line
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment\line
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master\line
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0\line
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1\line
^1a410efbd13591db07496601ebc7a059dd55cfe9\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you update a reference, Git doesn\u8217't edit this file but instead writes a new file to {\f1 refs/heads}. To get the appropriate SHA for a given reference, Git checks for that reference in the {\f1 refs} directory and then checks the {\f1 packed-refs} file as a fallback. However, if you can\u8217't find a reference in the {\f1 refs} directory, it\u8217's probably in your {\f1 packed-refs} file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notice the last line of the file, which begins with a {\f1 ^}. This means the tag directly above is an annotated tag and that line is the commit that the annotated tag points to.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Data Recovery\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At some point in your Git journey, you may accidentally lose a commit. Generally, this happens because you force-delete a branch that had work on it, and it turns out you wanted the branch after all; or you hard-reset a branch, thus abandoning commits that you wanted something from. Assuming this happens, how can you get your commits back?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here\u8217's an example that hard-resets the master branch in your test repository to an older commit and then recovers the lost commits. First, let\u8217's review where your repository is at this point:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline\line
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit\line
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb\line
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\line
cac0cab538b970a37ea1e769cbbde608743bc96d second commit\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, move the {\f1 master} branch back to the middle commit:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9\line
HEAD is now at 1a410ef third commit\line
$ git log --pretty=oneline\line
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\line
cac0cab538b970a37ea1e769cbbde608743bc96d second commit\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You\u8217've effectively lost the top two commits \u8212- you have no branch from which those commits are reachable. You need to find the latest commit SHA and then add a branch that points to it. The trick is finding that latest commit SHA \u8212- it\u8217's not like you\u8217've memorized it, right?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Often, the quickest way is to use a tool called {\f1 git reflog}. As you\u8217're working, Git silently records what your HEAD is every time you change it. Each time you commit or change branches, the reflog is updated. The reflog is also updated by the {\f1 git update-ref} command, which is another reason to use it instead of just writing the SHA value to your ref files, as we covered in the \u8220"Git References\u8221" section of this chapter earlier. You can see where you\u8217've been at any time by running {\f1 git reflog}:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git reflog\line
1a410ef HEAD@\{0\}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD\line
ab1afef HEAD@\{1\}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here we can see the two commits that we have had checked out, however there is not much information here. To see the same information in a much more useful way, we can run {\f1 git log -g}, which will give you a normal log output for your reflog.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log -g\line
commit 1a410efbd13591db07496601ebc7a059dd55cfe9\line
Reflog: HEAD@\{0\} (Scott Chacon <schacon@gmail.com>)\line
Reflog message: updating HEAD\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri May 22 18:22:37 2009 -0700\line
\line
    third commit\line
\line
commit ab1afef80fac8e34258ff41fc1b867c702daa24b\line
Reflog: HEAD@\{1\} (Scott Chacon <schacon@gmail.com>)\line
Reflog message: updating HEAD\line
Author: Scott Chacon <schacon@gmail.com>\line
Date:   Fri May 22 18:15:24 2009 -0700\line
\line
     modified repo a bit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It looks like the bottom commit is the one you lost, so you can recover it by creating a new branch at that commit. For example, you can start a branch named {\f1 recover-branch} at that commit (ab1afef):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch recover-branch ab1afef\line
$ git log --pretty=oneline recover-branch\line
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit\line
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb\line
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\line
cac0cab538b970a37ea1e769cbbde608743bc96d second commit\line
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cool \u8212- now you have a branch named {\f1 recover-branch} that is where your {\f1 master} branch used to be, making the first two commits reachable again. Next, suppose your loss was for some reason not in the reflog \u8212- you can simulate that by removing {\f1 recover-branch} and deleting the reflog. Now the first two commits aren\u8217't reachable by anything:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git branch -D recover-branch\line
$ rm -Rf .git/logs/\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because the reflog data is kept in the {\f1 .git/logs/} directory, you effectively have no reflog. How can you recover that commit at this point? One way is to use the {\f1 git fsck} utility, which checks your database for integrity. If you run it with the {\f1 --full} option, it shows you all objects that aren\u8217't pointed to by another object:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git fsck --full\line
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4\line
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b\line
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9\line
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In this case, you can see your missing commit after the dangling commit. You can recover it the same way, by adding a branch that points to that SHA.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Removing Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are a lot of great things about Git, but one feature that can cause issues is the fact that a {\f1 git clone} downloads the entire history of the project, including every version of every file. This is fine if the whole thing is source code, because Git is highly optimized to compress that data efficiently. However, if someone at any point in the history of your project added a single huge file, every clone for all time will be forced to download that large file, even if it was removed from the project in the very next commit. Because it\u8217's reachable from the history, it will always be there.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This can be a huge problem when you\u8217're converting Subversion or Perforce repositories into Git. Because you don\u8217't download the whole history in those systems, this type of addition carries few consequences. If you did an import from another system or otherwise find that your repository is much larger than it should be, here is how you can find and remove large objects.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Be warned: this technique is destructive to your commit history. It rewrites every commit object downstream from the earliest tree you have to modify to remove a large file reference. If you do this immediately after an import, before anyone has started to base work on the commit, you\u8217're fine \u8212- otherwise, you have to notify all contributors that they must rebase their work onto your new commits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To demonstrate, you\u8217'll add a large file into your test repository, remove it in the next commit, find it, and remove it permanently from the repository. First, add a large object to your history:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 > git.tbz2\line
$ git add git.tbz2\line
$ git commit -am 'added git tarball'\line
[master 6df7640] added git tarball\line
 1 files changed, 0 insertions(+), 0 deletions(-)\line
 create mode 100644 git.tbz2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Oops \u8212- you didn\u8217't want to add a huge tarball to your project. Better get rid of it:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rm git.tbz2\line
rm 'git.tbz2'\line
$ git commit -m 'oops - removed large tarball'\line
[master da3f30d] oops - removed large tarball\line
 1 files changed, 0 insertions(+), 0 deletions(-)\line
 delete mode 100644 git.tbz2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, {\f1 gc} your database and see how much space you\u8217're using:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git gc\line
Counting objects: 21, done.\line
Delta compression using 2 threads.\line
Compressing objects: 100% (16/16), done.\line
Writing objects: 100% (21/21), done.\line
Total 21 (delta 3), reused 15 (delta 1)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can run the {\f1 count-objects} command to quickly see how much space you\u8217're using:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git count-objects -v\line
count: 4\line
size: 16\line
in-pack: 21\line
packs: 1\line
size-pack: 2016\line
prune-packable: 0\line
garbage: 0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 size-pack} entry is the size of your packfiles in kilobytes, so you\u8217're using 2MB. Before the last commit, you were using closer to 2K \u8212- clearly, removing the file from the previous commit didn\u8217't remove it from your history. Every time anyone clones this repository, they will have to clone all 2MB just to get this tiny project, because you accidentally added a big file. Let\u8217's get rid of it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First you have to find it. In this case, you already know what file it is. But suppose you didn\u8217't; how would you identify what file or files were taking up so much space? If you run {\f1 git gc}, all the objects are in a packfile; you can identify the big objects by running another plumbing command called {\f1 git verify-pack} and sorting on the third field in the output, which is file size. You can also pipe it through the {\f1 tail} command because you\u8217're only interested in the last few largest files:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n | tail -3\line
e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4667\line
05408d195263d853f09dca71d55116663690c27c blob   12908 3478 1189\line
7a9eb2fba2b1811321254ac360970fc169ba2330 blob   2056716 2056872 5401\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The big object is at the bottom: 2MB. To find out what file it is, you\u8217'll use the {\f1 rev-list} command, which you used briefly in Chapter 7. If you pass {\f1 --objects} to {\f1 rev-list}, it lists all the commit SHAs and also the blob SHAs with the file paths associated with them. You can use this to find your blob\u8217's name:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git rev-list --objects --all | grep 7a9eb2fb\line
7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now, you need to remove this file from all trees in your past. You can easily see what commits modified this file:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git log --pretty=oneline -- git.tbz2\line
da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball\line
6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You must rewrite all the commits downstream from {\f1 6df76} to fully remove this file from your Git history. To do so, you use {\f1 filter-branch}, which you used in Chapter 6:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git filter-branch --index-filter \\\line
   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..\line
Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'\line
Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)\line
Ref 'refs/heads/master' was rewritten\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 --index-filter} option is similar to the {\f1 --tree-filter} option used in Chapter 6, except that instead of passing a command that modifies files checked out on disk, you\u8217're modifying your staging area or index each time. Rather than remove a specific file with something like {\f1 rm file}, you have to remove it with {\f1 git rm --cached} \u8212- you must remove it from the index, not from disk. The reason to do it this way is speed \u8212- because Git doesn\u8217't have to check out each revision to disk before running your filter, the process can be much, much faster. You can accomplish the same task with {\f1 --tree-filter} if you want. The {\f1 --ignore-unmatch} option to {\f1 git rm} tells it not to error out if the pattern you\u8217're trying to remove isn\u8217't there. Finally, you ask {\f1 filter-branch} to rewrite your history only from the {\f1 6df7640} commit up, because you know that is where this problem started. Otherwise, it will start from the beginning and will unnecessarily take longer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Your history no longer contains a reference to that file. However, your reflog and a new set of refs that Git added when you did the {\f1 filter-branch} under {\f1 .git/refs/original} still do, so you have to remove them and then repack the database. You need to get rid of anything that has a pointer to those old commits before you repack:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ rm -Rf .git/refs/original\line
$ rm -Rf .git/logs/\line
$ git gc\line
Counting objects: 19, done.\line
Delta compression using 2 threads.\line
Compressing objects: 100% (14/14), done.\line
Writing objects: 100% (19/19), done.\line
Total 19 (delta 3), reused 16 (delta 1)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let\u8217's see how much space you saved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 $ git count-objects -v\line
count: 8\line
size: 2040\line
in-pack: 19\line
packs: 1\line
size-pack: 7\line
prune-packable: 0\line
garbage: 0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The packed repository size is down to 7K, which is much better than 2MB. You can see from the size value that the big object is still in your loose objects, so it\u8217's not gone; but it won\u8217't be transferred on a push or subsequent clone, which is what is important. If you really wanted to, you could remove the object completely by running {\f1 git prune --expire}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should have a pretty good understanding of what Git does in the background and, to some degree, how it\u8217's implemented. This chapter has covered a number of plumbing commands \u8212- commands that are lower level and simpler than the porcelain commands you\u8217've learned about in the rest of the book. Understanding how Git works at a lower level should make it easier to understand why it\u8217's doing what it\u8217's doing and also to write your own tools and helping scripts to make your specific workflow work for you.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Git as a content-addressable filesystem is a very powerful tool that you can easily use as more than just a VCS. I hope you can use your newfound knowledge of Git internals to implement your own cool application of this technology and feel more comfortable using Git in more advanced ways.\par}
}
